# In order to ensure make instructions fail if there is command that fails a pipe (ie: `go test ... | tee -a ./test_results.txt`)
# the value `-o pipefail` (or `set -o pipefail`) is added to each shell command that make runs
# otherwise in the example command pipe, only the exit code of `tee` is recorded instead of `go test` which can cause
# test to pass in CI when they should not.
SHELL = /usr/bin/env bash
.SHELLFLAGS = -o pipefail -c

# SRC_ROOT is the top of the source tree.
SRC_ROOT := $(shell git rev-parse --show-toplevel)
# SRC_PARENT_DIR is the absolute path of source tree's parent directory
SRC_PARENT_DIR := $(shell dirname $(SRC_ROOT))

COVER_DIR?=coverage
COVER_DIR_ABS?=$(SRC_ROOT)/$(COVER_DIR)

# build tags required by any component should be defined as an independent variables and later added to GO_BUILD_TAGS below
GO_BUILD_TAGS=""
# These ldflags allow the build tool to omit the symbol table, debug information, and the DWARF symbol table to downscale binary size.
GO_BUILD_LDFLAGS="-s -w"
GOTEST_TIMEOUT?= 900s
GOCMD?= go
GOOS=$(shell $(GOCMD) env GOOS)
GOARCH=$(shell $(GOCMD) env GOARCH)
GOTESTARCH?=$(GOARCH)

# On Windows arm64 neither `-race` nor cgo are not supported (cgo is not supported due to the GH runner installed gcc not having arm64 libs)
ifeq ($(GOOS)-$(GOARCH),windows-arm64)
	CGO_ENABLED_OPT?=0
else
	GOTEST_RACE_OPT?=-race
	CGO_ENABLED_OPT?=1
endif

GOTEST_OPT?=$(GOTEST_RACE_OPT) -timeout $(GOTEST_TIMEOUT) -parallel 4 --tags=$(GO_BUILD_TAGS)
GOTEST_INTEGRATION_OPT?=$(GOTEST_RACE_OPT) -timeout 360s -parallel 4 -skip Sudo
GOTEST_INTEGRATION_OPT_SUDO?=$(GOTEST_RACE_OPT) -timeout 360s -parallel 4 -exec sudo -run Sudo
COVER_OPT :=-cover -covermode=atomic -test.gocoverdir="$(COVER_DIR_ABS)"
GOTEST_OPT_WITH_INTEGRATION=$(GOTEST_INTEGRATION_OPT) -tags=integration,$(GO_BUILD_TAGS)
GOTEST_OPT_WITH_INTEGRATION_SUDO=$(GOTEST_INTEGRATION_OPT_SUDO) -tags=integration,$(GO_BUILD_TAGS)
GOTEST_OPT_WITH_INTEGRATION_COVERAGE=$(GOTEST_OPT_WITH_INTEGRATION) -coverprofile=integration-coverage.txt -covermode=atomic

DOCKERCMD ?= docker

CURR_MOD := $(shell go list -m | tr '/' '-' )

# Tools are declared in $(TOOLS_MOD_DIR)/go.mod using tool directives.
TOOLS_MOD_DIR   := $(SRC_ROOT)/internal/tools
TOOLS_MOD_FILE  := $(TOOLS_MOD_DIR)/go.mod

CHLOGGEN_CONFIG := .chloggen/config.yaml

# no trailing slash
JUNIT_OUT_DIR ?= $(TOOLS_MOD_DIR)/testresults

# Tools used by go generate commands
#
# We build the tool with GOOS= GOARCH= (i.e. for the host platform), and then
# execute the binary with the GOOS/GOARCH that the Makefile is being run with.
# This necessary for linting Windows code on non-Windows platforms, for example.
GO_TOOL = GOOS= GOARCH= $(GOCMD) tool -modfile=$(TOOLS_MOD_FILE)
MDATAGEN            = $(shell $(GO_TOOL) -n go.opentelemetry.io/collector/cmd/mdatagen)
ACTIONLINT          = $(shell $(GO_TOOL) -n github.com/rhysd/actionlint/cmd/actionlint)
ADDLICENSE          = $(shell $(GO_TOOL) -n github.com/google/addlicense)
MISSPELL            = $(shell $(GO_TOOL) -n github.com/client9/misspell/cmd/misspell -error)
MISSPELL_CORRECTION = $(shell $(GO_TOOL) -n github.com/client9/misspell/cmd/misspell -w)
LINT                = $(shell $(GO_TOOL) -n github.com/golangci/golangci-lint/v2/cmd/golangci-lint)
MULTIMOD            = $(shell $(GO_TOOL) -n go.opentelemetry.io/build-tools/multimod)
CHLOGGEN            = $(shell $(GO_TOOL) -n go.opentelemetry.io/build-tools/chloggen)
GITHUBGEN           = $(shell $(GO_TOOL) -n go.opentelemetry.io/build-tools/githubgen)
GOIMPORTS           = $(shell $(GO_TOOL) -n golang.org/x/tools/cmd/goimports)
PORTO               = $(shell $(GO_TOOL) -n github.com/jcchavezs/porto/cmd/porto)
CHECKFILE           = $(shell $(GO_TOOL) -n go.opentelemetry.io/build-tools/checkfile)
CROSSLINK           = $(shell $(GO_TOOL) -n go.opentelemetry.io/build-tools/crosslink)
GOJUNIT             = $(shell $(GO_TOOL) -n github.com/jstemmer/go-junit-report)
BUILDER             = $(shell $(GO_TOOL) -n go.opentelemetry.io/collector/cmd/builder)
GOFUMPT             = $(shell $(GO_TOOL) -n mvdan.cc/gofumpt)
GOVULNCHECK         = $(shell $(GO_TOOL) -n golang.org/x/vuln/cmd/govulncheck)
GCI                 = $(shell $(GO_TOOL) -n github.com/daixiang0/gci)
GOTESTSUM           = $(shell $(GO_TOOL) -n gotest.tools/gotestsum)
CHECKAPI            = $(shell $(GO_TOOL) -n go.opentelemetry.io/build-tools/checkapi)
MODERNIZE           = $(shell $(GO_TOOL) -n golang.org/x/tools/go/analysis/passes/modernize/cmd/modernize)

GOTESTSUM_OPT?= --rerun-fails=1

# BUILD_TYPE should be one of (dev, release).
BUILD_TYPE?=release

# All source code and documents. Used in spell check.
ALL_SRC_AND_DOC_CMD := find . -type f \( \( -name "*.md" -o -name "*.go" -o -name "*.yaml" \) -and \( -not -path '*/third_party/*' \) \) | sort

ADDLICENSE_CMD := $(ADDLICENSE) -s=only -y "" -c "The OpenTelemetry Authors"

# All source code and .sh files (evaluated when used)
ALL_SRC_AND_SHELL_CMD := find . -type f \( \( -name "*.go" -o -name "*.sh" \) -and \( -not -path '*/third_party/*' \) \) | sort

pwd:
	@pwd

.DEFAULT_GOAL := common

.PHONY: common
common: lint test

.PHONY: test
test:
	$(GOTESTSUM) $(GOTESTSUM_OPT) --packages="./..." -- $(GOTEST_OPT)

# This target is used in scoped tests.
# We do not pass GOTESTSUM_OPT so that we do not re-run failures
# and run each changed test two times.
#
# This helps us catch flakes more easily before they land on main.
test-twice:
	$(GOTESTSUM) --packages="./..." -- $(GOTEST_OPT) -count=2

.PHONY: test-with-cover
test-with-cover:
	mkdir -p $(PWD)/coverage/unit
	$(GOTESTSUM) $(GOTESTSUM_OPT) --packages="./..." -- $(GOTEST_OPT) -cover -covermode=atomic -args -test.gocoverdir="$(PWD)/coverage/unit"

.PHONY: do-unit-tests-with-cover
do-unit-tests-with-cover:
	@echo "running $(GOCMD) unit test ./... + coverage in `pwd`"
	$(GOTESTSUM) $(GOTESTSUM_OPT) --packages="./..." -- $(GOTEST_OPT) ./... $(COVER_OPT)
	$(GOCMD) tool cover -html=coverage.txt -o coverage.html

.PHONY: test-with-junit
test-with-junit:
	mkdir -p $(JUNIT_OUT_DIR)
	$(GOTESTSUM) $(GOTESTSUM_OPT) --packages="./..." --junitfile $(JUNIT_OUT_DIR)/$(CURR_MOD)-junit.xml -- $(GOTEST_OPT) ./...

.PHONY: test-with-junit-and-cover
test-with-junit-and-cover:
	mkdir -p $(COVER_DIR_ABS)
	mkdir -p $(JUNIT_OUT_DIR)
	$(GOTESTSUM) $(GOTESTSUM_OPT) --packages="./..." --junitfile $(JUNIT_OUT_DIR)/$(CURR_MOD)-junit.xml -- $(GOTEST_OPT) ./... $(COVER_OPT)

.PHONY: buildtest
buildtest:
ifneq (,$(wildcard ./*.go))
	GOARCH=$(GOTESTARCH) CGO_ENABLED=$(CGO_ENABLED_OPT) $(GOCMD) test -c -o builtunitetest.test
endif

.PHONY: runbuilttest
runbuilttest:
ifneq (,$(wildcard ./builtunitetest.test))
	$(GOTESTSUM) --raw-command -- $(GOCMD) tool test2json -p "./..." -t ./builtunitetest.test -test.v -test.failfast -test.timeout $(GOTEST_TIMEOUT)
endif

INTEGRATION_TEST_FILES := $(shell find . -name *integration_test.go)
INTEGRATION_TESTS := $(if $(INTEGRATION_TEST_FILES),$(shell cat $(INTEGRATION_TEST_FILES) | sed -n "s/func \(Test[A-Za-z0-9_]*\).*/\1/p" | xargs | sed "s/ /|/g"))
.PHONY: mod-integration-test
mod-integration-test:
	@echo "running $(GOCMD) integration test $(INTEGRATION_TESTS) in `pwd`"
	@if [ -n "$(INTEGRATION_TESTS)" ]; then \
		$(GOTESTSUM) $(GOTESTSUM_OPT) --packages="./..." -- -run "$(INTEGRATION_TESTS)" $(GOTEST_OPT_WITH_INTEGRATION); \
	else \
        echo "No integration tests in `pwd`"; \
	fi
	@if [ -e integration-coverage.txt ]; then \
		$(GOCMD) tool cover -html=integration-coverage.txt -o integration-coverage.html; \
	fi

.PHONY: mod-integration-sudo-test
mod-integration-sudo-test:
	@echo "running $(GOCMD) integration sudo (root/privileged) test $(INTEGRATION_TESTS) in `pwd`"
	@if [ -n "$(INTEGRATION_TESTS)" ]; then \
		$(GOTESTSUM) $(GOTESTSUM_OPT) --format standard-verbose --packages="./..." -- -run "$(INTEGRATION_TESTS)" $(GOTEST_OPT_WITH_INTEGRATION_SUDO); \
	else \
        echo "No integration tests in `pwd`"; \
	fi

.PHONY: do-integration-tests-with-cover
do-integration-tests-with-cover:
	@echo "running $(GOCMD) integration test $(INTEGRATION_TESTS) + coverage in `pwd`"
	@if [ -n "$(INTEGRATION_TESTS)" ]; then \
		$(GOTESTSUM) $(GOTESTSUM_OPT) --packages="./..." -- -run "$(INTEGRATION_TESTS)" $(GOTEST_OPT_WITH_INTEGRATION_COVERAGE); \
	else \
        echo "No integration tests in `pwd`"; \
	fi
	@if [ -e integration-coverage.txt ]; then \
		$(GOCMD) tool cover -html=integration-coverage.txt -o integration-coverage.html; \
	fi

.PHONY: benchmark
benchmark:
	$(GOTESTSUM) $(GOTESTSUM_OPT) --packages="$$(find . -name 'go.mod' -not -path '*/third_party/*' -not -path '*/local/*' -type f | xargs dirname | sort | uniq | xargs -L 1 bash -c 'cd $$0 && go list -f "{{ .Dir }}"' | xargs echo)" -- -bench=. -run=notests --tags=$(GO_BUILD_TAGS)

.PHONY: addlicense
addlicense:
	@ADDLICENSEOUT=$$(for f in $$($(ALL_SRC_AND_SHELL_CMD)); do \
		`$(ADDLICENSE_CMD) "$$f" 2>&1`; \
	done); \
	if [ "$$ADDLICENSEOUT" ]; then \
		echo "$(ADDLICENSE) FAILED => add License errors:\n"; \
		echo "$$ADDLICENSEOUT\n"; \
		exit 1; \
	else \
		echo "Add License finished successfully"; \
	fi

.PHONY: checklicense
checklicense:
	@licRes=$$(for f in $$($(ALL_SRC_AND_SHELL_CMD)); do \
		if awk '/Copyright The OpenTelemetry Authors|generated|GENERATED/ && NR<=3 { found=1; next } END { if (!found) print FILENAME }' $$f; then \
			continue; \
		fi; \
		if awk '/SPDX-License-Identifier: Apache-2.0|generated|GENERATED/ && NR<=4 { found=1; next } END { if (!found) print FILENAME }' $$f; then \
			continue; \
		fi; \
		$(ADDLICENSE_CMD) -check "$$f" 2>&1 || echo "$$f"; \
		done); \
	if [ -n "$${licRes}" ]; then \
		echo "license header checking failed:"; echo "$${licRes}"; \
		exit 1; \
	else \
		echo "Check License finished successfully"; \
	fi

.PHONY: checklinks
checklinks:
	command -v $(DOCKERCMD) >/dev/null 2>&1 || { echo >&2 "$(DOCKERCMD) not installed. Install before continuing"; exit 1; }
	$(DOCKERCMD) run -w /home/repo --rm \
		--mount 'type=bind,source='$(PWD)',target=/home/repo' \
		--mount 'type=bind,source='$(SRC_ROOT)/.github/lychee.toml',target=/lychee.toml' \
		lycheeverse/lychee \
		--config /lychee.toml \
		--root-dir /home/repo \
		-v \
		--no-progress './**/*.md'

.PHONY: fmt
fmt:
	$(GOFUMPT) -l -w -extra .
	$(GOIMPORTS) -w -local github.com/open-telemetry/opentelemetry-collector-contrib ./

MDATAGEN_METADATA_YAML?= metadata.yaml

.PHONY: mdatagen
mdatagen:
	@$(MDATAGEN) $(MDATAGEN_METADATA_YAML)

.PHONY: generate
generate:
ifeq ($(CURDIR),$(SRC_ROOT))
	$(MAKE) for-all CMD="$(GOCMD) generate ./..."
	$(MAKE) gofmt
	$(MAKE) gogci
else
	$(GOCMD) generate ./...
	$(MAKE) fmt
	$(MAKE) gci
endif

.PHONY: lint
lint: checklicense misspell
	$(LINT) run

.PHONY: govulncheck
govulncheck:
	$(GOVULNCHECK) ./...

.PHONY: modernize
modernize:
	$(MODERNIZE) -fix -test -tags integration -v -any -bloop -fmtappendf -forvar -mapsloop -minmax -newexpr \
		-omitzero -plusbuild \
		-rangeint -reflecttypefor -slicescontains -slicessort -stditerators -stringscut \
		-stringscutprefix -stringsseq -stringsbuilder -testingcontext -waitgroup ./...

.PHONY: tidy
tidy:
	rm -fr go.sum
	$(GOCMD) mod tidy -compat=$(GO_COMPAT_VERSION)

.PHONY: toolchain
toolchain:
	$(GOCMD) get toolchain@none

.PHONY: misspell
misspell:
	@echo "running $(MISSPELL)"
	@$(MISSPELL) $$($(ALL_SRC_AND_DOC_CMD))

.PHONY: misspell-correction
misspell-correction:
	@$(MISSPELL_CORRECTION) $$($(ALL_SRC_AND_DOC_CMD))

.PHONY: moddownload
moddownload:
	$(GOCMD) mod download

.PHONY: gci
gci:
	@echo "running $(GCI)"
	@$(GCI) write -s standard -s default -s "prefix(github.com/open-telemetry/opentelemetry-collector-contrib)" $$($(ALL_SRC_AND_DOC_CMD))

CHANGED_GOLANG_SOURCES?=$(shell git diff main --name-only | grep -E '.*\.go$$' | grep -v -E '.*_test\.go$$')
.PHONY: for-affected-components
for-affected-components:
	@echo "Checking for affected components..."
	@if [ -z '$${CHANGED_GOLANG_SOURCES}' ]; then \
		echo "No go source changes detected in shippable code."; \
	else \
		cd $(SRC_ROOT); \
		DEPENDENT_PKGS=$$(echo $${CHANGED_GOLANG_SOURCES} | xargs sed -n 's|^package .* // import "\(.*\)"$$|\1|p' | uniq); \
		if [ -z '$${DEPENDENT_PKGS}' ]; then \
			echo "No other package depends on the one being changed."; \
		else \
			DEPENDENT_PKG_DIRS=$$(echo $${DEPENDENT_PKGS} | tr ' ' '\n' | xargs -I {} grep --include=go.mod -rl {} | xargs -r dirname | uniq); \
			set -e; for dir in $$(echo $${DEPENDENT_PKG_DIRS}); do \
			(cd "$${dir}" && \
				echo "running $${CMD} in $${dir}" && \
				$${CMD} ); \
			done \
		fi \
	fi

# Do not pass GOTESTSUM_OPT so that we do not re-run failures
# and run each changed test three times.
# This helps us catch flakes more easily before they land on main.
CHANGED_GOLANG_TESTS?=$(shell git diff main --name-only | grep -E '.*_test\.go$$')
.PHONY: run-changed-tests
run-changed-tests:
	@echo "Checking for affected tests..."
	@if [ -z '$${CHANGED_GOLANG_TESTS}' ]; then \
		echo "No go test changes detected."; \
	else \
		cd $(SRC_ROOT); \
		AFFECTED_TEST_DIRS=$$(echo $${CHANGED_GOLANG_TESTS} | tr ' ' '\n' | xargs dirname | uniq); \
		if [ -z '$${AFFECTED_TEST_DIRS}' ]; then \
			echo "Failed to find the affected test directories."; \
		else \
			set -e; for dir in $$(echo $${AFFECTED_TEST_DIRS}); do \
			(cd "$${dir}" && \
				$(GOTESTSUM) --packages="./..." -- $(GOTEST_OPT) -count=3 ); \
			done \
		fi \
	fi

SRC ?= '$(CURDIR)'
FLAGS ?= '-o=$(CURDIR)/'

.PHONY: schemagen
schemagen:
	@echo "Running schemagen with filepath='$(SRC)' and flags='$(FLAGS)'"
	cd $(SRC_ROOT)/cmd/schemagen && go run . $(FLAGS) $(SRC)
