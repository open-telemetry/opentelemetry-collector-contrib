package sentryexporter

import (
	"context"
	"encoding/json"
	"io"
	"net/http"
	"strings"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/config/confighttp"
)

var testHTTPClient *http.Client

func init() {
	newHTTPClient = func(ctx context.Context, cfg confighttp.ClientConfig, host component.Host, ts component.TelemetrySettings) (*http.Client, error) {
		if testHTTPClient != nil {
			return testHTTPClient, nil
		}
		return &http.Client{
			Transport: stubRoundTripper{},
		}, nil
	}
}

// stubRoundTripper mocks the http.Client for the autogenerated tests
type stubRoundTripper struct{}

func (stubRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {
	path := req.URL.Path
	switch {
	case req.Method == http.MethodGet && strings.Contains(path, "/api/0/organizations/"):
		return jsonResp(http.StatusOK, []ProjectInfo{{
			ID:    "1",
			Slug:  "proj",
			Team:  TeamInfo{Slug: "team"},
			Teams: []TeamInfo{{Slug: "team"}},
		}})
	case req.Method == http.MethodGet && strings.Contains(path, "/keys/"):
		return jsonResp(http.StatusOK, []ProjectKey{{
			ID:       "1",
			Public:   "pubkey",
			IsActive: true,
			DSN:      DSNField{Public: "https://pub@example.ingest.sentry.io/1"},
		}})
	case req.Method == http.MethodPost && strings.Contains(path, "/projects/"):
		return jsonResp(http.StatusCreated, ProjectInfo{
			ID:   "created",
			Slug: "proj",
			Team: TeamInfo{Slug: "team"},
		})
	case req.Method == http.MethodPost && strings.Contains(path, "/integration/otlp/v1/"):
		return jsonResp(http.StatusOK, map[string]any{})
	default:
		return &http.Response{
			StatusCode: http.StatusNotFound,
			Body:       http.NoBody,
			Request:    req,
			Header:     make(http.Header),
		}, nil
	}
}

func jsonResp(status int, body any) (*http.Response, error) {
	b, _ := json.Marshal(body)
	return &http.Response{
		StatusCode: status,
		Status:     http.StatusText(status),
		Body:       io.NopCloser(strings.NewReader(string(b))),
		Header:     make(http.Header),
	}, nil
}
