apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Name }}-metadata-config
  namespace: default
data:
  server.py: |
    import json
    import os
    from http.server import BaseHTTPRequestHandler, HTTPServer
    from urllib.parse import urlparse

    # DigitalOcean metadata format (returned from /metadata/v1.json)
    DIGITALOCEAN_METADATA = {
        "droplet_id": 123456789,
        "hostname": "test-droplet.internal",
        "region": "nyc3",
        "user_data": "",
        "vendor_data": "",
        "public_keys": ["ssh-rsa AAAA... user@example.com"],
        "tags": ["env:testing", "team:observability"],
        "dns": {
            "nameservers": ["67.207.67.2", "67.207.67.3"]
        },
        "interfaces": {
            "public": [{
                "mac": "04:01:2a:0f:2a:01",
                "type": "public",
                "ipv4": {
                    "ip_address": "104.131.20.105",
                    "netmask": "255.255.192.0",
                    "gateway": "104.131.0.1"
                },
                "ipv6": {
                    "ip_address": "2604:A880:0800:0010:0000:0000:0000:0101",
                    "cidr": 64,
                    "gateway": "2604:A880:0800:0010:0000:0000:0000:0001"
                }
            }],
            "private": [{
                "mac": "04:01:2a:0f:2a:02",
                "type": "private",
                "ipv4": {
                    "ip_address": "10.132.0.2",
                    "netmask": "255.255.0.0",
                    "gateway": "10.132.0.1"
                }
            }]
        },
        "floating_ip": {
            "ipv4": {
                "ip_address": "",
                "active": False
            }
        },
        "reserved_ip": {
            "ipv4": {
                "ip_address": "",
                "active": False
            },
            "ipv6": {
                "ip_address": "",
                "active": False
            }
        },
        "features": {
            "dhcp_enabled": True,
            "vpc_peering_enabled": False
        }
    }

    class Handler(BaseHTTPRequestHandler):
        def do_GET(self):
            parsed = urlparse(self.path)
            path = parsed.path

            # Health check endpoint
            if path == "/healthz":
                body = b"ok"
                self.send_response(200)
                self.send_header("Content-Type", "text/plain; charset=utf-8")
                self.send_header("Content-Length", str(len(body)))
                self.end_headers()
                self.wfile.write(body)
                return

            # DigitalOcean metadata endpoint (all metadata as JSON)
            if path == "/metadata/v1.json":
                body = json.dumps(DIGITALOCEAN_METADATA).encode("utf-8")
                self.send_response(200)
                self.send_header("Content-Type", "application/json; charset=utf-8")
                self.send_header("Content-Length", str(len(body)))
                self.end_headers()
                self.wfile.write(body)
                return

            # Individual metadata fields (for compatibility)
            if path == "/metadata/v1/id":
                body = str(DIGITALOCEAN_METADATA["droplet_id"]).encode("utf-8")
                self.send_response(200)
                self.send_header("Content-Type", "text/plain; charset=utf-8")
                self.send_header("Content-Length", str(len(body)))
                self.end_headers()
                self.wfile.write(body)
                return

            if path == "/metadata/v1/hostname":
                body = DIGITALOCEAN_METADATA["hostname"].encode("utf-8")
                self.send_response(200)
                self.send_header("Content-Type", "text/plain; charset=utf-8")
                self.send_header("Content-Length", str(len(body)))
                self.end_headers()
                self.wfile.write(body)
                return

            if path == "/metadata/v1/region":
                body = DIGITALOCEAN_METADATA["region"].encode("utf-8")
                self.send_response(200)
                self.send_header("Content-Type", "text/plain; charset=utf-8")
                self.send_header("Content-Length", str(len(body)))
                self.end_headers()
                self.wfile.write(body)
                return

            # Not found
            self.send_response(404)
            self.end_headers()

        def log_message(self, fmt, *args):
            return

    if __name__ == "__main__":
        port = int(os.environ.get("PORT", "80"))
        server = HTTPServer(("", port), Handler)
        server.serve_forever()
