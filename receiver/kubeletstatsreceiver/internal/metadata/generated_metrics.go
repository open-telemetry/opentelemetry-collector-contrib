// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/filter"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
	"go.opentelemetry.io/collector/receiver"
)

// AttributeDirection specifies the value direction attribute.
type AttributeDirection int

const (
	_ AttributeDirection = iota
	AttributeDirectionReceive
	AttributeDirectionTransmit
)

// String returns the string representation of the AttributeDirection.
func (av AttributeDirection) String() string {
	switch av {
	case AttributeDirectionReceive:
		return "receive"
	case AttributeDirectionTransmit:
		return "transmit"
	}
	return ""
}

// MapAttributeDirection is a helper map of string to AttributeDirection attribute value.
var MapAttributeDirection = map[string]AttributeDirection{
	"receive":  AttributeDirectionReceive,
	"transmit": AttributeDirectionTransmit,
}

var MetricsInfo = metricsInfo{
	ContainerCPUTime: metricInfo{
		Name: "container.cpu.time",
	},
	ContainerCPUUsage: metricInfo{
		Name: "container.cpu.usage",
	},
	ContainerFilesystemAvailable: metricInfo{
		Name: "container.filesystem.available",
	},
	ContainerFilesystemCapacity: metricInfo{
		Name: "container.filesystem.capacity",
	},
	ContainerFilesystemUsage: metricInfo{
		Name: "container.filesystem.usage",
	},
	ContainerMemoryAvailable: metricInfo{
		Name: "container.memory.available",
	},
	ContainerMemoryMajorPageFaults: metricInfo{
		Name: "container.memory.major_page_faults",
	},
	ContainerMemoryPageFaults: metricInfo{
		Name: "container.memory.page_faults",
	},
	ContainerMemoryRss: metricInfo{
		Name: "container.memory.rss",
	},
	ContainerMemoryUsage: metricInfo{
		Name: "container.memory.usage",
	},
	ContainerMemoryWorkingSet: metricInfo{
		Name: "container.memory.working_set",
	},
	ContainerUptime: metricInfo{
		Name: "container.uptime",
	},
	K8sContainerCPUNodeUtilization: metricInfo{
		Name: "k8s.container.cpu.node.utilization",
	},
	K8sContainerCPULimitUtilization: metricInfo{
		Name: "k8s.container.cpu_limit_utilization",
	},
	K8sContainerCPURequestUtilization: metricInfo{
		Name: "k8s.container.cpu_request_utilization",
	},
	K8sContainerMemoryNodeUtilization: metricInfo{
		Name: "k8s.container.memory.node.utilization",
	},
	K8sContainerMemoryLimitUtilization: metricInfo{
		Name: "k8s.container.memory_limit_utilization",
	},
	K8sContainerMemoryRequestUtilization: metricInfo{
		Name: "k8s.container.memory_request_utilization",
	},
	K8sNodeCPUTime: metricInfo{
		Name: "k8s.node.cpu.time",
	},
	K8sNodeCPUUsage: metricInfo{
		Name: "k8s.node.cpu.usage",
	},
	K8sNodeFilesystemAvailable: metricInfo{
		Name: "k8s.node.filesystem.available",
	},
	K8sNodeFilesystemCapacity: metricInfo{
		Name: "k8s.node.filesystem.capacity",
	},
	K8sNodeFilesystemUsage: metricInfo{
		Name: "k8s.node.filesystem.usage",
	},
	K8sNodeMemoryAvailable: metricInfo{
		Name: "k8s.node.memory.available",
	},
	K8sNodeMemoryMajorPageFaults: metricInfo{
		Name: "k8s.node.memory.major_page_faults",
	},
	K8sNodeMemoryPageFaults: metricInfo{
		Name: "k8s.node.memory.page_faults",
	},
	K8sNodeMemoryRss: metricInfo{
		Name: "k8s.node.memory.rss",
	},
	K8sNodeMemoryUsage: metricInfo{
		Name: "k8s.node.memory.usage",
	},
	K8sNodeMemoryWorkingSet: metricInfo{
		Name: "k8s.node.memory.working_set",
	},
	K8sNodeNetworkErrors: metricInfo{
		Name: "k8s.node.network.errors",
	},
	K8sNodeNetworkIo: metricInfo{
		Name: "k8s.node.network.io",
	},
	K8sNodeUptime: metricInfo{
		Name: "k8s.node.uptime",
	},
	K8sPodCPUNodeUtilization: metricInfo{
		Name: "k8s.pod.cpu.node.utilization",
	},
	K8sPodCPUTime: metricInfo{
		Name: "k8s.pod.cpu.time",
	},
	K8sPodCPUUsage: metricInfo{
		Name: "k8s.pod.cpu.usage",
	},
	K8sPodCPULimitUtilization: metricInfo{
		Name: "k8s.pod.cpu_limit_utilization",
	},
	K8sPodCPURequestUtilization: metricInfo{
		Name: "k8s.pod.cpu_request_utilization",
	},
	K8sPodFilesystemAvailable: metricInfo{
		Name: "k8s.pod.filesystem.available",
	},
	K8sPodFilesystemCapacity: metricInfo{
		Name: "k8s.pod.filesystem.capacity",
	},
	K8sPodFilesystemUsage: metricInfo{
		Name: "k8s.pod.filesystem.usage",
	},
	K8sPodMemoryAvailable: metricInfo{
		Name: "k8s.pod.memory.available",
	},
	K8sPodMemoryMajorPageFaults: metricInfo{
		Name: "k8s.pod.memory.major_page_faults",
	},
	K8sPodMemoryNodeUtilization: metricInfo{
		Name: "k8s.pod.memory.node.utilization",
	},
	K8sPodMemoryPageFaults: metricInfo{
		Name: "k8s.pod.memory.page_faults",
	},
	K8sPodMemoryRss: metricInfo{
		Name: "k8s.pod.memory.rss",
	},
	K8sPodMemoryUsage: metricInfo{
		Name: "k8s.pod.memory.usage",
	},
	K8sPodMemoryWorkingSet: metricInfo{
		Name: "k8s.pod.memory.working_set",
	},
	K8sPodMemoryLimitUtilization: metricInfo{
		Name: "k8s.pod.memory_limit_utilization",
	},
	K8sPodMemoryRequestUtilization: metricInfo{
		Name: "k8s.pod.memory_request_utilization",
	},
	K8sPodNetworkErrors: metricInfo{
		Name: "k8s.pod.network.errors",
	},
	K8sPodNetworkIo: metricInfo{
		Name: "k8s.pod.network.io",
	},
	K8sPodUptime: metricInfo{
		Name: "k8s.pod.uptime",
	},
	K8sPodVolumeUsage: metricInfo{
		Name: "k8s.pod.volume.usage",
	},
	K8sVolumeAvailable: metricInfo{
		Name: "k8s.volume.available",
	},
	K8sVolumeCapacity: metricInfo{
		Name: "k8s.volume.capacity",
	},
	K8sVolumeInodes: metricInfo{
		Name: "k8s.volume.inodes",
	},
	K8sVolumeInodesFree: metricInfo{
		Name: "k8s.volume.inodes.free",
	},
	K8sVolumeInodesUsed: metricInfo{
		Name: "k8s.volume.inodes.used",
	},
}

type metricsInfo struct {
	ContainerCPUTime                     metricInfo
	ContainerCPUUsage                    metricInfo
	ContainerFilesystemAvailable         metricInfo
	ContainerFilesystemCapacity          metricInfo
	ContainerFilesystemUsage             metricInfo
	ContainerMemoryAvailable             metricInfo
	ContainerMemoryMajorPageFaults       metricInfo
	ContainerMemoryPageFaults            metricInfo
	ContainerMemoryRss                   metricInfo
	ContainerMemoryUsage                 metricInfo
	ContainerMemoryWorkingSet            metricInfo
	ContainerUptime                      metricInfo
	K8sContainerCPUNodeUtilization       metricInfo
	K8sContainerCPULimitUtilization      metricInfo
	K8sContainerCPURequestUtilization    metricInfo
	K8sContainerMemoryNodeUtilization    metricInfo
	K8sContainerMemoryLimitUtilization   metricInfo
	K8sContainerMemoryRequestUtilization metricInfo
	K8sNodeCPUTime                       metricInfo
	K8sNodeCPUUsage                      metricInfo
	K8sNodeFilesystemAvailable           metricInfo
	K8sNodeFilesystemCapacity            metricInfo
	K8sNodeFilesystemUsage               metricInfo
	K8sNodeMemoryAvailable               metricInfo
	K8sNodeMemoryMajorPageFaults         metricInfo
	K8sNodeMemoryPageFaults              metricInfo
	K8sNodeMemoryRss                     metricInfo
	K8sNodeMemoryUsage                   metricInfo
	K8sNodeMemoryWorkingSet              metricInfo
	K8sNodeNetworkErrors                 metricInfo
	K8sNodeNetworkIo                     metricInfo
	K8sNodeUptime                        metricInfo
	K8sPodCPUNodeUtilization             metricInfo
	K8sPodCPUTime                        metricInfo
	K8sPodCPUUsage                       metricInfo
	K8sPodCPULimitUtilization            metricInfo
	K8sPodCPURequestUtilization          metricInfo
	K8sPodFilesystemAvailable            metricInfo
	K8sPodFilesystemCapacity             metricInfo
	K8sPodFilesystemUsage                metricInfo
	K8sPodMemoryAvailable                metricInfo
	K8sPodMemoryMajorPageFaults          metricInfo
	K8sPodMemoryNodeUtilization          metricInfo
	K8sPodMemoryPageFaults               metricInfo
	K8sPodMemoryRss                      metricInfo
	K8sPodMemoryUsage                    metricInfo
	K8sPodMemoryWorkingSet               metricInfo
	K8sPodMemoryLimitUtilization         metricInfo
	K8sPodMemoryRequestUtilization       metricInfo
	K8sPodNetworkErrors                  metricInfo
	K8sPodNetworkIo                      metricInfo
	K8sPodUptime                         metricInfo
	K8sPodVolumeUsage                    metricInfo
	K8sVolumeAvailable                   metricInfo
	K8sVolumeCapacity                    metricInfo
	K8sVolumeInodes                      metricInfo
	K8sVolumeInodesFree                  metricInfo
	K8sVolumeInodesUsed                  metricInfo
}

type metricInfo struct {
	Name string
}

type metricContainerCPUTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.cpu.time metric with initial data.
func (m *metricContainerCPUTime) init() {
	m.data.SetName("container.cpu.time")
	m.data.SetDescription("Total cumulative CPU time (sum of all cores) spent by the container/pod/node since its creation")
	m.data.SetUnit("s")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricContainerCPUTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerCPUTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerCPUTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerCPUTime(cfg MetricConfig) metricContainerCPUTime {
	m := metricContainerCPUTime{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerCPUUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.cpu.usage metric with initial data.
func (m *metricContainerCPUUsage) init() {
	m.data.SetName("container.cpu.usage")
	m.data.SetDescription("Total CPU usage (sum of all cores per second) averaged over the sample window")
	m.data.SetUnit("{cpu}")
	m.data.SetEmptyGauge()
}

func (m *metricContainerCPUUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerCPUUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerCPUUsage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerCPUUsage(cfg MetricConfig) metricContainerCPUUsage {
	m := metricContainerCPUUsage{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerFilesystemAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.filesystem.available metric with initial data.
func (m *metricContainerFilesystemAvailable) init() {
	m.data.SetName("container.filesystem.available")
	m.data.SetDescription("Container filesystem available")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricContainerFilesystemAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerFilesystemAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerFilesystemAvailable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerFilesystemAvailable(cfg MetricConfig) metricContainerFilesystemAvailable {
	m := metricContainerFilesystemAvailable{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerFilesystemCapacity struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.filesystem.capacity metric with initial data.
func (m *metricContainerFilesystemCapacity) init() {
	m.data.SetName("container.filesystem.capacity")
	m.data.SetDescription("Container filesystem capacity")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricContainerFilesystemCapacity) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerFilesystemCapacity) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerFilesystemCapacity) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerFilesystemCapacity(cfg MetricConfig) metricContainerFilesystemCapacity {
	m := metricContainerFilesystemCapacity{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerFilesystemUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.filesystem.usage metric with initial data.
func (m *metricContainerFilesystemUsage) init() {
	m.data.SetName("container.filesystem.usage")
	m.data.SetDescription("Container filesystem usage")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricContainerFilesystemUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerFilesystemUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerFilesystemUsage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerFilesystemUsage(cfg MetricConfig) metricContainerFilesystemUsage {
	m := metricContainerFilesystemUsage{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerMemoryAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.memory.available metric with initial data.
func (m *metricContainerMemoryAvailable) init() {
	m.data.SetName("container.memory.available")
	m.data.SetDescription("Container memory available")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricContainerMemoryAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerMemoryAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerMemoryAvailable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerMemoryAvailable(cfg MetricConfig) metricContainerMemoryAvailable {
	m := metricContainerMemoryAvailable{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerMemoryMajorPageFaults struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.memory.major_page_faults metric with initial data.
func (m *metricContainerMemoryMajorPageFaults) init() {
	m.data.SetName("container.memory.major_page_faults")
	m.data.SetDescription("Container memory major_page_faults")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricContainerMemoryMajorPageFaults) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerMemoryMajorPageFaults) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerMemoryMajorPageFaults) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerMemoryMajorPageFaults(cfg MetricConfig) metricContainerMemoryMajorPageFaults {
	m := metricContainerMemoryMajorPageFaults{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerMemoryPageFaults struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.memory.page_faults metric with initial data.
func (m *metricContainerMemoryPageFaults) init() {
	m.data.SetName("container.memory.page_faults")
	m.data.SetDescription("Container memory page_faults")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricContainerMemoryPageFaults) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerMemoryPageFaults) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerMemoryPageFaults) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerMemoryPageFaults(cfg MetricConfig) metricContainerMemoryPageFaults {
	m := metricContainerMemoryPageFaults{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerMemoryRss struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.memory.rss metric with initial data.
func (m *metricContainerMemoryRss) init() {
	m.data.SetName("container.memory.rss")
	m.data.SetDescription("Container memory rss")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricContainerMemoryRss) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerMemoryRss) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerMemoryRss) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerMemoryRss(cfg MetricConfig) metricContainerMemoryRss {
	m := metricContainerMemoryRss{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerMemoryUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.memory.usage metric with initial data.
func (m *metricContainerMemoryUsage) init() {
	m.data.SetName("container.memory.usage")
	m.data.SetDescription("Container memory usage")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricContainerMemoryUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerMemoryUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerMemoryUsage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerMemoryUsage(cfg MetricConfig) metricContainerMemoryUsage {
	m := metricContainerMemoryUsage{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerMemoryWorkingSet struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.memory.working_set metric with initial data.
func (m *metricContainerMemoryWorkingSet) init() {
	m.data.SetName("container.memory.working_set")
	m.data.SetDescription("Container memory working_set")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricContainerMemoryWorkingSet) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerMemoryWorkingSet) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerMemoryWorkingSet) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerMemoryWorkingSet(cfg MetricConfig) metricContainerMemoryWorkingSet {
	m := metricContainerMemoryWorkingSet{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerUptime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.uptime metric with initial data.
func (m *metricContainerUptime) init() {
	m.data.SetName("container.uptime")
	m.data.SetDescription("The time since the container started")
	m.data.SetUnit("s")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricContainerUptime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerUptime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerUptime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerUptime(cfg MetricConfig) metricContainerUptime {
	m := metricContainerUptime{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sContainerCPUNodeUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.container.cpu.node.utilization metric with initial data.
func (m *metricK8sContainerCPUNodeUtilization) init() {
	m.data.SetName("k8s.container.cpu.node.utilization")
	m.data.SetDescription("Container cpu utilization as a ratio of the node's capacity")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sContainerCPUNodeUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sContainerCPUNodeUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sContainerCPUNodeUtilization) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sContainerCPUNodeUtilization(cfg MetricConfig) metricK8sContainerCPUNodeUtilization {
	m := metricK8sContainerCPUNodeUtilization{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sContainerCPULimitUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.container.cpu_limit_utilization metric with initial data.
func (m *metricK8sContainerCPULimitUtilization) init() {
	m.data.SetName("k8s.container.cpu_limit_utilization")
	m.data.SetDescription("Container cpu utilization as a ratio of the container's limits")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sContainerCPULimitUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sContainerCPULimitUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sContainerCPULimitUtilization) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sContainerCPULimitUtilization(cfg MetricConfig) metricK8sContainerCPULimitUtilization {
	m := metricK8sContainerCPULimitUtilization{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sContainerCPURequestUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.container.cpu_request_utilization metric with initial data.
func (m *metricK8sContainerCPURequestUtilization) init() {
	m.data.SetName("k8s.container.cpu_request_utilization")
	m.data.SetDescription("Container cpu utilization as a ratio of the container's requests")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sContainerCPURequestUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sContainerCPURequestUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sContainerCPURequestUtilization) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sContainerCPURequestUtilization(cfg MetricConfig) metricK8sContainerCPURequestUtilization {
	m := metricK8sContainerCPURequestUtilization{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sContainerMemoryNodeUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.container.memory.node.utilization metric with initial data.
func (m *metricK8sContainerMemoryNodeUtilization) init() {
	m.data.SetName("k8s.container.memory.node.utilization")
	m.data.SetDescription("Container memory utilization as a ratio of the node's capacity")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sContainerMemoryNodeUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sContainerMemoryNodeUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sContainerMemoryNodeUtilization) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sContainerMemoryNodeUtilization(cfg MetricConfig) metricK8sContainerMemoryNodeUtilization {
	m := metricK8sContainerMemoryNodeUtilization{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sContainerMemoryLimitUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.container.memory_limit_utilization metric with initial data.
func (m *metricK8sContainerMemoryLimitUtilization) init() {
	m.data.SetName("k8s.container.memory_limit_utilization")
	m.data.SetDescription("Container memory utilization as a ratio of the container's limits")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sContainerMemoryLimitUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sContainerMemoryLimitUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sContainerMemoryLimitUtilization) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sContainerMemoryLimitUtilization(cfg MetricConfig) metricK8sContainerMemoryLimitUtilization {
	m := metricK8sContainerMemoryLimitUtilization{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sContainerMemoryRequestUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.container.memory_request_utilization metric with initial data.
func (m *metricK8sContainerMemoryRequestUtilization) init() {
	m.data.SetName("k8s.container.memory_request_utilization")
	m.data.SetDescription("Container memory utilization as a ratio of the container's requests")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sContainerMemoryRequestUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sContainerMemoryRequestUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sContainerMemoryRequestUtilization) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sContainerMemoryRequestUtilization(cfg MetricConfig) metricK8sContainerMemoryRequestUtilization {
	m := metricK8sContainerMemoryRequestUtilization{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeCPUTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.cpu.time metric with initial data.
func (m *metricK8sNodeCPUTime) init() {
	m.data.SetName("k8s.node.cpu.time")
	m.data.SetDescription("Total cumulative CPU time (sum of all cores) spent by the container/pod/node since its creation")
	m.data.SetUnit("s")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricK8sNodeCPUTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeCPUTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeCPUTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeCPUTime(cfg MetricConfig) metricK8sNodeCPUTime {
	m := metricK8sNodeCPUTime{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeCPUUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.cpu.usage metric with initial data.
func (m *metricK8sNodeCPUUsage) init() {
	m.data.SetName("k8s.node.cpu.usage")
	m.data.SetDescription("Total CPU usage (sum of all cores per second) averaged over the sample window")
	m.data.SetUnit("{cpu}")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeCPUUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeCPUUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeCPUUsage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeCPUUsage(cfg MetricConfig) metricK8sNodeCPUUsage {
	m := metricK8sNodeCPUUsage{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeFilesystemAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.filesystem.available metric with initial data.
func (m *metricK8sNodeFilesystemAvailable) init() {
	m.data.SetName("k8s.node.filesystem.available")
	m.data.SetDescription("Node filesystem available")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeFilesystemAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeFilesystemAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeFilesystemAvailable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeFilesystemAvailable(cfg MetricConfig) metricK8sNodeFilesystemAvailable {
	m := metricK8sNodeFilesystemAvailable{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeFilesystemCapacity struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.filesystem.capacity metric with initial data.
func (m *metricK8sNodeFilesystemCapacity) init() {
	m.data.SetName("k8s.node.filesystem.capacity")
	m.data.SetDescription("Node filesystem capacity")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeFilesystemCapacity) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeFilesystemCapacity) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeFilesystemCapacity) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeFilesystemCapacity(cfg MetricConfig) metricK8sNodeFilesystemCapacity {
	m := metricK8sNodeFilesystemCapacity{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeFilesystemUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.filesystem.usage metric with initial data.
func (m *metricK8sNodeFilesystemUsage) init() {
	m.data.SetName("k8s.node.filesystem.usage")
	m.data.SetDescription("Node filesystem usage")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeFilesystemUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeFilesystemUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeFilesystemUsage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeFilesystemUsage(cfg MetricConfig) metricK8sNodeFilesystemUsage {
	m := metricK8sNodeFilesystemUsage{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeMemoryAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.memory.available metric with initial data.
func (m *metricK8sNodeMemoryAvailable) init() {
	m.data.SetName("k8s.node.memory.available")
	m.data.SetDescription("Node memory available")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeMemoryAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeMemoryAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeMemoryAvailable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeMemoryAvailable(cfg MetricConfig) metricK8sNodeMemoryAvailable {
	m := metricK8sNodeMemoryAvailable{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeMemoryMajorPageFaults struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.memory.major_page_faults metric with initial data.
func (m *metricK8sNodeMemoryMajorPageFaults) init() {
	m.data.SetName("k8s.node.memory.major_page_faults")
	m.data.SetDescription("Node memory major_page_faults")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeMemoryMajorPageFaults) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeMemoryMajorPageFaults) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeMemoryMajorPageFaults) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeMemoryMajorPageFaults(cfg MetricConfig) metricK8sNodeMemoryMajorPageFaults {
	m := metricK8sNodeMemoryMajorPageFaults{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeMemoryPageFaults struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.memory.page_faults metric with initial data.
func (m *metricK8sNodeMemoryPageFaults) init() {
	m.data.SetName("k8s.node.memory.page_faults")
	m.data.SetDescription("Node memory page_faults")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeMemoryPageFaults) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeMemoryPageFaults) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeMemoryPageFaults) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeMemoryPageFaults(cfg MetricConfig) metricK8sNodeMemoryPageFaults {
	m := metricK8sNodeMemoryPageFaults{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeMemoryRss struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.memory.rss metric with initial data.
func (m *metricK8sNodeMemoryRss) init() {
	m.data.SetName("k8s.node.memory.rss")
	m.data.SetDescription("Node memory rss")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeMemoryRss) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeMemoryRss) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeMemoryRss) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeMemoryRss(cfg MetricConfig) metricK8sNodeMemoryRss {
	m := metricK8sNodeMemoryRss{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeMemoryUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.memory.usage metric with initial data.
func (m *metricK8sNodeMemoryUsage) init() {
	m.data.SetName("k8s.node.memory.usage")
	m.data.SetDescription("Node memory usage")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeMemoryUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeMemoryUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeMemoryUsage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeMemoryUsage(cfg MetricConfig) metricK8sNodeMemoryUsage {
	m := metricK8sNodeMemoryUsage{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeMemoryWorkingSet struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.memory.working_set metric with initial data.
func (m *metricK8sNodeMemoryWorkingSet) init() {
	m.data.SetName("k8s.node.memory.working_set")
	m.data.SetDescription("Node memory working_set")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeMemoryWorkingSet) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeMemoryWorkingSet) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeMemoryWorkingSet) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeMemoryWorkingSet(cfg MetricConfig) metricK8sNodeMemoryWorkingSet {
	m := metricK8sNodeMemoryWorkingSet{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeNetworkErrors struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.network.errors metric with initial data.
func (m *metricK8sNodeNetworkErrors) init() {
	m.data.SetName("k8s.node.network.errors")
	m.data.SetDescription("Node network errors")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricK8sNodeNetworkErrors) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, interfaceAttributeValue string, directionAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("interface", interfaceAttributeValue)
	dp.Attributes().PutStr("direction", directionAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeNetworkErrors) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeNetworkErrors) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeNetworkErrors(cfg MetricConfig) metricK8sNodeNetworkErrors {
	m := metricK8sNodeNetworkErrors{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeNetworkIo struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.network.io metric with initial data.
func (m *metricK8sNodeNetworkIo) init() {
	m.data.SetName("k8s.node.network.io")
	m.data.SetDescription("Node network IO")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricK8sNodeNetworkIo) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, interfaceAttributeValue string, directionAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("interface", interfaceAttributeValue)
	dp.Attributes().PutStr("direction", directionAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeNetworkIo) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeNetworkIo) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeNetworkIo(cfg MetricConfig) metricK8sNodeNetworkIo {
	m := metricK8sNodeNetworkIo{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeUptime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.uptime metric with initial data.
func (m *metricK8sNodeUptime) init() {
	m.data.SetName("k8s.node.uptime")
	m.data.SetDescription("The time since the node started")
	m.data.SetUnit("s")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricK8sNodeUptime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeUptime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeUptime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeUptime(cfg MetricConfig) metricK8sNodeUptime {
	m := metricK8sNodeUptime{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodCPUNodeUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.cpu.node.utilization metric with initial data.
func (m *metricK8sPodCPUNodeUtilization) init() {
	m.data.SetName("k8s.pod.cpu.node.utilization")
	m.data.SetDescription("Pod cpu utilization as a ratio of the node's capacity")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodCPUNodeUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodCPUNodeUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodCPUNodeUtilization) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodCPUNodeUtilization(cfg MetricConfig) metricK8sPodCPUNodeUtilization {
	m := metricK8sPodCPUNodeUtilization{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodCPUTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.cpu.time metric with initial data.
func (m *metricK8sPodCPUTime) init() {
	m.data.SetName("k8s.pod.cpu.time")
	m.data.SetDescription("Total cumulative CPU time (sum of all cores) spent by the container/pod/node since its creation")
	m.data.SetUnit("s")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricK8sPodCPUTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodCPUTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodCPUTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodCPUTime(cfg MetricConfig) metricK8sPodCPUTime {
	m := metricK8sPodCPUTime{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodCPUUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.cpu.usage metric with initial data.
func (m *metricK8sPodCPUUsage) init() {
	m.data.SetName("k8s.pod.cpu.usage")
	m.data.SetDescription("Total CPU usage (sum of all cores per second) averaged over the sample window")
	m.data.SetUnit("{cpu}")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodCPUUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodCPUUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodCPUUsage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodCPUUsage(cfg MetricConfig) metricK8sPodCPUUsage {
	m := metricK8sPodCPUUsage{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodCPULimitUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.cpu_limit_utilization metric with initial data.
func (m *metricK8sPodCPULimitUtilization) init() {
	m.data.SetName("k8s.pod.cpu_limit_utilization")
	m.data.SetDescription("Pod cpu utilization as a ratio of the pod's total container limits. If any container is missing a limit the metric is not emitted.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodCPULimitUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodCPULimitUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodCPULimitUtilization) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodCPULimitUtilization(cfg MetricConfig) metricK8sPodCPULimitUtilization {
	m := metricK8sPodCPULimitUtilization{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodCPURequestUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.cpu_request_utilization metric with initial data.
func (m *metricK8sPodCPURequestUtilization) init() {
	m.data.SetName("k8s.pod.cpu_request_utilization")
	m.data.SetDescription("Pod cpu utilization as a ratio of the pod's total container requests. If any container is missing a request the metric is not emitted.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodCPURequestUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodCPURequestUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodCPURequestUtilization) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodCPURequestUtilization(cfg MetricConfig) metricK8sPodCPURequestUtilization {
	m := metricK8sPodCPURequestUtilization{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodFilesystemAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.filesystem.available metric with initial data.
func (m *metricK8sPodFilesystemAvailable) init() {
	m.data.SetName("k8s.pod.filesystem.available")
	m.data.SetDescription("Pod filesystem available")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodFilesystemAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodFilesystemAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodFilesystemAvailable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodFilesystemAvailable(cfg MetricConfig) metricK8sPodFilesystemAvailable {
	m := metricK8sPodFilesystemAvailable{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodFilesystemCapacity struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.filesystem.capacity metric with initial data.
func (m *metricK8sPodFilesystemCapacity) init() {
	m.data.SetName("k8s.pod.filesystem.capacity")
	m.data.SetDescription("Pod filesystem capacity")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodFilesystemCapacity) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodFilesystemCapacity) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodFilesystemCapacity) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodFilesystemCapacity(cfg MetricConfig) metricK8sPodFilesystemCapacity {
	m := metricK8sPodFilesystemCapacity{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodFilesystemUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.filesystem.usage metric with initial data.
func (m *metricK8sPodFilesystemUsage) init() {
	m.data.SetName("k8s.pod.filesystem.usage")
	m.data.SetDescription("Pod filesystem usage")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodFilesystemUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodFilesystemUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodFilesystemUsage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodFilesystemUsage(cfg MetricConfig) metricK8sPodFilesystemUsage {
	m := metricK8sPodFilesystemUsage{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodMemoryAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.memory.available metric with initial data.
func (m *metricK8sPodMemoryAvailable) init() {
	m.data.SetName("k8s.pod.memory.available")
	m.data.SetDescription("Pod memory available")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodMemoryAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodMemoryAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodMemoryAvailable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodMemoryAvailable(cfg MetricConfig) metricK8sPodMemoryAvailable {
	m := metricK8sPodMemoryAvailable{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodMemoryMajorPageFaults struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.memory.major_page_faults metric with initial data.
func (m *metricK8sPodMemoryMajorPageFaults) init() {
	m.data.SetName("k8s.pod.memory.major_page_faults")
	m.data.SetDescription("Pod memory major_page_faults")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodMemoryMajorPageFaults) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodMemoryMajorPageFaults) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodMemoryMajorPageFaults) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodMemoryMajorPageFaults(cfg MetricConfig) metricK8sPodMemoryMajorPageFaults {
	m := metricK8sPodMemoryMajorPageFaults{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodMemoryNodeUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.memory.node.utilization metric with initial data.
func (m *metricK8sPodMemoryNodeUtilization) init() {
	m.data.SetName("k8s.pod.memory.node.utilization")
	m.data.SetDescription("Pod memory utilization as a ratio of the node's capacity")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodMemoryNodeUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodMemoryNodeUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodMemoryNodeUtilization) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodMemoryNodeUtilization(cfg MetricConfig) metricK8sPodMemoryNodeUtilization {
	m := metricK8sPodMemoryNodeUtilization{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodMemoryPageFaults struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.memory.page_faults metric with initial data.
func (m *metricK8sPodMemoryPageFaults) init() {
	m.data.SetName("k8s.pod.memory.page_faults")
	m.data.SetDescription("Pod memory page_faults")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodMemoryPageFaults) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodMemoryPageFaults) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodMemoryPageFaults) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodMemoryPageFaults(cfg MetricConfig) metricK8sPodMemoryPageFaults {
	m := metricK8sPodMemoryPageFaults{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodMemoryRss struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.memory.rss metric with initial data.
func (m *metricK8sPodMemoryRss) init() {
	m.data.SetName("k8s.pod.memory.rss")
	m.data.SetDescription("Pod memory rss")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodMemoryRss) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodMemoryRss) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodMemoryRss) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodMemoryRss(cfg MetricConfig) metricK8sPodMemoryRss {
	m := metricK8sPodMemoryRss{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodMemoryUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.memory.usage metric with initial data.
func (m *metricK8sPodMemoryUsage) init() {
	m.data.SetName("k8s.pod.memory.usage")
	m.data.SetDescription("Pod memory usage")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodMemoryUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodMemoryUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodMemoryUsage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodMemoryUsage(cfg MetricConfig) metricK8sPodMemoryUsage {
	m := metricK8sPodMemoryUsage{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodMemoryWorkingSet struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.memory.working_set metric with initial data.
func (m *metricK8sPodMemoryWorkingSet) init() {
	m.data.SetName("k8s.pod.memory.working_set")
	m.data.SetDescription("Pod memory working_set")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodMemoryWorkingSet) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodMemoryWorkingSet) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodMemoryWorkingSet) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodMemoryWorkingSet(cfg MetricConfig) metricK8sPodMemoryWorkingSet {
	m := metricK8sPodMemoryWorkingSet{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodMemoryLimitUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.memory_limit_utilization metric with initial data.
func (m *metricK8sPodMemoryLimitUtilization) init() {
	m.data.SetName("k8s.pod.memory_limit_utilization")
	m.data.SetDescription("Pod memory utilization as a ratio of the pod's total container limits. If any container is missing a limit the metric is not emitted.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodMemoryLimitUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodMemoryLimitUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodMemoryLimitUtilization) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodMemoryLimitUtilization(cfg MetricConfig) metricK8sPodMemoryLimitUtilization {
	m := metricK8sPodMemoryLimitUtilization{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodMemoryRequestUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.memory_request_utilization metric with initial data.
func (m *metricK8sPodMemoryRequestUtilization) init() {
	m.data.SetName("k8s.pod.memory_request_utilization")
	m.data.SetDescription("Pod memory utilization as a ratio of the pod's total container requests. If any container is missing a request the metric is not emitted.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodMemoryRequestUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodMemoryRequestUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodMemoryRequestUtilization) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodMemoryRequestUtilization(cfg MetricConfig) metricK8sPodMemoryRequestUtilization {
	m := metricK8sPodMemoryRequestUtilization{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodNetworkErrors struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.network.errors metric with initial data.
func (m *metricK8sPodNetworkErrors) init() {
	m.data.SetName("k8s.pod.network.errors")
	m.data.SetDescription("Pod network errors")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricK8sPodNetworkErrors) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, interfaceAttributeValue string, directionAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("interface", interfaceAttributeValue)
	dp.Attributes().PutStr("direction", directionAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodNetworkErrors) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodNetworkErrors) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodNetworkErrors(cfg MetricConfig) metricK8sPodNetworkErrors {
	m := metricK8sPodNetworkErrors{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodNetworkIo struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.network.io metric with initial data.
func (m *metricK8sPodNetworkIo) init() {
	m.data.SetName("k8s.pod.network.io")
	m.data.SetDescription("Pod network IO")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricK8sPodNetworkIo) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, interfaceAttributeValue string, directionAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("interface", interfaceAttributeValue)
	dp.Attributes().PutStr("direction", directionAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodNetworkIo) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodNetworkIo) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodNetworkIo(cfg MetricConfig) metricK8sPodNetworkIo {
	m := metricK8sPodNetworkIo{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodUptime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.uptime metric with initial data.
func (m *metricK8sPodUptime) init() {
	m.data.SetName("k8s.pod.uptime")
	m.data.SetDescription("The time since the pod started")
	m.data.SetUnit("s")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricK8sPodUptime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodUptime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodUptime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodUptime(cfg MetricConfig) metricK8sPodUptime {
	m := metricK8sPodUptime{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodVolumeUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.volume.usage metric with initial data.
func (m *metricK8sPodVolumeUsage) init() {
	m.data.SetName("k8s.pod.volume.usage")
	m.data.SetDescription("The number of used bytes in the pod volume.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricK8sPodVolumeUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodVolumeUsage) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodVolumeUsage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodVolumeUsage(cfg MetricConfig) metricK8sPodVolumeUsage {
	m := metricK8sPodVolumeUsage{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sVolumeAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.volume.available metric with initial data.
func (m *metricK8sVolumeAvailable) init() {
	m.data.SetName("k8s.volume.available")
	m.data.SetDescription("The number of available bytes in the volume.")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sVolumeAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sVolumeAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sVolumeAvailable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sVolumeAvailable(cfg MetricConfig) metricK8sVolumeAvailable {
	m := metricK8sVolumeAvailable{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sVolumeCapacity struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.volume.capacity metric with initial data.
func (m *metricK8sVolumeCapacity) init() {
	m.data.SetName("k8s.volume.capacity")
	m.data.SetDescription("The total capacity in bytes of the volume.")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sVolumeCapacity) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sVolumeCapacity) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sVolumeCapacity) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sVolumeCapacity(cfg MetricConfig) metricK8sVolumeCapacity {
	m := metricK8sVolumeCapacity{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sVolumeInodes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.volume.inodes metric with initial data.
func (m *metricK8sVolumeInodes) init() {
	m.data.SetName("k8s.volume.inodes")
	m.data.SetDescription("The total inodes in the filesystem.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sVolumeInodes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sVolumeInodes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sVolumeInodes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sVolumeInodes(cfg MetricConfig) metricK8sVolumeInodes {
	m := metricK8sVolumeInodes{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sVolumeInodesFree struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.volume.inodes.free metric with initial data.
func (m *metricK8sVolumeInodesFree) init() {
	m.data.SetName("k8s.volume.inodes.free")
	m.data.SetDescription("The free inodes in the filesystem.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sVolumeInodesFree) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sVolumeInodesFree) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sVolumeInodesFree) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sVolumeInodesFree(cfg MetricConfig) metricK8sVolumeInodesFree {
	m := metricK8sVolumeInodesFree{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sVolumeInodesUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.volume.inodes.used metric with initial data.
func (m *metricK8sVolumeInodesUsed) init() {
	m.data.SetName("k8s.volume.inodes.used")
	m.data.SetDescription("The inodes used by the filesystem. This may not equal inodes - free because filesystem may share inodes with other filesystems.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sVolumeInodesUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sVolumeInodesUsed) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sVolumeInodesUsed) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sVolumeInodesUsed(cfg MetricConfig) metricK8sVolumeInodesUsed {
	m := metricK8sVolumeInodesUsed{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user config.
type MetricsBuilder struct {
	config                                     MetricsBuilderConfig // config of the metrics builder.
	startTime                                  pcommon.Timestamp    // start time that will be applied to all recorded data points.
	metricsCapacity                            int                  // maximum observed number of metrics per resource.
	metricsBuffer                              pmetric.Metrics      // accumulates metrics data before emitting.
	buildInfo                                  component.BuildInfo  // contains version information.
	resourceAttributeIncludeFilter             map[string]filter.Filter
	resourceAttributeExcludeFilter             map[string]filter.Filter
	metricContainerCPUTime                     metricContainerCPUTime
	metricContainerCPUUsage                    metricContainerCPUUsage
	metricContainerFilesystemAvailable         metricContainerFilesystemAvailable
	metricContainerFilesystemCapacity          metricContainerFilesystemCapacity
	metricContainerFilesystemUsage             metricContainerFilesystemUsage
	metricContainerMemoryAvailable             metricContainerMemoryAvailable
	metricContainerMemoryMajorPageFaults       metricContainerMemoryMajorPageFaults
	metricContainerMemoryPageFaults            metricContainerMemoryPageFaults
	metricContainerMemoryRss                   metricContainerMemoryRss
	metricContainerMemoryUsage                 metricContainerMemoryUsage
	metricContainerMemoryWorkingSet            metricContainerMemoryWorkingSet
	metricContainerUptime                      metricContainerUptime
	metricK8sContainerCPUNodeUtilization       metricK8sContainerCPUNodeUtilization
	metricK8sContainerCPULimitUtilization      metricK8sContainerCPULimitUtilization
	metricK8sContainerCPURequestUtilization    metricK8sContainerCPURequestUtilization
	metricK8sContainerMemoryNodeUtilization    metricK8sContainerMemoryNodeUtilization
	metricK8sContainerMemoryLimitUtilization   metricK8sContainerMemoryLimitUtilization
	metricK8sContainerMemoryRequestUtilization metricK8sContainerMemoryRequestUtilization
	metricK8sNodeCPUTime                       metricK8sNodeCPUTime
	metricK8sNodeCPUUsage                      metricK8sNodeCPUUsage
	metricK8sNodeFilesystemAvailable           metricK8sNodeFilesystemAvailable
	metricK8sNodeFilesystemCapacity            metricK8sNodeFilesystemCapacity
	metricK8sNodeFilesystemUsage               metricK8sNodeFilesystemUsage
	metricK8sNodeMemoryAvailable               metricK8sNodeMemoryAvailable
	metricK8sNodeMemoryMajorPageFaults         metricK8sNodeMemoryMajorPageFaults
	metricK8sNodeMemoryPageFaults              metricK8sNodeMemoryPageFaults
	metricK8sNodeMemoryRss                     metricK8sNodeMemoryRss
	metricK8sNodeMemoryUsage                   metricK8sNodeMemoryUsage
	metricK8sNodeMemoryWorkingSet              metricK8sNodeMemoryWorkingSet
	metricK8sNodeNetworkErrors                 metricK8sNodeNetworkErrors
	metricK8sNodeNetworkIo                     metricK8sNodeNetworkIo
	metricK8sNodeUptime                        metricK8sNodeUptime
	metricK8sPodCPUNodeUtilization             metricK8sPodCPUNodeUtilization
	metricK8sPodCPUTime                        metricK8sPodCPUTime
	metricK8sPodCPUUsage                       metricK8sPodCPUUsage
	metricK8sPodCPULimitUtilization            metricK8sPodCPULimitUtilization
	metricK8sPodCPURequestUtilization          metricK8sPodCPURequestUtilization
	metricK8sPodFilesystemAvailable            metricK8sPodFilesystemAvailable
	metricK8sPodFilesystemCapacity             metricK8sPodFilesystemCapacity
	metricK8sPodFilesystemUsage                metricK8sPodFilesystemUsage
	metricK8sPodMemoryAvailable                metricK8sPodMemoryAvailable
	metricK8sPodMemoryMajorPageFaults          metricK8sPodMemoryMajorPageFaults
	metricK8sPodMemoryNodeUtilization          metricK8sPodMemoryNodeUtilization
	metricK8sPodMemoryPageFaults               metricK8sPodMemoryPageFaults
	metricK8sPodMemoryRss                      metricK8sPodMemoryRss
	metricK8sPodMemoryUsage                    metricK8sPodMemoryUsage
	metricK8sPodMemoryWorkingSet               metricK8sPodMemoryWorkingSet
	metricK8sPodMemoryLimitUtilization         metricK8sPodMemoryLimitUtilization
	metricK8sPodMemoryRequestUtilization       metricK8sPodMemoryRequestUtilization
	metricK8sPodNetworkErrors                  metricK8sPodNetworkErrors
	metricK8sPodNetworkIo                      metricK8sPodNetworkIo
	metricK8sPodUptime                         metricK8sPodUptime
	metricK8sPodVolumeUsage                    metricK8sPodVolumeUsage
	metricK8sVolumeAvailable                   metricK8sVolumeAvailable
	metricK8sVolumeCapacity                    metricK8sVolumeCapacity
	metricK8sVolumeInodes                      metricK8sVolumeInodes
	metricK8sVolumeInodesFree                  metricK8sVolumeInodesFree
	metricK8sVolumeInodesUsed                  metricK8sVolumeInodesUsed
}

// MetricBuilderOption applies changes to default metrics builder.
type MetricBuilderOption interface {
	apply(*MetricsBuilder)
}

type metricBuilderOptionFunc func(mb *MetricsBuilder)

func (mbof metricBuilderOptionFunc) apply(mb *MetricsBuilder) {
	mbof(mb)
}

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) MetricBuilderOption {
	return metricBuilderOptionFunc(func(mb *MetricsBuilder) {
		mb.startTime = startTime
	})
}
func NewMetricsBuilder(mbc MetricsBuilderConfig, settings receiver.Settings, options ...MetricBuilderOption) *MetricsBuilder {
	if mbc.ResourceAttributes.AwsVolumeID.Enabled {
		settings.Logger.Warn("[WARNING] `aws.volume.id` should not be enabled: This resource_attribute is deprecated and will be removed soon")
	}
	if mbc.ResourceAttributes.FsType.Enabled {
		settings.Logger.Warn("[WARNING] `fs.type` should not be enabled: This resource_attribute is deprecated and will be removed soon")
	}
	if mbc.ResourceAttributes.GcePdName.Enabled {
		settings.Logger.Warn("[WARNING] `gce.pd.name` should not be enabled: This resource_attribute is deprecated and will be removed soon")
	}
	if mbc.ResourceAttributes.GlusterfsEndpointsName.Enabled {
		settings.Logger.Warn("[WARNING] `glusterfs.endpoints.name` should not be enabled: This resource_attribute is deprecated and will be removed soon")
	}
	if mbc.ResourceAttributes.GlusterfsPath.Enabled {
		settings.Logger.Warn("[WARNING] `glusterfs.path` should not be enabled: This resource_attribute is deprecated and will be removed soon")
	}
	if mbc.ResourceAttributes.Partition.Enabled {
		settings.Logger.Warn("[WARNING] `partition` should not be enabled: This resource_attribute is deprecated and will be removed soon")
	}
	mb := &MetricsBuilder{
		config:                                     mbc,
		startTime:                                  pcommon.NewTimestampFromTime(time.Now()),
		metricsBuffer:                              pmetric.NewMetrics(),
		buildInfo:                                  settings.BuildInfo,
		metricContainerCPUTime:                     newMetricContainerCPUTime(mbc.Metrics.ContainerCPUTime),
		metricContainerCPUUsage:                    newMetricContainerCPUUsage(mbc.Metrics.ContainerCPUUsage),
		metricContainerFilesystemAvailable:         newMetricContainerFilesystemAvailable(mbc.Metrics.ContainerFilesystemAvailable),
		metricContainerFilesystemCapacity:          newMetricContainerFilesystemCapacity(mbc.Metrics.ContainerFilesystemCapacity),
		metricContainerFilesystemUsage:             newMetricContainerFilesystemUsage(mbc.Metrics.ContainerFilesystemUsage),
		metricContainerMemoryAvailable:             newMetricContainerMemoryAvailable(mbc.Metrics.ContainerMemoryAvailable),
		metricContainerMemoryMajorPageFaults:       newMetricContainerMemoryMajorPageFaults(mbc.Metrics.ContainerMemoryMajorPageFaults),
		metricContainerMemoryPageFaults:            newMetricContainerMemoryPageFaults(mbc.Metrics.ContainerMemoryPageFaults),
		metricContainerMemoryRss:                   newMetricContainerMemoryRss(mbc.Metrics.ContainerMemoryRss),
		metricContainerMemoryUsage:                 newMetricContainerMemoryUsage(mbc.Metrics.ContainerMemoryUsage),
		metricContainerMemoryWorkingSet:            newMetricContainerMemoryWorkingSet(mbc.Metrics.ContainerMemoryWorkingSet),
		metricContainerUptime:                      newMetricContainerUptime(mbc.Metrics.ContainerUptime),
		metricK8sContainerCPUNodeUtilization:       newMetricK8sContainerCPUNodeUtilization(mbc.Metrics.K8sContainerCPUNodeUtilization),
		metricK8sContainerCPULimitUtilization:      newMetricK8sContainerCPULimitUtilization(mbc.Metrics.K8sContainerCPULimitUtilization),
		metricK8sContainerCPURequestUtilization:    newMetricK8sContainerCPURequestUtilization(mbc.Metrics.K8sContainerCPURequestUtilization),
		metricK8sContainerMemoryNodeUtilization:    newMetricK8sContainerMemoryNodeUtilization(mbc.Metrics.K8sContainerMemoryNodeUtilization),
		metricK8sContainerMemoryLimitUtilization:   newMetricK8sContainerMemoryLimitUtilization(mbc.Metrics.K8sContainerMemoryLimitUtilization),
		metricK8sContainerMemoryRequestUtilization: newMetricK8sContainerMemoryRequestUtilization(mbc.Metrics.K8sContainerMemoryRequestUtilization),
		metricK8sNodeCPUTime:                       newMetricK8sNodeCPUTime(mbc.Metrics.K8sNodeCPUTime),
		metricK8sNodeCPUUsage:                      newMetricK8sNodeCPUUsage(mbc.Metrics.K8sNodeCPUUsage),
		metricK8sNodeFilesystemAvailable:           newMetricK8sNodeFilesystemAvailable(mbc.Metrics.K8sNodeFilesystemAvailable),
		metricK8sNodeFilesystemCapacity:            newMetricK8sNodeFilesystemCapacity(mbc.Metrics.K8sNodeFilesystemCapacity),
		metricK8sNodeFilesystemUsage:               newMetricK8sNodeFilesystemUsage(mbc.Metrics.K8sNodeFilesystemUsage),
		metricK8sNodeMemoryAvailable:               newMetricK8sNodeMemoryAvailable(mbc.Metrics.K8sNodeMemoryAvailable),
		metricK8sNodeMemoryMajorPageFaults:         newMetricK8sNodeMemoryMajorPageFaults(mbc.Metrics.K8sNodeMemoryMajorPageFaults),
		metricK8sNodeMemoryPageFaults:              newMetricK8sNodeMemoryPageFaults(mbc.Metrics.K8sNodeMemoryPageFaults),
		metricK8sNodeMemoryRss:                     newMetricK8sNodeMemoryRss(mbc.Metrics.K8sNodeMemoryRss),
		metricK8sNodeMemoryUsage:                   newMetricK8sNodeMemoryUsage(mbc.Metrics.K8sNodeMemoryUsage),
		metricK8sNodeMemoryWorkingSet:              newMetricK8sNodeMemoryWorkingSet(mbc.Metrics.K8sNodeMemoryWorkingSet),
		metricK8sNodeNetworkErrors:                 newMetricK8sNodeNetworkErrors(mbc.Metrics.K8sNodeNetworkErrors),
		metricK8sNodeNetworkIo:                     newMetricK8sNodeNetworkIo(mbc.Metrics.K8sNodeNetworkIo),
		metricK8sNodeUptime:                        newMetricK8sNodeUptime(mbc.Metrics.K8sNodeUptime),
		metricK8sPodCPUNodeUtilization:             newMetricK8sPodCPUNodeUtilization(mbc.Metrics.K8sPodCPUNodeUtilization),
		metricK8sPodCPUTime:                        newMetricK8sPodCPUTime(mbc.Metrics.K8sPodCPUTime),
		metricK8sPodCPUUsage:                       newMetricK8sPodCPUUsage(mbc.Metrics.K8sPodCPUUsage),
		metricK8sPodCPULimitUtilization:            newMetricK8sPodCPULimitUtilization(mbc.Metrics.K8sPodCPULimitUtilization),
		metricK8sPodCPURequestUtilization:          newMetricK8sPodCPURequestUtilization(mbc.Metrics.K8sPodCPURequestUtilization),
		metricK8sPodFilesystemAvailable:            newMetricK8sPodFilesystemAvailable(mbc.Metrics.K8sPodFilesystemAvailable),
		metricK8sPodFilesystemCapacity:             newMetricK8sPodFilesystemCapacity(mbc.Metrics.K8sPodFilesystemCapacity),
		metricK8sPodFilesystemUsage:                newMetricK8sPodFilesystemUsage(mbc.Metrics.K8sPodFilesystemUsage),
		metricK8sPodMemoryAvailable:                newMetricK8sPodMemoryAvailable(mbc.Metrics.K8sPodMemoryAvailable),
		metricK8sPodMemoryMajorPageFaults:          newMetricK8sPodMemoryMajorPageFaults(mbc.Metrics.K8sPodMemoryMajorPageFaults),
		metricK8sPodMemoryNodeUtilization:          newMetricK8sPodMemoryNodeUtilization(mbc.Metrics.K8sPodMemoryNodeUtilization),
		metricK8sPodMemoryPageFaults:               newMetricK8sPodMemoryPageFaults(mbc.Metrics.K8sPodMemoryPageFaults),
		metricK8sPodMemoryRss:                      newMetricK8sPodMemoryRss(mbc.Metrics.K8sPodMemoryRss),
		metricK8sPodMemoryUsage:                    newMetricK8sPodMemoryUsage(mbc.Metrics.K8sPodMemoryUsage),
		metricK8sPodMemoryWorkingSet:               newMetricK8sPodMemoryWorkingSet(mbc.Metrics.K8sPodMemoryWorkingSet),
		metricK8sPodMemoryLimitUtilization:         newMetricK8sPodMemoryLimitUtilization(mbc.Metrics.K8sPodMemoryLimitUtilization),
		metricK8sPodMemoryRequestUtilization:       newMetricK8sPodMemoryRequestUtilization(mbc.Metrics.K8sPodMemoryRequestUtilization),
		metricK8sPodNetworkErrors:                  newMetricK8sPodNetworkErrors(mbc.Metrics.K8sPodNetworkErrors),
		metricK8sPodNetworkIo:                      newMetricK8sPodNetworkIo(mbc.Metrics.K8sPodNetworkIo),
		metricK8sPodUptime:                         newMetricK8sPodUptime(mbc.Metrics.K8sPodUptime),
		metricK8sPodVolumeUsage:                    newMetricK8sPodVolumeUsage(mbc.Metrics.K8sPodVolumeUsage),
		metricK8sVolumeAvailable:                   newMetricK8sVolumeAvailable(mbc.Metrics.K8sVolumeAvailable),
		metricK8sVolumeCapacity:                    newMetricK8sVolumeCapacity(mbc.Metrics.K8sVolumeCapacity),
		metricK8sVolumeInodes:                      newMetricK8sVolumeInodes(mbc.Metrics.K8sVolumeInodes),
		metricK8sVolumeInodesFree:                  newMetricK8sVolumeInodesFree(mbc.Metrics.K8sVolumeInodesFree),
		metricK8sVolumeInodesUsed:                  newMetricK8sVolumeInodesUsed(mbc.Metrics.K8sVolumeInodesUsed),
		resourceAttributeIncludeFilter:             make(map[string]filter.Filter),
		resourceAttributeExcludeFilter:             make(map[string]filter.Filter),
	}
	if mbc.ResourceAttributes.AwsVolumeID.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["aws.volume.id"] = filter.CreateFilter(mbc.ResourceAttributes.AwsVolumeID.MetricsInclude)
	}
	if mbc.ResourceAttributes.AwsVolumeID.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["aws.volume.id"] = filter.CreateFilter(mbc.ResourceAttributes.AwsVolumeID.MetricsExclude)
	}
	if mbc.ResourceAttributes.ContainerID.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["container.id"] = filter.CreateFilter(mbc.ResourceAttributes.ContainerID.MetricsInclude)
	}
	if mbc.ResourceAttributes.ContainerID.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["container.id"] = filter.CreateFilter(mbc.ResourceAttributes.ContainerID.MetricsExclude)
	}
	if mbc.ResourceAttributes.FsType.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["fs.type"] = filter.CreateFilter(mbc.ResourceAttributes.FsType.MetricsInclude)
	}
	if mbc.ResourceAttributes.FsType.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["fs.type"] = filter.CreateFilter(mbc.ResourceAttributes.FsType.MetricsExclude)
	}
	if mbc.ResourceAttributes.GcePdName.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["gce.pd.name"] = filter.CreateFilter(mbc.ResourceAttributes.GcePdName.MetricsInclude)
	}
	if mbc.ResourceAttributes.GcePdName.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["gce.pd.name"] = filter.CreateFilter(mbc.ResourceAttributes.GcePdName.MetricsExclude)
	}
	if mbc.ResourceAttributes.GlusterfsEndpointsName.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["glusterfs.endpoints.name"] = filter.CreateFilter(mbc.ResourceAttributes.GlusterfsEndpointsName.MetricsInclude)
	}
	if mbc.ResourceAttributes.GlusterfsEndpointsName.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["glusterfs.endpoints.name"] = filter.CreateFilter(mbc.ResourceAttributes.GlusterfsEndpointsName.MetricsExclude)
	}
	if mbc.ResourceAttributes.GlusterfsPath.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["glusterfs.path"] = filter.CreateFilter(mbc.ResourceAttributes.GlusterfsPath.MetricsInclude)
	}
	if mbc.ResourceAttributes.GlusterfsPath.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["glusterfs.path"] = filter.CreateFilter(mbc.ResourceAttributes.GlusterfsPath.MetricsExclude)
	}
	if mbc.ResourceAttributes.K8sContainerName.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["k8s.container.name"] = filter.CreateFilter(mbc.ResourceAttributes.K8sContainerName.MetricsInclude)
	}
	if mbc.ResourceAttributes.K8sContainerName.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["k8s.container.name"] = filter.CreateFilter(mbc.ResourceAttributes.K8sContainerName.MetricsExclude)
	}
	if mbc.ResourceAttributes.K8sNamespaceName.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["k8s.namespace.name"] = filter.CreateFilter(mbc.ResourceAttributes.K8sNamespaceName.MetricsInclude)
	}
	if mbc.ResourceAttributes.K8sNamespaceName.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["k8s.namespace.name"] = filter.CreateFilter(mbc.ResourceAttributes.K8sNamespaceName.MetricsExclude)
	}
	if mbc.ResourceAttributes.K8sNodeName.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["k8s.node.name"] = filter.CreateFilter(mbc.ResourceAttributes.K8sNodeName.MetricsInclude)
	}
	if mbc.ResourceAttributes.K8sNodeName.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["k8s.node.name"] = filter.CreateFilter(mbc.ResourceAttributes.K8sNodeName.MetricsExclude)
	}
	if mbc.ResourceAttributes.K8sPersistentvolumeclaimName.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["k8s.persistentvolumeclaim.name"] = filter.CreateFilter(mbc.ResourceAttributes.K8sPersistentvolumeclaimName.MetricsInclude)
	}
	if mbc.ResourceAttributes.K8sPersistentvolumeclaimName.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["k8s.persistentvolumeclaim.name"] = filter.CreateFilter(mbc.ResourceAttributes.K8sPersistentvolumeclaimName.MetricsExclude)
	}
	if mbc.ResourceAttributes.K8sPodName.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["k8s.pod.name"] = filter.CreateFilter(mbc.ResourceAttributes.K8sPodName.MetricsInclude)
	}
	if mbc.ResourceAttributes.K8sPodName.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["k8s.pod.name"] = filter.CreateFilter(mbc.ResourceAttributes.K8sPodName.MetricsExclude)
	}
	if mbc.ResourceAttributes.K8sPodUID.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["k8s.pod.uid"] = filter.CreateFilter(mbc.ResourceAttributes.K8sPodUID.MetricsInclude)
	}
	if mbc.ResourceAttributes.K8sPodUID.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["k8s.pod.uid"] = filter.CreateFilter(mbc.ResourceAttributes.K8sPodUID.MetricsExclude)
	}
	if mbc.ResourceAttributes.K8sVolumeName.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["k8s.volume.name"] = filter.CreateFilter(mbc.ResourceAttributes.K8sVolumeName.MetricsInclude)
	}
	if mbc.ResourceAttributes.K8sVolumeName.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["k8s.volume.name"] = filter.CreateFilter(mbc.ResourceAttributes.K8sVolumeName.MetricsExclude)
	}
	if mbc.ResourceAttributes.K8sVolumeType.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["k8s.volume.type"] = filter.CreateFilter(mbc.ResourceAttributes.K8sVolumeType.MetricsInclude)
	}
	if mbc.ResourceAttributes.K8sVolumeType.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["k8s.volume.type"] = filter.CreateFilter(mbc.ResourceAttributes.K8sVolumeType.MetricsExclude)
	}
	if mbc.ResourceAttributes.Partition.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["partition"] = filter.CreateFilter(mbc.ResourceAttributes.Partition.MetricsInclude)
	}
	if mbc.ResourceAttributes.Partition.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["partition"] = filter.CreateFilter(mbc.ResourceAttributes.Partition.MetricsExclude)
	}

	for _, op := range options {
		op.apply(mb)
	}
	return mb
}

// NewResourceBuilder returns a new resource builder that should be used to build a resource associated with for the emitted metrics.
func (mb *MetricsBuilder) NewResourceBuilder() *ResourceBuilder {
	return NewResourceBuilder(mb.config.ResourceAttributes)
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (mb *MetricsBuilder) updateCapacity(rm pmetric.ResourceMetrics) {
	if mb.metricsCapacity < rm.ScopeMetrics().At(0).Metrics().Len() {
		mb.metricsCapacity = rm.ScopeMetrics().At(0).Metrics().Len()
	}
}

// ResourceMetricsOption applies changes to provided resource metrics.
type ResourceMetricsOption interface {
	apply(pmetric.ResourceMetrics)
}

type resourceMetricsOptionFunc func(pmetric.ResourceMetrics)

func (rmof resourceMetricsOptionFunc) apply(rm pmetric.ResourceMetrics) {
	rmof(rm)
}

// WithResource sets the provided resource on the emitted ResourceMetrics.
// It's recommended to use ResourceBuilder to create the resource.
func WithResource(res pcommon.Resource) ResourceMetricsOption {
	return resourceMetricsOptionFunc(func(rm pmetric.ResourceMetrics) {
		res.CopyTo(rm.Resource())
	})
}

// WithStartTimeOverride overrides start time for all the resource metrics data points.
// This option should be only used if different start time has to be set on metrics coming from different resources.
func WithStartTimeOverride(start pcommon.Timestamp) ResourceMetricsOption {
	return resourceMetricsOptionFunc(func(rm pmetric.ResourceMetrics) {
		var dps pmetric.NumberDataPointSlice
		metrics := rm.ScopeMetrics().At(0).Metrics()
		for i := 0; i < metrics.Len(); i++ {
			switch metrics.At(i).Type() {
			case pmetric.MetricTypeGauge:
				dps = metrics.At(i).Gauge().DataPoints()
			case pmetric.MetricTypeSum:
				dps = metrics.At(i).Sum().DataPoints()
			}
			for j := 0; j < dps.Len(); j++ {
				dps.At(j).SetStartTimestamp(start)
			}
		}
	})
}

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead.
// Resource attributes should be provided as ResourceMetricsOption arguments.
func (mb *MetricsBuilder) EmitForResource(options ...ResourceMetricsOption) {
	rm := pmetric.NewResourceMetrics()
	ils := rm.ScopeMetrics().AppendEmpty()
	ils.Scope().SetName(ScopeName)
	ils.Scope().SetVersion(mb.buildInfo.Version)
	ils.Metrics().EnsureCapacity(mb.metricsCapacity)
	mb.metricContainerCPUTime.emit(ils.Metrics())
	mb.metricContainerCPUUsage.emit(ils.Metrics())
	mb.metricContainerFilesystemAvailable.emit(ils.Metrics())
	mb.metricContainerFilesystemCapacity.emit(ils.Metrics())
	mb.metricContainerFilesystemUsage.emit(ils.Metrics())
	mb.metricContainerMemoryAvailable.emit(ils.Metrics())
	mb.metricContainerMemoryMajorPageFaults.emit(ils.Metrics())
	mb.metricContainerMemoryPageFaults.emit(ils.Metrics())
	mb.metricContainerMemoryRss.emit(ils.Metrics())
	mb.metricContainerMemoryUsage.emit(ils.Metrics())
	mb.metricContainerMemoryWorkingSet.emit(ils.Metrics())
	mb.metricContainerUptime.emit(ils.Metrics())
	mb.metricK8sContainerCPUNodeUtilization.emit(ils.Metrics())
	mb.metricK8sContainerCPULimitUtilization.emit(ils.Metrics())
	mb.metricK8sContainerCPURequestUtilization.emit(ils.Metrics())
	mb.metricK8sContainerMemoryNodeUtilization.emit(ils.Metrics())
	mb.metricK8sContainerMemoryLimitUtilization.emit(ils.Metrics())
	mb.metricK8sContainerMemoryRequestUtilization.emit(ils.Metrics())
	mb.metricK8sNodeCPUTime.emit(ils.Metrics())
	mb.metricK8sNodeCPUUsage.emit(ils.Metrics())
	mb.metricK8sNodeFilesystemAvailable.emit(ils.Metrics())
	mb.metricK8sNodeFilesystemCapacity.emit(ils.Metrics())
	mb.metricK8sNodeFilesystemUsage.emit(ils.Metrics())
	mb.metricK8sNodeMemoryAvailable.emit(ils.Metrics())
	mb.metricK8sNodeMemoryMajorPageFaults.emit(ils.Metrics())
	mb.metricK8sNodeMemoryPageFaults.emit(ils.Metrics())
	mb.metricK8sNodeMemoryRss.emit(ils.Metrics())
	mb.metricK8sNodeMemoryUsage.emit(ils.Metrics())
	mb.metricK8sNodeMemoryWorkingSet.emit(ils.Metrics())
	mb.metricK8sNodeNetworkErrors.emit(ils.Metrics())
	mb.metricK8sNodeNetworkIo.emit(ils.Metrics())
	mb.metricK8sNodeUptime.emit(ils.Metrics())
	mb.metricK8sPodCPUNodeUtilization.emit(ils.Metrics())
	mb.metricK8sPodCPUTime.emit(ils.Metrics())
	mb.metricK8sPodCPUUsage.emit(ils.Metrics())
	mb.metricK8sPodCPULimitUtilization.emit(ils.Metrics())
	mb.metricK8sPodCPURequestUtilization.emit(ils.Metrics())
	mb.metricK8sPodFilesystemAvailable.emit(ils.Metrics())
	mb.metricK8sPodFilesystemCapacity.emit(ils.Metrics())
	mb.metricK8sPodFilesystemUsage.emit(ils.Metrics())
	mb.metricK8sPodMemoryAvailable.emit(ils.Metrics())
	mb.metricK8sPodMemoryMajorPageFaults.emit(ils.Metrics())
	mb.metricK8sPodMemoryNodeUtilization.emit(ils.Metrics())
	mb.metricK8sPodMemoryPageFaults.emit(ils.Metrics())
	mb.metricK8sPodMemoryRss.emit(ils.Metrics())
	mb.metricK8sPodMemoryUsage.emit(ils.Metrics())
	mb.metricK8sPodMemoryWorkingSet.emit(ils.Metrics())
	mb.metricK8sPodMemoryLimitUtilization.emit(ils.Metrics())
	mb.metricK8sPodMemoryRequestUtilization.emit(ils.Metrics())
	mb.metricK8sPodNetworkErrors.emit(ils.Metrics())
	mb.metricK8sPodNetworkIo.emit(ils.Metrics())
	mb.metricK8sPodUptime.emit(ils.Metrics())
	mb.metricK8sPodVolumeUsage.emit(ils.Metrics())
	mb.metricK8sVolumeAvailable.emit(ils.Metrics())
	mb.metricK8sVolumeCapacity.emit(ils.Metrics())
	mb.metricK8sVolumeInodes.emit(ils.Metrics())
	mb.metricK8sVolumeInodesFree.emit(ils.Metrics())
	mb.metricK8sVolumeInodesUsed.emit(ils.Metrics())

	for _, op := range options {
		op.apply(rm)
	}
	for attr, filter := range mb.resourceAttributeIncludeFilter {
		if val, ok := rm.Resource().Attributes().Get(attr); ok && !filter.Matches(val.AsString()) {
			return
		}
	}
	for attr, filter := range mb.resourceAttributeExcludeFilter {
		if val, ok := rm.Resource().Attributes().Get(attr); ok && filter.Matches(val.AsString()) {
			return
		}
	}

	if ils.Metrics().Len() > 0 {
		mb.updateCapacity(rm)
		rm.MoveTo(mb.metricsBuffer.ResourceMetrics().AppendEmpty())
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user config, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit(options ...ResourceMetricsOption) pmetric.Metrics {
	mb.EmitForResource(options...)
	metrics := mb.metricsBuffer
	mb.metricsBuffer = pmetric.NewMetrics()
	return metrics
}

// RecordContainerCPUTimeDataPoint adds a data point to container.cpu.time metric.
func (mb *MetricsBuilder) RecordContainerCPUTimeDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricContainerCPUTime.recordDataPoint(mb.startTime, ts, val)
}

// RecordContainerCPUUsageDataPoint adds a data point to container.cpu.usage metric.
func (mb *MetricsBuilder) RecordContainerCPUUsageDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricContainerCPUUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordContainerFilesystemAvailableDataPoint adds a data point to container.filesystem.available metric.
func (mb *MetricsBuilder) RecordContainerFilesystemAvailableDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricContainerFilesystemAvailable.recordDataPoint(mb.startTime, ts, val)
}

// RecordContainerFilesystemCapacityDataPoint adds a data point to container.filesystem.capacity metric.
func (mb *MetricsBuilder) RecordContainerFilesystemCapacityDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricContainerFilesystemCapacity.recordDataPoint(mb.startTime, ts, val)
}

// RecordContainerFilesystemUsageDataPoint adds a data point to container.filesystem.usage metric.
func (mb *MetricsBuilder) RecordContainerFilesystemUsageDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricContainerFilesystemUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordContainerMemoryAvailableDataPoint adds a data point to container.memory.available metric.
func (mb *MetricsBuilder) RecordContainerMemoryAvailableDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricContainerMemoryAvailable.recordDataPoint(mb.startTime, ts, val)
}

// RecordContainerMemoryMajorPageFaultsDataPoint adds a data point to container.memory.major_page_faults metric.
func (mb *MetricsBuilder) RecordContainerMemoryMajorPageFaultsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricContainerMemoryMajorPageFaults.recordDataPoint(mb.startTime, ts, val)
}

// RecordContainerMemoryPageFaultsDataPoint adds a data point to container.memory.page_faults metric.
func (mb *MetricsBuilder) RecordContainerMemoryPageFaultsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricContainerMemoryPageFaults.recordDataPoint(mb.startTime, ts, val)
}

// RecordContainerMemoryRssDataPoint adds a data point to container.memory.rss metric.
func (mb *MetricsBuilder) RecordContainerMemoryRssDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricContainerMemoryRss.recordDataPoint(mb.startTime, ts, val)
}

// RecordContainerMemoryUsageDataPoint adds a data point to container.memory.usage metric.
func (mb *MetricsBuilder) RecordContainerMemoryUsageDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricContainerMemoryUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordContainerMemoryWorkingSetDataPoint adds a data point to container.memory.working_set metric.
func (mb *MetricsBuilder) RecordContainerMemoryWorkingSetDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricContainerMemoryWorkingSet.recordDataPoint(mb.startTime, ts, val)
}

// RecordContainerUptimeDataPoint adds a data point to container.uptime metric.
func (mb *MetricsBuilder) RecordContainerUptimeDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricContainerUptime.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sContainerCPUNodeUtilizationDataPoint adds a data point to k8s.container.cpu.node.utilization metric.
func (mb *MetricsBuilder) RecordK8sContainerCPUNodeUtilizationDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricK8sContainerCPUNodeUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sContainerCPULimitUtilizationDataPoint adds a data point to k8s.container.cpu_limit_utilization metric.
func (mb *MetricsBuilder) RecordK8sContainerCPULimitUtilizationDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricK8sContainerCPULimitUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sContainerCPURequestUtilizationDataPoint adds a data point to k8s.container.cpu_request_utilization metric.
func (mb *MetricsBuilder) RecordK8sContainerCPURequestUtilizationDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricK8sContainerCPURequestUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sContainerMemoryNodeUtilizationDataPoint adds a data point to k8s.container.memory.node.utilization metric.
func (mb *MetricsBuilder) RecordK8sContainerMemoryNodeUtilizationDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricK8sContainerMemoryNodeUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sContainerMemoryLimitUtilizationDataPoint adds a data point to k8s.container.memory_limit_utilization metric.
func (mb *MetricsBuilder) RecordK8sContainerMemoryLimitUtilizationDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricK8sContainerMemoryLimitUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sContainerMemoryRequestUtilizationDataPoint adds a data point to k8s.container.memory_request_utilization metric.
func (mb *MetricsBuilder) RecordK8sContainerMemoryRequestUtilizationDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricK8sContainerMemoryRequestUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sNodeCPUTimeDataPoint adds a data point to k8s.node.cpu.time metric.
func (mb *MetricsBuilder) RecordK8sNodeCPUTimeDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricK8sNodeCPUTime.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sNodeCPUUsageDataPoint adds a data point to k8s.node.cpu.usage metric.
func (mb *MetricsBuilder) RecordK8sNodeCPUUsageDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricK8sNodeCPUUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sNodeFilesystemAvailableDataPoint adds a data point to k8s.node.filesystem.available metric.
func (mb *MetricsBuilder) RecordK8sNodeFilesystemAvailableDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sNodeFilesystemAvailable.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sNodeFilesystemCapacityDataPoint adds a data point to k8s.node.filesystem.capacity metric.
func (mb *MetricsBuilder) RecordK8sNodeFilesystemCapacityDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sNodeFilesystemCapacity.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sNodeFilesystemUsageDataPoint adds a data point to k8s.node.filesystem.usage metric.
func (mb *MetricsBuilder) RecordK8sNodeFilesystemUsageDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sNodeFilesystemUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sNodeMemoryAvailableDataPoint adds a data point to k8s.node.memory.available metric.
func (mb *MetricsBuilder) RecordK8sNodeMemoryAvailableDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sNodeMemoryAvailable.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sNodeMemoryMajorPageFaultsDataPoint adds a data point to k8s.node.memory.major_page_faults metric.
func (mb *MetricsBuilder) RecordK8sNodeMemoryMajorPageFaultsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sNodeMemoryMajorPageFaults.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sNodeMemoryPageFaultsDataPoint adds a data point to k8s.node.memory.page_faults metric.
func (mb *MetricsBuilder) RecordK8sNodeMemoryPageFaultsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sNodeMemoryPageFaults.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sNodeMemoryRssDataPoint adds a data point to k8s.node.memory.rss metric.
func (mb *MetricsBuilder) RecordK8sNodeMemoryRssDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sNodeMemoryRss.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sNodeMemoryUsageDataPoint adds a data point to k8s.node.memory.usage metric.
func (mb *MetricsBuilder) RecordK8sNodeMemoryUsageDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sNodeMemoryUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sNodeMemoryWorkingSetDataPoint adds a data point to k8s.node.memory.working_set metric.
func (mb *MetricsBuilder) RecordK8sNodeMemoryWorkingSetDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sNodeMemoryWorkingSet.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sNodeNetworkErrorsDataPoint adds a data point to k8s.node.network.errors metric.
func (mb *MetricsBuilder) RecordK8sNodeNetworkErrorsDataPoint(ts pcommon.Timestamp, val int64, interfaceAttributeValue string, directionAttributeValue AttributeDirection) {
	mb.metricK8sNodeNetworkErrors.recordDataPoint(mb.startTime, ts, val, interfaceAttributeValue, directionAttributeValue.String())
}

// RecordK8sNodeNetworkIoDataPoint adds a data point to k8s.node.network.io metric.
func (mb *MetricsBuilder) RecordK8sNodeNetworkIoDataPoint(ts pcommon.Timestamp, val int64, interfaceAttributeValue string, directionAttributeValue AttributeDirection) {
	mb.metricK8sNodeNetworkIo.recordDataPoint(mb.startTime, ts, val, interfaceAttributeValue, directionAttributeValue.String())
}

// RecordK8sNodeUptimeDataPoint adds a data point to k8s.node.uptime metric.
func (mb *MetricsBuilder) RecordK8sNodeUptimeDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sNodeUptime.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodCPUNodeUtilizationDataPoint adds a data point to k8s.pod.cpu.node.utilization metric.
func (mb *MetricsBuilder) RecordK8sPodCPUNodeUtilizationDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricK8sPodCPUNodeUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodCPUTimeDataPoint adds a data point to k8s.pod.cpu.time metric.
func (mb *MetricsBuilder) RecordK8sPodCPUTimeDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricK8sPodCPUTime.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodCPUUsageDataPoint adds a data point to k8s.pod.cpu.usage metric.
func (mb *MetricsBuilder) RecordK8sPodCPUUsageDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricK8sPodCPUUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodCPULimitUtilizationDataPoint adds a data point to k8s.pod.cpu_limit_utilization metric.
func (mb *MetricsBuilder) RecordK8sPodCPULimitUtilizationDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricK8sPodCPULimitUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodCPURequestUtilizationDataPoint adds a data point to k8s.pod.cpu_request_utilization metric.
func (mb *MetricsBuilder) RecordK8sPodCPURequestUtilizationDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricK8sPodCPURequestUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodFilesystemAvailableDataPoint adds a data point to k8s.pod.filesystem.available metric.
func (mb *MetricsBuilder) RecordK8sPodFilesystemAvailableDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sPodFilesystemAvailable.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodFilesystemCapacityDataPoint adds a data point to k8s.pod.filesystem.capacity metric.
func (mb *MetricsBuilder) RecordK8sPodFilesystemCapacityDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sPodFilesystemCapacity.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodFilesystemUsageDataPoint adds a data point to k8s.pod.filesystem.usage metric.
func (mb *MetricsBuilder) RecordK8sPodFilesystemUsageDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sPodFilesystemUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodMemoryAvailableDataPoint adds a data point to k8s.pod.memory.available metric.
func (mb *MetricsBuilder) RecordK8sPodMemoryAvailableDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sPodMemoryAvailable.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodMemoryMajorPageFaultsDataPoint adds a data point to k8s.pod.memory.major_page_faults metric.
func (mb *MetricsBuilder) RecordK8sPodMemoryMajorPageFaultsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sPodMemoryMajorPageFaults.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodMemoryNodeUtilizationDataPoint adds a data point to k8s.pod.memory.node.utilization metric.
func (mb *MetricsBuilder) RecordK8sPodMemoryNodeUtilizationDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricK8sPodMemoryNodeUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodMemoryPageFaultsDataPoint adds a data point to k8s.pod.memory.page_faults metric.
func (mb *MetricsBuilder) RecordK8sPodMemoryPageFaultsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sPodMemoryPageFaults.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodMemoryRssDataPoint adds a data point to k8s.pod.memory.rss metric.
func (mb *MetricsBuilder) RecordK8sPodMemoryRssDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sPodMemoryRss.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodMemoryUsageDataPoint adds a data point to k8s.pod.memory.usage metric.
func (mb *MetricsBuilder) RecordK8sPodMemoryUsageDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sPodMemoryUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodMemoryWorkingSetDataPoint adds a data point to k8s.pod.memory.working_set metric.
func (mb *MetricsBuilder) RecordK8sPodMemoryWorkingSetDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sPodMemoryWorkingSet.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodMemoryLimitUtilizationDataPoint adds a data point to k8s.pod.memory_limit_utilization metric.
func (mb *MetricsBuilder) RecordK8sPodMemoryLimitUtilizationDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricK8sPodMemoryLimitUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodMemoryRequestUtilizationDataPoint adds a data point to k8s.pod.memory_request_utilization metric.
func (mb *MetricsBuilder) RecordK8sPodMemoryRequestUtilizationDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricK8sPodMemoryRequestUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodNetworkErrorsDataPoint adds a data point to k8s.pod.network.errors metric.
func (mb *MetricsBuilder) RecordK8sPodNetworkErrorsDataPoint(ts pcommon.Timestamp, val int64, interfaceAttributeValue string, directionAttributeValue AttributeDirection) {
	mb.metricK8sPodNetworkErrors.recordDataPoint(mb.startTime, ts, val, interfaceAttributeValue, directionAttributeValue.String())
}

// RecordK8sPodNetworkIoDataPoint adds a data point to k8s.pod.network.io metric.
func (mb *MetricsBuilder) RecordK8sPodNetworkIoDataPoint(ts pcommon.Timestamp, val int64, interfaceAttributeValue string, directionAttributeValue AttributeDirection) {
	mb.metricK8sPodNetworkIo.recordDataPoint(mb.startTime, ts, val, interfaceAttributeValue, directionAttributeValue.String())
}

// RecordK8sPodUptimeDataPoint adds a data point to k8s.pod.uptime metric.
func (mb *MetricsBuilder) RecordK8sPodUptimeDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sPodUptime.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodVolumeUsageDataPoint adds a data point to k8s.pod.volume.usage metric.
func (mb *MetricsBuilder) RecordK8sPodVolumeUsageDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sPodVolumeUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sVolumeAvailableDataPoint adds a data point to k8s.volume.available metric.
func (mb *MetricsBuilder) RecordK8sVolumeAvailableDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sVolumeAvailable.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sVolumeCapacityDataPoint adds a data point to k8s.volume.capacity metric.
func (mb *MetricsBuilder) RecordK8sVolumeCapacityDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sVolumeCapacity.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sVolumeInodesDataPoint adds a data point to k8s.volume.inodes metric.
func (mb *MetricsBuilder) RecordK8sVolumeInodesDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sVolumeInodes.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sVolumeInodesFreeDataPoint adds a data point to k8s.volume.inodes.free metric.
func (mb *MetricsBuilder) RecordK8sVolumeInodesFreeDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sVolumeInodesFree.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sVolumeInodesUsedDataPoint adds a data point to k8s.volume.inodes.used metric.
func (mb *MetricsBuilder) RecordK8sVolumeInodesUsedDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sVolumeInodesUsed.recordDataPoint(mb.startTime, ts, val)
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...MetricBuilderOption) {
	mb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op.apply(mb)
	}
}
