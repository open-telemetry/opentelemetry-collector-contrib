// Copyright The OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"go.opentelemetry.io/collector/config"
	"go.opentelemetry.io/collector/model/pdata"
)

// Type is the component type name.
const Type config.Type = "kubeletstatsreceiver"

// MetricIntf is an interface to generically interact with generated metric.
type MetricIntf interface {
	Name() string
	New() pdata.Metric
	Init(metric pdata.Metric)
}

// Intentionally not exposing this so that it is opaque and can change freely.
type metricImpl struct {
	name     string
	initFunc func(pdata.Metric)
}

// Name returns the metric name.
func (m *metricImpl) Name() string {
	return m.name
}

// New creates a metric object preinitialized.
func (m *metricImpl) New() pdata.Metric {
	metric := pdata.NewMetric()
	m.Init(metric)
	return metric
}

// Init initializes the provided metric object.
func (m *metricImpl) Init(metric pdata.Metric) {
	m.initFunc(metric)
}

type metricStruct struct {
	CPUTime               MetricIntf
	CPUUtilization        MetricIntf
	FilesystemAvailable   MetricIntf
	FilesystemCapacity    MetricIntf
	FilesystemUsage       MetricIntf
	MemoryAvailable       MetricIntf
	MemoryMajorPageFaults MetricIntf
	MemoryPageFaults      MetricIntf
	MemoryRss             MetricIntf
	MemoryUsage           MetricIntf
	MemoryWorkingSet      MetricIntf
	NetworkErrors         MetricIntf
	NetworkIo             MetricIntf
	VolumeAvailable       MetricIntf
	VolumeCapacity        MetricIntf
	VolumeInodes          MetricIntf
	VolumeInodesFree      MetricIntf
	VolumeInodesUsed      MetricIntf
}

// Names returns a list of all the metric name strings.
func (m *metricStruct) Names() []string {
	return []string{
		"cpu.time",
		"cpu.utilization",
		"filesystem.available",
		"filesystem.capacity",
		"filesystem.usage",
		"memory.available",
		"memory.major_page_faults",
		"memory.page_faults",
		"memory.rss",
		"memory.usage",
		"memory.working_set",
		"network.errors",
		"network.io",
		"volume.available",
		"volume.capacity",
		"volume.inodes",
		"volume.inodes.free",
		"volume.inodes.used",
	}
}

var metricsByName = map[string]MetricIntf{
	"cpu.time":                 Metrics.CPUTime,
	"cpu.utilization":          Metrics.CPUUtilization,
	"filesystem.available":     Metrics.FilesystemAvailable,
	"filesystem.capacity":      Metrics.FilesystemCapacity,
	"filesystem.usage":         Metrics.FilesystemUsage,
	"memory.available":         Metrics.MemoryAvailable,
	"memory.major_page_faults": Metrics.MemoryMajorPageFaults,
	"memory.page_faults":       Metrics.MemoryPageFaults,
	"memory.rss":               Metrics.MemoryRss,
	"memory.usage":             Metrics.MemoryUsage,
	"memory.working_set":       Metrics.MemoryWorkingSet,
	"network.errors":           Metrics.NetworkErrors,
	"network.io":               Metrics.NetworkIo,
	"volume.available":         Metrics.VolumeAvailable,
	"volume.capacity":          Metrics.VolumeCapacity,
	"volume.inodes":            Metrics.VolumeInodes,
	"volume.inodes.free":       Metrics.VolumeInodesFree,
	"volume.inodes.used":       Metrics.VolumeInodesUsed,
}

func (m *metricStruct) ByName(n string) MetricIntf {
	return metricsByName[n]
}

// Metrics contains a set of methods for each metric that help with
// manipulating those metrics.
var Metrics = &metricStruct{
	&metricImpl{
		"cpu.time",
		func(metric pdata.Metric) {
			metric.SetName("cpu.time")
			metric.SetDescription("CPU time")
			metric.SetUnit("s")
			metric.SetDataType(pdata.MetricDataTypeSum)
			metric.Sum().SetIsMonotonic(true)
			metric.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
		},
	},
	&metricImpl{
		"cpu.utilization",
		func(metric pdata.Metric) {
			metric.SetName("cpu.utilization")
			metric.SetDescription("CPU utilization")
			metric.SetUnit("1")
			metric.SetDataType(pdata.MetricDataTypeGauge)
		},
	},
	&metricImpl{
		"filesystem.available",
		func(metric pdata.Metric) {
			metric.SetName("filesystem.available")
			metric.SetDescription("Filesystem available")
			metric.SetUnit("By")
			metric.SetDataType(pdata.MetricDataTypeGauge)
		},
	},
	&metricImpl{
		"filesystem.capacity",
		func(metric pdata.Metric) {
			metric.SetName("filesystem.capacity")
			metric.SetDescription("Filesystem capacity")
			metric.SetUnit("By")
			metric.SetDataType(pdata.MetricDataTypeGauge)
		},
	},
	&metricImpl{
		"filesystem.usage",
		func(metric pdata.Metric) {
			metric.SetName("filesystem.usage")
			metric.SetDescription("Filesystem usage")
			metric.SetUnit("By")
			metric.SetDataType(pdata.MetricDataTypeGauge)
		},
	},
	&metricImpl{
		"memory.available",
		func(metric pdata.Metric) {
			metric.SetName("memory.available")
			metric.SetDescription("Memory available")
			metric.SetUnit("By")
			metric.SetDataType(pdata.MetricDataTypeGauge)
		},
	},
	&metricImpl{
		"memory.major_page_faults",
		func(metric pdata.Metric) {
			metric.SetName("memory.major_page_faults")
			metric.SetDescription("Memory major_page_faults")
			metric.SetUnit("1")
			metric.SetDataType(pdata.MetricDataTypeGauge)
		},
	},
	&metricImpl{
		"memory.page_faults",
		func(metric pdata.Metric) {
			metric.SetName("memory.page_faults")
			metric.SetDescription("Memory page_faults")
			metric.SetUnit("1")
			metric.SetDataType(pdata.MetricDataTypeGauge)
		},
	},
	&metricImpl{
		"memory.rss",
		func(metric pdata.Metric) {
			metric.SetName("memory.rss")
			metric.SetDescription("Memory rss")
			metric.SetUnit("By")
			metric.SetDataType(pdata.MetricDataTypeGauge)
		},
	},
	&metricImpl{
		"memory.usage",
		func(metric pdata.Metric) {
			metric.SetName("memory.usage")
			metric.SetDescription("Memory usage")
			metric.SetUnit("By")
			metric.SetDataType(pdata.MetricDataTypeGauge)
		},
	},
	&metricImpl{
		"memory.working_set",
		func(metric pdata.Metric) {
			metric.SetName("memory.working_set")
			metric.SetDescription("Memory working_set")
			metric.SetUnit("By")
			metric.SetDataType(pdata.MetricDataTypeGauge)
		},
	},
	&metricImpl{
		"network.errors",
		func(metric pdata.Metric) {
			metric.SetName("network.errors")
			metric.SetDescription("Network errors")
			metric.SetUnit("1")
			metric.SetDataType(pdata.MetricDataTypeSum)
			metric.Sum().SetIsMonotonic(true)
			metric.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
		},
	},
	&metricImpl{
		"network.io",
		func(metric pdata.Metric) {
			metric.SetName("network.io")
			metric.SetDescription("Network IO")
			metric.SetUnit("By")
			metric.SetDataType(pdata.MetricDataTypeSum)
			metric.Sum().SetIsMonotonic(true)
			metric.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
		},
	},
	&metricImpl{
		"volume.available",
		func(metric pdata.Metric) {
			metric.SetName("volume.available")
			metric.SetDescription("The number of available bytes in the volume.")
			metric.SetUnit("By")
			metric.SetDataType(pdata.MetricDataTypeGauge)
		},
	},
	&metricImpl{
		"volume.capacity",
		func(metric pdata.Metric) {
			metric.SetName("volume.capacity")
			metric.SetDescription("The total capacity in bytes of the volume.")
			metric.SetUnit("By")
			metric.SetDataType(pdata.MetricDataTypeGauge)
		},
	},
	&metricImpl{
		"volume.inodes",
		func(metric pdata.Metric) {
			metric.SetName("volume.inodes")
			metric.SetDescription("The total inodes in the filesystem.")
			metric.SetUnit("1")
			metric.SetDataType(pdata.MetricDataTypeGauge)
		},
	},
	&metricImpl{
		"volume.inodes.free",
		func(metric pdata.Metric) {
			metric.SetName("volume.inodes.free")
			metric.SetDescription("The free inodes in the filesystem.")
			metric.SetUnit("1")
			metric.SetDataType(pdata.MetricDataTypeGauge)
		},
	},
	&metricImpl{
		"volume.inodes.used",
		func(metric pdata.Metric) {
			metric.SetName("volume.inodes.used")
			metric.SetDescription("The inodes used by the filesystem. This may not equal inodes - free because filesystem may share inodes with other filesystems.")
			metric.SetUnit("1")
			metric.SetDataType(pdata.MetricDataTypeGauge)
		},
	},
}

// M contains a set of methods for each metric that help with
// manipulating those metrics. M is an alias for Metrics
var M = Metrics

// Labels contains the possible metric labels that can be used.
var Labels = struct {
	// Direction (Direction of flow of bytes/opertations (receive or transmit).)
	Direction string
	// Interface (Name of the network interface.)
	Interface string
}{
	"direction",
	"interface",
}

// L contains the possible metric labels that can be used. L is an alias for
// Labels.
var L = Labels

// LabelDirection are the possible values that the label "direction" can have.
var LabelDirection = struct {
	Receive  string
	Transmit string
}{
	"receive",
	"transmit",
}
