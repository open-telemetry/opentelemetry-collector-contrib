// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
	"go.opentelemetry.io/collector/receiver"
)

// AttributeDirection specifies the a value direction attribute.
type AttributeDirection int

const (
	_ AttributeDirection = iota
	AttributeDirectionReceive
	AttributeDirectionTransmit
)

// String returns the string representation of the AttributeDirection.
func (av AttributeDirection) String() string {
	switch av {
	case AttributeDirectionReceive:
		return "receive"
	case AttributeDirectionTransmit:
		return "transmit"
	}
	return ""
}

// MapAttributeDirection is a helper map of string to AttributeDirection attribute value.
var MapAttributeDirection = map[string]AttributeDirection{
	"receive":  AttributeDirectionReceive,
	"transmit": AttributeDirectionTransmit,
}

type metricContainerCPUTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.cpu.time metric with initial data.
func (m *metricContainerCPUTime) init() {
	m.data.SetName("container.cpu.time")
	m.data.SetDescription("Deprecated: use `k8s.container.cpu.time` metric instead. Container CPU time")
	m.data.SetUnit("s")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricContainerCPUTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerCPUTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerCPUTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerCPUTime(cfg MetricConfig) metricContainerCPUTime {
	m := metricContainerCPUTime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerCPUUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.cpu.utilization metric with initial data.
func (m *metricContainerCPUUtilization) init() {
	m.data.SetName("container.cpu.utilization")
	m.data.SetDescription("Deprecated: use `k8s.container.cpu.utilization` metric instead. Container CPU utilization")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricContainerCPUUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerCPUUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerCPUUtilization) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerCPUUtilization(cfg MetricConfig) metricContainerCPUUtilization {
	m := metricContainerCPUUtilization{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerFilesystemAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.filesystem.available metric with initial data.
func (m *metricContainerFilesystemAvailable) init() {
	m.data.SetName("container.filesystem.available")
	m.data.SetDescription("Deprecated: use `k8s.container.filesystem.available` metric instead. Container filesystem available")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricContainerFilesystemAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerFilesystemAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerFilesystemAvailable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerFilesystemAvailable(cfg MetricConfig) metricContainerFilesystemAvailable {
	m := metricContainerFilesystemAvailable{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerFilesystemCapacity struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.filesystem.capacity metric with initial data.
func (m *metricContainerFilesystemCapacity) init() {
	m.data.SetName("container.filesystem.capacity")
	m.data.SetDescription("Deprecated: use `k8s.container.filesystem.capacity` metric instead. Container filesystem capacity")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricContainerFilesystemCapacity) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerFilesystemCapacity) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerFilesystemCapacity) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerFilesystemCapacity(cfg MetricConfig) metricContainerFilesystemCapacity {
	m := metricContainerFilesystemCapacity{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerFilesystemUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.filesystem.usage metric with initial data.
func (m *metricContainerFilesystemUsage) init() {
	m.data.SetName("container.filesystem.usage")
	m.data.SetDescription("Deprecated: use `k8s.container.filesystem.usage` metric instead. Container filesystem usage")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricContainerFilesystemUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerFilesystemUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerFilesystemUsage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerFilesystemUsage(cfg MetricConfig) metricContainerFilesystemUsage {
	m := metricContainerFilesystemUsage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerMemoryAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.memory.available metric with initial data.
func (m *metricContainerMemoryAvailable) init() {
	m.data.SetName("container.memory.available")
	m.data.SetDescription("Deprecated: use `k8s.container.memory.available` metric instead. Container memory available")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricContainerMemoryAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerMemoryAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerMemoryAvailable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerMemoryAvailable(cfg MetricConfig) metricContainerMemoryAvailable {
	m := metricContainerMemoryAvailable{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerMemoryMajorPageFaults struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.memory.major_page_faults metric with initial data.
func (m *metricContainerMemoryMajorPageFaults) init() {
	m.data.SetName("container.memory.major_page_faults")
	m.data.SetDescription("Deprecated: use `container.memory.major_page_faults` metric instead. Container memory major_page_faults")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricContainerMemoryMajorPageFaults) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerMemoryMajorPageFaults) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerMemoryMajorPageFaults) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerMemoryMajorPageFaults(cfg MetricConfig) metricContainerMemoryMajorPageFaults {
	m := metricContainerMemoryMajorPageFaults{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerMemoryPageFaults struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.memory.page_faults metric with initial data.
func (m *metricContainerMemoryPageFaults) init() {
	m.data.SetName("container.memory.page_faults")
	m.data.SetDescription("Deprecated: use `k8s.container.memory.page_faults` metric instead. Container memory page_faults")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricContainerMemoryPageFaults) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerMemoryPageFaults) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerMemoryPageFaults) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerMemoryPageFaults(cfg MetricConfig) metricContainerMemoryPageFaults {
	m := metricContainerMemoryPageFaults{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerMemoryRss struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.memory.rss metric with initial data.
func (m *metricContainerMemoryRss) init() {
	m.data.SetName("container.memory.rss")
	m.data.SetDescription("Deprecated: use `k8s.container.memory.rss` metric instead. Container memory rss")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricContainerMemoryRss) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerMemoryRss) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerMemoryRss) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerMemoryRss(cfg MetricConfig) metricContainerMemoryRss {
	m := metricContainerMemoryRss{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerMemoryUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.memory.usage metric with initial data.
func (m *metricContainerMemoryUsage) init() {
	m.data.SetName("container.memory.usage")
	m.data.SetDescription("Deprecated: use `k8s.container.memory.usage` metric instead. Container memory usage")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricContainerMemoryUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerMemoryUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerMemoryUsage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerMemoryUsage(cfg MetricConfig) metricContainerMemoryUsage {
	m := metricContainerMemoryUsage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerMemoryWorkingSet struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.memory.working_set metric with initial data.
func (m *metricContainerMemoryWorkingSet) init() {
	m.data.SetName("container.memory.working_set")
	m.data.SetDescription("Deprecated: use `k8s.container.memory.working_set` metric instead. Container memory working_set")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricContainerMemoryWorkingSet) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerMemoryWorkingSet) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerMemoryWorkingSet) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerMemoryWorkingSet(cfg MetricConfig) metricContainerMemoryWorkingSet {
	m := metricContainerMemoryWorkingSet{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sContainerCPUTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.container.cpu.time metric with initial data.
func (m *metricK8sContainerCPUTime) init() {
	m.data.SetName("k8s.container.cpu.time")
	m.data.SetDescription("Container CPU time")
	m.data.SetUnit("s")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricK8sContainerCPUTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sContainerCPUTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sContainerCPUTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sContainerCPUTime(cfg MetricConfig) metricK8sContainerCPUTime {
	m := metricK8sContainerCPUTime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sContainerCPUUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.container.cpu.utilization metric with initial data.
func (m *metricK8sContainerCPUUtilization) init() {
	m.data.SetName("k8s.container.cpu.utilization")
	m.data.SetDescription("Container CPU utilization")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sContainerCPUUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sContainerCPUUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sContainerCPUUtilization) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sContainerCPUUtilization(cfg MetricConfig) metricK8sContainerCPUUtilization {
	m := metricK8sContainerCPUUtilization{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sContainerFilesystemAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.container.filesystem.available metric with initial data.
func (m *metricK8sContainerFilesystemAvailable) init() {
	m.data.SetName("k8s.container.filesystem.available")
	m.data.SetDescription("Container filesystem available")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sContainerFilesystemAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sContainerFilesystemAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sContainerFilesystemAvailable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sContainerFilesystemAvailable(cfg MetricConfig) metricK8sContainerFilesystemAvailable {
	m := metricK8sContainerFilesystemAvailable{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sContainerFilesystemCapacity struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.container.filesystem.capacity metric with initial data.
func (m *metricK8sContainerFilesystemCapacity) init() {
	m.data.SetName("k8s.container.filesystem.capacity")
	m.data.SetDescription("Container filesystem capacity")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sContainerFilesystemCapacity) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sContainerFilesystemCapacity) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sContainerFilesystemCapacity) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sContainerFilesystemCapacity(cfg MetricConfig) metricK8sContainerFilesystemCapacity {
	m := metricK8sContainerFilesystemCapacity{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sContainerFilesystemUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.container.filesystem.usage metric with initial data.
func (m *metricK8sContainerFilesystemUsage) init() {
	m.data.SetName("k8s.container.filesystem.usage")
	m.data.SetDescription("Container filesystem usage")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sContainerFilesystemUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sContainerFilesystemUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sContainerFilesystemUsage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sContainerFilesystemUsage(cfg MetricConfig) metricK8sContainerFilesystemUsage {
	m := metricK8sContainerFilesystemUsage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sContainerMemoryAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.container.memory.available metric with initial data.
func (m *metricK8sContainerMemoryAvailable) init() {
	m.data.SetName("k8s.container.memory.available")
	m.data.SetDescription("Container memory available")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sContainerMemoryAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sContainerMemoryAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sContainerMemoryAvailable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sContainerMemoryAvailable(cfg MetricConfig) metricK8sContainerMemoryAvailable {
	m := metricK8sContainerMemoryAvailable{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sContainerMemoryMajorPageFaults struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.container.memory.major_page_faults metric with initial data.
func (m *metricK8sContainerMemoryMajorPageFaults) init() {
	m.data.SetName("k8s.container.memory.major_page_faults")
	m.data.SetDescription("Container memory major_page_faults")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sContainerMemoryMajorPageFaults) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sContainerMemoryMajorPageFaults) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sContainerMemoryMajorPageFaults) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sContainerMemoryMajorPageFaults(cfg MetricConfig) metricK8sContainerMemoryMajorPageFaults {
	m := metricK8sContainerMemoryMajorPageFaults{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sContainerMemoryPageFaults struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.container.memory.page_faults metric with initial data.
func (m *metricK8sContainerMemoryPageFaults) init() {
	m.data.SetName("k8s.container.memory.page_faults")
	m.data.SetDescription("Container memory page_faults")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sContainerMemoryPageFaults) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sContainerMemoryPageFaults) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sContainerMemoryPageFaults) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sContainerMemoryPageFaults(cfg MetricConfig) metricK8sContainerMemoryPageFaults {
	m := metricK8sContainerMemoryPageFaults{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sContainerMemoryRss struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.container.memory.rss metric with initial data.
func (m *metricK8sContainerMemoryRss) init() {
	m.data.SetName("k8s.container.memory.rss")
	m.data.SetDescription("Container memory rss")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sContainerMemoryRss) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sContainerMemoryRss) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sContainerMemoryRss) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sContainerMemoryRss(cfg MetricConfig) metricK8sContainerMemoryRss {
	m := metricK8sContainerMemoryRss{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sContainerMemoryUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.container.memory.usage metric with initial data.
func (m *metricK8sContainerMemoryUsage) init() {
	m.data.SetName("k8s.container.memory.usage")
	m.data.SetDescription("Container memory usage")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sContainerMemoryUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sContainerMemoryUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sContainerMemoryUsage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sContainerMemoryUsage(cfg MetricConfig) metricK8sContainerMemoryUsage {
	m := metricK8sContainerMemoryUsage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sContainerMemoryWorkingSet struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.container.memory.working_set metric with initial data.
func (m *metricK8sContainerMemoryWorkingSet) init() {
	m.data.SetName("k8s.container.memory.working_set")
	m.data.SetDescription("Container memory working_set")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sContainerMemoryWorkingSet) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sContainerMemoryWorkingSet) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sContainerMemoryWorkingSet) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sContainerMemoryWorkingSet(cfg MetricConfig) metricK8sContainerMemoryWorkingSet {
	m := metricK8sContainerMemoryWorkingSet{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeCPUTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.cpu.time metric with initial data.
func (m *metricK8sNodeCPUTime) init() {
	m.data.SetName("k8s.node.cpu.time")
	m.data.SetDescription("Node CPU time")
	m.data.SetUnit("s")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricK8sNodeCPUTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeCPUTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeCPUTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeCPUTime(cfg MetricConfig) metricK8sNodeCPUTime {
	m := metricK8sNodeCPUTime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeCPUUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.cpu.utilization metric with initial data.
func (m *metricK8sNodeCPUUtilization) init() {
	m.data.SetName("k8s.node.cpu.utilization")
	m.data.SetDescription("Node CPU utilization")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeCPUUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeCPUUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeCPUUtilization) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeCPUUtilization(cfg MetricConfig) metricK8sNodeCPUUtilization {
	m := metricK8sNodeCPUUtilization{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeFilesystemAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.filesystem.available metric with initial data.
func (m *metricK8sNodeFilesystemAvailable) init() {
	m.data.SetName("k8s.node.filesystem.available")
	m.data.SetDescription("Node filesystem available")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeFilesystemAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeFilesystemAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeFilesystemAvailable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeFilesystemAvailable(cfg MetricConfig) metricK8sNodeFilesystemAvailable {
	m := metricK8sNodeFilesystemAvailable{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeFilesystemCapacity struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.filesystem.capacity metric with initial data.
func (m *metricK8sNodeFilesystemCapacity) init() {
	m.data.SetName("k8s.node.filesystem.capacity")
	m.data.SetDescription("Node filesystem capacity")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeFilesystemCapacity) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeFilesystemCapacity) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeFilesystemCapacity) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeFilesystemCapacity(cfg MetricConfig) metricK8sNodeFilesystemCapacity {
	m := metricK8sNodeFilesystemCapacity{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeFilesystemUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.filesystem.usage metric with initial data.
func (m *metricK8sNodeFilesystemUsage) init() {
	m.data.SetName("k8s.node.filesystem.usage")
	m.data.SetDescription("Node filesystem usage")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeFilesystemUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeFilesystemUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeFilesystemUsage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeFilesystemUsage(cfg MetricConfig) metricK8sNodeFilesystemUsage {
	m := metricK8sNodeFilesystemUsage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeMemoryAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.memory.available metric with initial data.
func (m *metricK8sNodeMemoryAvailable) init() {
	m.data.SetName("k8s.node.memory.available")
	m.data.SetDescription("Node memory available")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeMemoryAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeMemoryAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeMemoryAvailable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeMemoryAvailable(cfg MetricConfig) metricK8sNodeMemoryAvailable {
	m := metricK8sNodeMemoryAvailable{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeMemoryMajorPageFaults struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.memory.major_page_faults metric with initial data.
func (m *metricK8sNodeMemoryMajorPageFaults) init() {
	m.data.SetName("k8s.node.memory.major_page_faults")
	m.data.SetDescription("Node memory major_page_faults")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeMemoryMajorPageFaults) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeMemoryMajorPageFaults) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeMemoryMajorPageFaults) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeMemoryMajorPageFaults(cfg MetricConfig) metricK8sNodeMemoryMajorPageFaults {
	m := metricK8sNodeMemoryMajorPageFaults{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeMemoryPageFaults struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.memory.page_faults metric with initial data.
func (m *metricK8sNodeMemoryPageFaults) init() {
	m.data.SetName("k8s.node.memory.page_faults")
	m.data.SetDescription("Node memory page_faults")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeMemoryPageFaults) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeMemoryPageFaults) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeMemoryPageFaults) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeMemoryPageFaults(cfg MetricConfig) metricK8sNodeMemoryPageFaults {
	m := metricK8sNodeMemoryPageFaults{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeMemoryRss struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.memory.rss metric with initial data.
func (m *metricK8sNodeMemoryRss) init() {
	m.data.SetName("k8s.node.memory.rss")
	m.data.SetDescription("Node memory rss")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeMemoryRss) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeMemoryRss) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeMemoryRss) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeMemoryRss(cfg MetricConfig) metricK8sNodeMemoryRss {
	m := metricK8sNodeMemoryRss{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeMemoryUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.memory.usage metric with initial data.
func (m *metricK8sNodeMemoryUsage) init() {
	m.data.SetName("k8s.node.memory.usage")
	m.data.SetDescription("Node memory usage")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeMemoryUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeMemoryUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeMemoryUsage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeMemoryUsage(cfg MetricConfig) metricK8sNodeMemoryUsage {
	m := metricK8sNodeMemoryUsage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeMemoryWorkingSet struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.memory.working_set metric with initial data.
func (m *metricK8sNodeMemoryWorkingSet) init() {
	m.data.SetName("k8s.node.memory.working_set")
	m.data.SetDescription("Node memory working_set")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeMemoryWorkingSet) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeMemoryWorkingSet) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeMemoryWorkingSet) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeMemoryWorkingSet(cfg MetricConfig) metricK8sNodeMemoryWorkingSet {
	m := metricK8sNodeMemoryWorkingSet{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeNetworkErrors struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.network.errors metric with initial data.
func (m *metricK8sNodeNetworkErrors) init() {
	m.data.SetName("k8s.node.network.errors")
	m.data.SetDescription("Node network errors")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricK8sNodeNetworkErrors) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, interfaceAttributeValue string, directionAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("interface", interfaceAttributeValue)
	dp.Attributes().PutStr("direction", directionAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeNetworkErrors) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeNetworkErrors) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeNetworkErrors(cfg MetricConfig) metricK8sNodeNetworkErrors {
	m := metricK8sNodeNetworkErrors{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeNetworkIo struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.network.io metric with initial data.
func (m *metricK8sNodeNetworkIo) init() {
	m.data.SetName("k8s.node.network.io")
	m.data.SetDescription("Node network IO")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricK8sNodeNetworkIo) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, interfaceAttributeValue string, directionAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("interface", interfaceAttributeValue)
	dp.Attributes().PutStr("direction", directionAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeNetworkIo) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeNetworkIo) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeNetworkIo(cfg MetricConfig) metricK8sNodeNetworkIo {
	m := metricK8sNodeNetworkIo{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodCPUTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.cpu.time metric with initial data.
func (m *metricK8sPodCPUTime) init() {
	m.data.SetName("k8s.pod.cpu.time")
	m.data.SetDescription("Pod CPU time")
	m.data.SetUnit("s")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricK8sPodCPUTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodCPUTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodCPUTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodCPUTime(cfg MetricConfig) metricK8sPodCPUTime {
	m := metricK8sPodCPUTime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodCPUUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.cpu.utilization metric with initial data.
func (m *metricK8sPodCPUUtilization) init() {
	m.data.SetName("k8s.pod.cpu.utilization")
	m.data.SetDescription("Pod CPU utilization")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodCPUUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodCPUUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodCPUUtilization) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodCPUUtilization(cfg MetricConfig) metricK8sPodCPUUtilization {
	m := metricK8sPodCPUUtilization{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodFilesystemAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.filesystem.available metric with initial data.
func (m *metricK8sPodFilesystemAvailable) init() {
	m.data.SetName("k8s.pod.filesystem.available")
	m.data.SetDescription("Pod filesystem available")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodFilesystemAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodFilesystemAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodFilesystemAvailable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodFilesystemAvailable(cfg MetricConfig) metricK8sPodFilesystemAvailable {
	m := metricK8sPodFilesystemAvailable{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodFilesystemCapacity struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.filesystem.capacity metric with initial data.
func (m *metricK8sPodFilesystemCapacity) init() {
	m.data.SetName("k8s.pod.filesystem.capacity")
	m.data.SetDescription("Pod filesystem capacity")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodFilesystemCapacity) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodFilesystemCapacity) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodFilesystemCapacity) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodFilesystemCapacity(cfg MetricConfig) metricK8sPodFilesystemCapacity {
	m := metricK8sPodFilesystemCapacity{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodFilesystemUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.filesystem.usage metric with initial data.
func (m *metricK8sPodFilesystemUsage) init() {
	m.data.SetName("k8s.pod.filesystem.usage")
	m.data.SetDescription("Pod filesystem usage")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodFilesystemUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodFilesystemUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodFilesystemUsage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodFilesystemUsage(cfg MetricConfig) metricK8sPodFilesystemUsage {
	m := metricK8sPodFilesystemUsage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodMemoryAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.memory.available metric with initial data.
func (m *metricK8sPodMemoryAvailable) init() {
	m.data.SetName("k8s.pod.memory.available")
	m.data.SetDescription("Pod memory available")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodMemoryAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodMemoryAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodMemoryAvailable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodMemoryAvailable(cfg MetricConfig) metricK8sPodMemoryAvailable {
	m := metricK8sPodMemoryAvailable{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodMemoryMajorPageFaults struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.memory.major_page_faults metric with initial data.
func (m *metricK8sPodMemoryMajorPageFaults) init() {
	m.data.SetName("k8s.pod.memory.major_page_faults")
	m.data.SetDescription("Pod memory major_page_faults")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodMemoryMajorPageFaults) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodMemoryMajorPageFaults) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodMemoryMajorPageFaults) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodMemoryMajorPageFaults(cfg MetricConfig) metricK8sPodMemoryMajorPageFaults {
	m := metricK8sPodMemoryMajorPageFaults{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodMemoryPageFaults struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.memory.page_faults metric with initial data.
func (m *metricK8sPodMemoryPageFaults) init() {
	m.data.SetName("k8s.pod.memory.page_faults")
	m.data.SetDescription("Pod memory page_faults")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodMemoryPageFaults) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodMemoryPageFaults) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodMemoryPageFaults) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodMemoryPageFaults(cfg MetricConfig) metricK8sPodMemoryPageFaults {
	m := metricK8sPodMemoryPageFaults{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodMemoryRss struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.memory.rss metric with initial data.
func (m *metricK8sPodMemoryRss) init() {
	m.data.SetName("k8s.pod.memory.rss")
	m.data.SetDescription("Pod memory rss")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodMemoryRss) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodMemoryRss) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodMemoryRss) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodMemoryRss(cfg MetricConfig) metricK8sPodMemoryRss {
	m := metricK8sPodMemoryRss{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodMemoryUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.memory.usage metric with initial data.
func (m *metricK8sPodMemoryUsage) init() {
	m.data.SetName("k8s.pod.memory.usage")
	m.data.SetDescription("Pod memory usage")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodMemoryUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodMemoryUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodMemoryUsage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodMemoryUsage(cfg MetricConfig) metricK8sPodMemoryUsage {
	m := metricK8sPodMemoryUsage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodMemoryWorkingSet struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.memory.working_set metric with initial data.
func (m *metricK8sPodMemoryWorkingSet) init() {
	m.data.SetName("k8s.pod.memory.working_set")
	m.data.SetDescription("Pod memory working_set")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodMemoryWorkingSet) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodMemoryWorkingSet) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodMemoryWorkingSet) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodMemoryWorkingSet(cfg MetricConfig) metricK8sPodMemoryWorkingSet {
	m := metricK8sPodMemoryWorkingSet{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodNetworkErrors struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.network.errors metric with initial data.
func (m *metricK8sPodNetworkErrors) init() {
	m.data.SetName("k8s.pod.network.errors")
	m.data.SetDescription("Pod network errors")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricK8sPodNetworkErrors) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, interfaceAttributeValue string, directionAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("interface", interfaceAttributeValue)
	dp.Attributes().PutStr("direction", directionAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodNetworkErrors) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodNetworkErrors) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodNetworkErrors(cfg MetricConfig) metricK8sPodNetworkErrors {
	m := metricK8sPodNetworkErrors{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodNetworkIo struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.network.io metric with initial data.
func (m *metricK8sPodNetworkIo) init() {
	m.data.SetName("k8s.pod.network.io")
	m.data.SetDescription("Pod network IO")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricK8sPodNetworkIo) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, interfaceAttributeValue string, directionAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("interface", interfaceAttributeValue)
	dp.Attributes().PutStr("direction", directionAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodNetworkIo) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodNetworkIo) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodNetworkIo(cfg MetricConfig) metricK8sPodNetworkIo {
	m := metricK8sPodNetworkIo{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sVolumeAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.volume.available metric with initial data.
func (m *metricK8sVolumeAvailable) init() {
	m.data.SetName("k8s.volume.available")
	m.data.SetDescription("The number of available bytes in the volume.")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sVolumeAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sVolumeAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sVolumeAvailable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sVolumeAvailable(cfg MetricConfig) metricK8sVolumeAvailable {
	m := metricK8sVolumeAvailable{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sVolumeCapacity struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.volume.capacity metric with initial data.
func (m *metricK8sVolumeCapacity) init() {
	m.data.SetName("k8s.volume.capacity")
	m.data.SetDescription("The total capacity in bytes of the volume.")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sVolumeCapacity) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sVolumeCapacity) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sVolumeCapacity) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sVolumeCapacity(cfg MetricConfig) metricK8sVolumeCapacity {
	m := metricK8sVolumeCapacity{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sVolumeInodes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.volume.inodes metric with initial data.
func (m *metricK8sVolumeInodes) init() {
	m.data.SetName("k8s.volume.inodes")
	m.data.SetDescription("The total inodes in the filesystem.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sVolumeInodes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sVolumeInodes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sVolumeInodes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sVolumeInodes(cfg MetricConfig) metricK8sVolumeInodes {
	m := metricK8sVolumeInodes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sVolumeInodesFree struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.volume.inodes.free metric with initial data.
func (m *metricK8sVolumeInodesFree) init() {
	m.data.SetName("k8s.volume.inodes.free")
	m.data.SetDescription("The free inodes in the filesystem.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sVolumeInodesFree) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sVolumeInodesFree) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sVolumeInodesFree) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sVolumeInodesFree(cfg MetricConfig) metricK8sVolumeInodesFree {
	m := metricK8sVolumeInodesFree{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sVolumeInodesUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.volume.inodes.used metric with initial data.
func (m *metricK8sVolumeInodesUsed) init() {
	m.data.SetName("k8s.volume.inodes.used")
	m.data.SetDescription("The inodes used by the filesystem. This may not equal inodes - free because filesystem may share inodes with other filesystems.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sVolumeInodesUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sVolumeInodesUsed) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sVolumeInodesUsed) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sVolumeInodesUsed(cfg MetricConfig) metricK8sVolumeInodesUsed {
	m := metricK8sVolumeInodesUsed{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user config.
type MetricsBuilder struct {
	startTime                               pcommon.Timestamp   // start time that will be applied to all recorded data points.
	metricsCapacity                         int                 // maximum observed number of metrics per resource.
	resourceCapacity                        int                 // maximum observed number of resource attributes.
	metricsBuffer                           pmetric.Metrics     // accumulates metrics data before emitting.
	buildInfo                               component.BuildInfo // contains version information
	resourceAttributesConfig                ResourceAttributesConfig
	metricContainerCPUTime                  metricContainerCPUTime
	metricContainerCPUUtilization           metricContainerCPUUtilization
	metricContainerFilesystemAvailable      metricContainerFilesystemAvailable
	metricContainerFilesystemCapacity       metricContainerFilesystemCapacity
	metricContainerFilesystemUsage          metricContainerFilesystemUsage
	metricContainerMemoryAvailable          metricContainerMemoryAvailable
	metricContainerMemoryMajorPageFaults    metricContainerMemoryMajorPageFaults
	metricContainerMemoryPageFaults         metricContainerMemoryPageFaults
	metricContainerMemoryRss                metricContainerMemoryRss
	metricContainerMemoryUsage              metricContainerMemoryUsage
	metricContainerMemoryWorkingSet         metricContainerMemoryWorkingSet
	metricK8sContainerCPUTime               metricK8sContainerCPUTime
	metricK8sContainerCPUUtilization        metricK8sContainerCPUUtilization
	metricK8sContainerFilesystemAvailable   metricK8sContainerFilesystemAvailable
	metricK8sContainerFilesystemCapacity    metricK8sContainerFilesystemCapacity
	metricK8sContainerFilesystemUsage       metricK8sContainerFilesystemUsage
	metricK8sContainerMemoryAvailable       metricK8sContainerMemoryAvailable
	metricK8sContainerMemoryMajorPageFaults metricK8sContainerMemoryMajorPageFaults
	metricK8sContainerMemoryPageFaults      metricK8sContainerMemoryPageFaults
	metricK8sContainerMemoryRss             metricK8sContainerMemoryRss
	metricK8sContainerMemoryUsage           metricK8sContainerMemoryUsage
	metricK8sContainerMemoryWorkingSet      metricK8sContainerMemoryWorkingSet
	metricK8sNodeCPUTime                    metricK8sNodeCPUTime
	metricK8sNodeCPUUtilization             metricK8sNodeCPUUtilization
	metricK8sNodeFilesystemAvailable        metricK8sNodeFilesystemAvailable
	metricK8sNodeFilesystemCapacity         metricK8sNodeFilesystemCapacity
	metricK8sNodeFilesystemUsage            metricK8sNodeFilesystemUsage
	metricK8sNodeMemoryAvailable            metricK8sNodeMemoryAvailable
	metricK8sNodeMemoryMajorPageFaults      metricK8sNodeMemoryMajorPageFaults
	metricK8sNodeMemoryPageFaults           metricK8sNodeMemoryPageFaults
	metricK8sNodeMemoryRss                  metricK8sNodeMemoryRss
	metricK8sNodeMemoryUsage                metricK8sNodeMemoryUsage
	metricK8sNodeMemoryWorkingSet           metricK8sNodeMemoryWorkingSet
	metricK8sNodeNetworkErrors              metricK8sNodeNetworkErrors
	metricK8sNodeNetworkIo                  metricK8sNodeNetworkIo
	metricK8sPodCPUTime                     metricK8sPodCPUTime
	metricK8sPodCPUUtilization              metricK8sPodCPUUtilization
	metricK8sPodFilesystemAvailable         metricK8sPodFilesystemAvailable
	metricK8sPodFilesystemCapacity          metricK8sPodFilesystemCapacity
	metricK8sPodFilesystemUsage             metricK8sPodFilesystemUsage
	metricK8sPodMemoryAvailable             metricK8sPodMemoryAvailable
	metricK8sPodMemoryMajorPageFaults       metricK8sPodMemoryMajorPageFaults
	metricK8sPodMemoryPageFaults            metricK8sPodMemoryPageFaults
	metricK8sPodMemoryRss                   metricK8sPodMemoryRss
	metricK8sPodMemoryUsage                 metricK8sPodMemoryUsage
	metricK8sPodMemoryWorkingSet            metricK8sPodMemoryWorkingSet
	metricK8sPodNetworkErrors               metricK8sPodNetworkErrors
	metricK8sPodNetworkIo                   metricK8sPodNetworkIo
	metricK8sVolumeAvailable                metricK8sVolumeAvailable
	metricK8sVolumeCapacity                 metricK8sVolumeCapacity
	metricK8sVolumeInodes                   metricK8sVolumeInodes
	metricK8sVolumeInodesFree               metricK8sVolumeInodesFree
	metricK8sVolumeInodesUsed               metricK8sVolumeInodesUsed
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

func NewMetricsBuilder(mbc MetricsBuilderConfig, settings receiver.CreateSettings, options ...metricBuilderOption) *MetricsBuilder {
	if mbc.Metrics.ContainerCPUTime.Enabled {
		settings.Logger.Warn("[WARNING] `container.cpu.time` should not be enabled: This metric will be disabled in v0.84.0 and removed in v0.86.0.")
	}
	if mbc.Metrics.ContainerCPUUtilization.Enabled {
		settings.Logger.Warn("[WARNING] `container.cpu.utilization` should not be enabled: This metric will be disabled in v0.84.0 and removed in v0.86.0.")
	}
	if mbc.Metrics.ContainerFilesystemAvailable.Enabled {
		settings.Logger.Warn("[WARNING] `container.filesystem.available` should not be enabled: This metric will be disabled in v0.84.0 and removed in v0.86.0.")
	}
	if mbc.Metrics.ContainerFilesystemCapacity.Enabled {
		settings.Logger.Warn("[WARNING] `container.filesystem.capacity` should not be enabled: This metric will be disabled in v0.84.0 and removed in v0.86.0.")
	}
	if mbc.Metrics.ContainerFilesystemUsage.Enabled {
		settings.Logger.Warn("[WARNING] `container.filesystem.usage` should not be enabled: This metric will be disabled in v0.84.0 and removed in v0.86.0.")
	}
	if mbc.Metrics.ContainerMemoryAvailable.Enabled {
		settings.Logger.Warn("[WARNING] `container.memory.available` should not be enabled: This metric will be disabled in v0.84.0 and removed in v0.86.0.")
	}
	if mbc.Metrics.ContainerMemoryMajorPageFaults.Enabled {
		settings.Logger.Warn("[WARNING] `container.memory.major_page_faults` should not be enabled: This metric will be disabled in v0.84.0 and removed in v0.86.0.")
	}
	if mbc.Metrics.ContainerMemoryPageFaults.Enabled {
		settings.Logger.Warn("[WARNING] `container.memory.page_faults` should not be enabled: This metric will be disabled in v0.84.0 and removed in v0.86.0.")
	}
	if mbc.Metrics.ContainerMemoryRss.Enabled {
		settings.Logger.Warn("[WARNING] `container.memory.rss` should not be enabled: This metric will be disabled in v0.84.0 and removed in v0.86.0.")
	}
	if mbc.Metrics.ContainerMemoryUsage.Enabled {
		settings.Logger.Warn("[WARNING] `container.memory.usage` should not be enabled: This metric will be disabled in v0.84.0 and removed in v0.86.0.")
	}
	if mbc.Metrics.ContainerMemoryWorkingSet.Enabled {
		settings.Logger.Warn("[WARNING] `container.memory.working_set` should not be enabled: This metric will be disabled in v0.84.0 and removed in v0.86.0.")
	}
	mb := &MetricsBuilder{
		startTime:                               pcommon.NewTimestampFromTime(time.Now()),
		metricsBuffer:                           pmetric.NewMetrics(),
		buildInfo:                               settings.BuildInfo,
		resourceAttributesConfig:                mbc.ResourceAttributes,
		metricContainerCPUTime:                  newMetricContainerCPUTime(mbc.Metrics.ContainerCPUTime),
		metricContainerCPUUtilization:           newMetricContainerCPUUtilization(mbc.Metrics.ContainerCPUUtilization),
		metricContainerFilesystemAvailable:      newMetricContainerFilesystemAvailable(mbc.Metrics.ContainerFilesystemAvailable),
		metricContainerFilesystemCapacity:       newMetricContainerFilesystemCapacity(mbc.Metrics.ContainerFilesystemCapacity),
		metricContainerFilesystemUsage:          newMetricContainerFilesystemUsage(mbc.Metrics.ContainerFilesystemUsage),
		metricContainerMemoryAvailable:          newMetricContainerMemoryAvailable(mbc.Metrics.ContainerMemoryAvailable),
		metricContainerMemoryMajorPageFaults:    newMetricContainerMemoryMajorPageFaults(mbc.Metrics.ContainerMemoryMajorPageFaults),
		metricContainerMemoryPageFaults:         newMetricContainerMemoryPageFaults(mbc.Metrics.ContainerMemoryPageFaults),
		metricContainerMemoryRss:                newMetricContainerMemoryRss(mbc.Metrics.ContainerMemoryRss),
		metricContainerMemoryUsage:              newMetricContainerMemoryUsage(mbc.Metrics.ContainerMemoryUsage),
		metricContainerMemoryWorkingSet:         newMetricContainerMemoryWorkingSet(mbc.Metrics.ContainerMemoryWorkingSet),
		metricK8sContainerCPUTime:               newMetricK8sContainerCPUTime(mbc.Metrics.K8sContainerCPUTime),
		metricK8sContainerCPUUtilization:        newMetricK8sContainerCPUUtilization(mbc.Metrics.K8sContainerCPUUtilization),
		metricK8sContainerFilesystemAvailable:   newMetricK8sContainerFilesystemAvailable(mbc.Metrics.K8sContainerFilesystemAvailable),
		metricK8sContainerFilesystemCapacity:    newMetricK8sContainerFilesystemCapacity(mbc.Metrics.K8sContainerFilesystemCapacity),
		metricK8sContainerFilesystemUsage:       newMetricK8sContainerFilesystemUsage(mbc.Metrics.K8sContainerFilesystemUsage),
		metricK8sContainerMemoryAvailable:       newMetricK8sContainerMemoryAvailable(mbc.Metrics.K8sContainerMemoryAvailable),
		metricK8sContainerMemoryMajorPageFaults: newMetricK8sContainerMemoryMajorPageFaults(mbc.Metrics.K8sContainerMemoryMajorPageFaults),
		metricK8sContainerMemoryPageFaults:      newMetricK8sContainerMemoryPageFaults(mbc.Metrics.K8sContainerMemoryPageFaults),
		metricK8sContainerMemoryRss:             newMetricK8sContainerMemoryRss(mbc.Metrics.K8sContainerMemoryRss),
		metricK8sContainerMemoryUsage:           newMetricK8sContainerMemoryUsage(mbc.Metrics.K8sContainerMemoryUsage),
		metricK8sContainerMemoryWorkingSet:      newMetricK8sContainerMemoryWorkingSet(mbc.Metrics.K8sContainerMemoryWorkingSet),
		metricK8sNodeCPUTime:                    newMetricK8sNodeCPUTime(mbc.Metrics.K8sNodeCPUTime),
		metricK8sNodeCPUUtilization:             newMetricK8sNodeCPUUtilization(mbc.Metrics.K8sNodeCPUUtilization),
		metricK8sNodeFilesystemAvailable:        newMetricK8sNodeFilesystemAvailable(mbc.Metrics.K8sNodeFilesystemAvailable),
		metricK8sNodeFilesystemCapacity:         newMetricK8sNodeFilesystemCapacity(mbc.Metrics.K8sNodeFilesystemCapacity),
		metricK8sNodeFilesystemUsage:            newMetricK8sNodeFilesystemUsage(mbc.Metrics.K8sNodeFilesystemUsage),
		metricK8sNodeMemoryAvailable:            newMetricK8sNodeMemoryAvailable(mbc.Metrics.K8sNodeMemoryAvailable),
		metricK8sNodeMemoryMajorPageFaults:      newMetricK8sNodeMemoryMajorPageFaults(mbc.Metrics.K8sNodeMemoryMajorPageFaults),
		metricK8sNodeMemoryPageFaults:           newMetricK8sNodeMemoryPageFaults(mbc.Metrics.K8sNodeMemoryPageFaults),
		metricK8sNodeMemoryRss:                  newMetricK8sNodeMemoryRss(mbc.Metrics.K8sNodeMemoryRss),
		metricK8sNodeMemoryUsage:                newMetricK8sNodeMemoryUsage(mbc.Metrics.K8sNodeMemoryUsage),
		metricK8sNodeMemoryWorkingSet:           newMetricK8sNodeMemoryWorkingSet(mbc.Metrics.K8sNodeMemoryWorkingSet),
		metricK8sNodeNetworkErrors:              newMetricK8sNodeNetworkErrors(mbc.Metrics.K8sNodeNetworkErrors),
		metricK8sNodeNetworkIo:                  newMetricK8sNodeNetworkIo(mbc.Metrics.K8sNodeNetworkIo),
		metricK8sPodCPUTime:                     newMetricK8sPodCPUTime(mbc.Metrics.K8sPodCPUTime),
		metricK8sPodCPUUtilization:              newMetricK8sPodCPUUtilization(mbc.Metrics.K8sPodCPUUtilization),
		metricK8sPodFilesystemAvailable:         newMetricK8sPodFilesystemAvailable(mbc.Metrics.K8sPodFilesystemAvailable),
		metricK8sPodFilesystemCapacity:          newMetricK8sPodFilesystemCapacity(mbc.Metrics.K8sPodFilesystemCapacity),
		metricK8sPodFilesystemUsage:             newMetricK8sPodFilesystemUsage(mbc.Metrics.K8sPodFilesystemUsage),
		metricK8sPodMemoryAvailable:             newMetricK8sPodMemoryAvailable(mbc.Metrics.K8sPodMemoryAvailable),
		metricK8sPodMemoryMajorPageFaults:       newMetricK8sPodMemoryMajorPageFaults(mbc.Metrics.K8sPodMemoryMajorPageFaults),
		metricK8sPodMemoryPageFaults:            newMetricK8sPodMemoryPageFaults(mbc.Metrics.K8sPodMemoryPageFaults),
		metricK8sPodMemoryRss:                   newMetricK8sPodMemoryRss(mbc.Metrics.K8sPodMemoryRss),
		metricK8sPodMemoryUsage:                 newMetricK8sPodMemoryUsage(mbc.Metrics.K8sPodMemoryUsage),
		metricK8sPodMemoryWorkingSet:            newMetricK8sPodMemoryWorkingSet(mbc.Metrics.K8sPodMemoryWorkingSet),
		metricK8sPodNetworkErrors:               newMetricK8sPodNetworkErrors(mbc.Metrics.K8sPodNetworkErrors),
		metricK8sPodNetworkIo:                   newMetricK8sPodNetworkIo(mbc.Metrics.K8sPodNetworkIo),
		metricK8sVolumeAvailable:                newMetricK8sVolumeAvailable(mbc.Metrics.K8sVolumeAvailable),
		metricK8sVolumeCapacity:                 newMetricK8sVolumeCapacity(mbc.Metrics.K8sVolumeCapacity),
		metricK8sVolumeInodes:                   newMetricK8sVolumeInodes(mbc.Metrics.K8sVolumeInodes),
		metricK8sVolumeInodesFree:               newMetricK8sVolumeInodesFree(mbc.Metrics.K8sVolumeInodesFree),
		metricK8sVolumeInodesUsed:               newMetricK8sVolumeInodesUsed(mbc.Metrics.K8sVolumeInodesUsed),
	}
	for _, op := range options {
		op(mb)
	}
	return mb
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (mb *MetricsBuilder) updateCapacity(rm pmetric.ResourceMetrics) {
	if mb.metricsCapacity < rm.ScopeMetrics().At(0).Metrics().Len() {
		mb.metricsCapacity = rm.ScopeMetrics().At(0).Metrics().Len()
	}
	if mb.resourceCapacity < rm.Resource().Attributes().Len() {
		mb.resourceCapacity = rm.Resource().Attributes().Len()
	}
}

// ResourceMetricsOption applies changes to provided resource metrics.
type ResourceMetricsOption func(ResourceAttributesConfig, pmetric.ResourceMetrics)

// WithAwsVolumeID sets provided value as "aws.volume.id" attribute for current resource.
func WithAwsVolumeID(val string) ResourceMetricsOption {
	return func(rac ResourceAttributesConfig, rm pmetric.ResourceMetrics) {
		if rac.AwsVolumeID.Enabled {
			rm.Resource().Attributes().PutStr("aws.volume.id", val)
		}
	}
}

// WithContainerID sets provided value as "container.id" attribute for current resource.
func WithContainerID(val string) ResourceMetricsOption {
	return func(rac ResourceAttributesConfig, rm pmetric.ResourceMetrics) {
		if rac.ContainerID.Enabled {
			rm.Resource().Attributes().PutStr("container.id", val)
		}
	}
}

// WithFsType sets provided value as "fs.type" attribute for current resource.
func WithFsType(val string) ResourceMetricsOption {
	return func(rac ResourceAttributesConfig, rm pmetric.ResourceMetrics) {
		if rac.FsType.Enabled {
			rm.Resource().Attributes().PutStr("fs.type", val)
		}
	}
}

// WithGcePdName sets provided value as "gce.pd.name" attribute for current resource.
func WithGcePdName(val string) ResourceMetricsOption {
	return func(rac ResourceAttributesConfig, rm pmetric.ResourceMetrics) {
		if rac.GcePdName.Enabled {
			rm.Resource().Attributes().PutStr("gce.pd.name", val)
		}
	}
}

// WithGlusterfsEndpointsName sets provided value as "glusterfs.endpoints.name" attribute for current resource.
func WithGlusterfsEndpointsName(val string) ResourceMetricsOption {
	return func(rac ResourceAttributesConfig, rm pmetric.ResourceMetrics) {
		if rac.GlusterfsEndpointsName.Enabled {
			rm.Resource().Attributes().PutStr("glusterfs.endpoints.name", val)
		}
	}
}

// WithGlusterfsPath sets provided value as "glusterfs.path" attribute for current resource.
func WithGlusterfsPath(val string) ResourceMetricsOption {
	return func(rac ResourceAttributesConfig, rm pmetric.ResourceMetrics) {
		if rac.GlusterfsPath.Enabled {
			rm.Resource().Attributes().PutStr("glusterfs.path", val)
		}
	}
}

// WithK8sContainerName sets provided value as "k8s.container.name" attribute for current resource.
func WithK8sContainerName(val string) ResourceMetricsOption {
	return func(rac ResourceAttributesConfig, rm pmetric.ResourceMetrics) {
		if rac.K8sContainerName.Enabled {
			rm.Resource().Attributes().PutStr("k8s.container.name", val)
		}
	}
}

// WithK8sNamespaceName sets provided value as "k8s.namespace.name" attribute for current resource.
func WithK8sNamespaceName(val string) ResourceMetricsOption {
	return func(rac ResourceAttributesConfig, rm pmetric.ResourceMetrics) {
		if rac.K8sNamespaceName.Enabled {
			rm.Resource().Attributes().PutStr("k8s.namespace.name", val)
		}
	}
}

// WithK8sNodeName sets provided value as "k8s.node.name" attribute for current resource.
func WithK8sNodeName(val string) ResourceMetricsOption {
	return func(rac ResourceAttributesConfig, rm pmetric.ResourceMetrics) {
		if rac.K8sNodeName.Enabled {
			rm.Resource().Attributes().PutStr("k8s.node.name", val)
		}
	}
}

// WithK8sPersistentvolumeclaimName sets provided value as "k8s.persistentvolumeclaim.name" attribute for current resource.
func WithK8sPersistentvolumeclaimName(val string) ResourceMetricsOption {
	return func(rac ResourceAttributesConfig, rm pmetric.ResourceMetrics) {
		if rac.K8sPersistentvolumeclaimName.Enabled {
			rm.Resource().Attributes().PutStr("k8s.persistentvolumeclaim.name", val)
		}
	}
}

// WithK8sPodName sets provided value as "k8s.pod.name" attribute for current resource.
func WithK8sPodName(val string) ResourceMetricsOption {
	return func(rac ResourceAttributesConfig, rm pmetric.ResourceMetrics) {
		if rac.K8sPodName.Enabled {
			rm.Resource().Attributes().PutStr("k8s.pod.name", val)
		}
	}
}

// WithK8sPodUID sets provided value as "k8s.pod.uid" attribute for current resource.
func WithK8sPodUID(val string) ResourceMetricsOption {
	return func(rac ResourceAttributesConfig, rm pmetric.ResourceMetrics) {
		if rac.K8sPodUID.Enabled {
			rm.Resource().Attributes().PutStr("k8s.pod.uid", val)
		}
	}
}

// WithK8sVolumeName sets provided value as "k8s.volume.name" attribute for current resource.
func WithK8sVolumeName(val string) ResourceMetricsOption {
	return func(rac ResourceAttributesConfig, rm pmetric.ResourceMetrics) {
		if rac.K8sVolumeName.Enabled {
			rm.Resource().Attributes().PutStr("k8s.volume.name", val)
		}
	}
}

// WithK8sVolumeType sets provided value as "k8s.volume.type" attribute for current resource.
func WithK8sVolumeType(val string) ResourceMetricsOption {
	return func(rac ResourceAttributesConfig, rm pmetric.ResourceMetrics) {
		if rac.K8sVolumeType.Enabled {
			rm.Resource().Attributes().PutStr("k8s.volume.type", val)
		}
	}
}

// WithPartition sets provided value as "partition" attribute for current resource.
func WithPartition(val string) ResourceMetricsOption {
	return func(rac ResourceAttributesConfig, rm pmetric.ResourceMetrics) {
		if rac.Partition.Enabled {
			rm.Resource().Attributes().PutStr("partition", val)
		}
	}
}

// WithStartTimeOverride overrides start time for all the resource metrics data points.
// This option should be only used if different start time has to be set on metrics coming from different resources.
func WithStartTimeOverride(start pcommon.Timestamp) ResourceMetricsOption {
	return func(_ ResourceAttributesConfig, rm pmetric.ResourceMetrics) {
		var dps pmetric.NumberDataPointSlice
		metrics := rm.ScopeMetrics().At(0).Metrics()
		for i := 0; i < metrics.Len(); i++ {
			switch metrics.At(i).Type() {
			case pmetric.MetricTypeGauge:
				dps = metrics.At(i).Gauge().DataPoints()
			case pmetric.MetricTypeSum:
				dps = metrics.At(i).Sum().DataPoints()
			}
			for j := 0; j < dps.Len(); j++ {
				dps.At(j).SetStartTimestamp(start)
			}
		}
	}
}

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead.
// Resource attributes should be provided as ResourceMetricsOption arguments.
func (mb *MetricsBuilder) EmitForResource(rmo ...ResourceMetricsOption) {
	rm := pmetric.NewResourceMetrics()
	rm.Resource().Attributes().EnsureCapacity(mb.resourceCapacity)
	ils := rm.ScopeMetrics().AppendEmpty()
	ils.Scope().SetName("otelcol/kubeletstatsreceiver")
	ils.Scope().SetVersion(mb.buildInfo.Version)
	ils.Metrics().EnsureCapacity(mb.metricsCapacity)
	mb.metricContainerCPUTime.emit(ils.Metrics())
	mb.metricContainerCPUUtilization.emit(ils.Metrics())
	mb.metricContainerFilesystemAvailable.emit(ils.Metrics())
	mb.metricContainerFilesystemCapacity.emit(ils.Metrics())
	mb.metricContainerFilesystemUsage.emit(ils.Metrics())
	mb.metricContainerMemoryAvailable.emit(ils.Metrics())
	mb.metricContainerMemoryMajorPageFaults.emit(ils.Metrics())
	mb.metricContainerMemoryPageFaults.emit(ils.Metrics())
	mb.metricContainerMemoryRss.emit(ils.Metrics())
	mb.metricContainerMemoryUsage.emit(ils.Metrics())
	mb.metricContainerMemoryWorkingSet.emit(ils.Metrics())
	mb.metricK8sContainerCPUTime.emit(ils.Metrics())
	mb.metricK8sContainerCPUUtilization.emit(ils.Metrics())
	mb.metricK8sContainerFilesystemAvailable.emit(ils.Metrics())
	mb.metricK8sContainerFilesystemCapacity.emit(ils.Metrics())
	mb.metricK8sContainerFilesystemUsage.emit(ils.Metrics())
	mb.metricK8sContainerMemoryAvailable.emit(ils.Metrics())
	mb.metricK8sContainerMemoryMajorPageFaults.emit(ils.Metrics())
	mb.metricK8sContainerMemoryPageFaults.emit(ils.Metrics())
	mb.metricK8sContainerMemoryRss.emit(ils.Metrics())
	mb.metricK8sContainerMemoryUsage.emit(ils.Metrics())
	mb.metricK8sContainerMemoryWorkingSet.emit(ils.Metrics())
	mb.metricK8sNodeCPUTime.emit(ils.Metrics())
	mb.metricK8sNodeCPUUtilization.emit(ils.Metrics())
	mb.metricK8sNodeFilesystemAvailable.emit(ils.Metrics())
	mb.metricK8sNodeFilesystemCapacity.emit(ils.Metrics())
	mb.metricK8sNodeFilesystemUsage.emit(ils.Metrics())
	mb.metricK8sNodeMemoryAvailable.emit(ils.Metrics())
	mb.metricK8sNodeMemoryMajorPageFaults.emit(ils.Metrics())
	mb.metricK8sNodeMemoryPageFaults.emit(ils.Metrics())
	mb.metricK8sNodeMemoryRss.emit(ils.Metrics())
	mb.metricK8sNodeMemoryUsage.emit(ils.Metrics())
	mb.metricK8sNodeMemoryWorkingSet.emit(ils.Metrics())
	mb.metricK8sNodeNetworkErrors.emit(ils.Metrics())
	mb.metricK8sNodeNetworkIo.emit(ils.Metrics())
	mb.metricK8sPodCPUTime.emit(ils.Metrics())
	mb.metricK8sPodCPUUtilization.emit(ils.Metrics())
	mb.metricK8sPodFilesystemAvailable.emit(ils.Metrics())
	mb.metricK8sPodFilesystemCapacity.emit(ils.Metrics())
	mb.metricK8sPodFilesystemUsage.emit(ils.Metrics())
	mb.metricK8sPodMemoryAvailable.emit(ils.Metrics())
	mb.metricK8sPodMemoryMajorPageFaults.emit(ils.Metrics())
	mb.metricK8sPodMemoryPageFaults.emit(ils.Metrics())
	mb.metricK8sPodMemoryRss.emit(ils.Metrics())
	mb.metricK8sPodMemoryUsage.emit(ils.Metrics())
	mb.metricK8sPodMemoryWorkingSet.emit(ils.Metrics())
	mb.metricK8sPodNetworkErrors.emit(ils.Metrics())
	mb.metricK8sPodNetworkIo.emit(ils.Metrics())
	mb.metricK8sVolumeAvailable.emit(ils.Metrics())
	mb.metricK8sVolumeCapacity.emit(ils.Metrics())
	mb.metricK8sVolumeInodes.emit(ils.Metrics())
	mb.metricK8sVolumeInodesFree.emit(ils.Metrics())
	mb.metricK8sVolumeInodesUsed.emit(ils.Metrics())

	for _, op := range rmo {
		op(mb.resourceAttributesConfig, rm)
	}
	if ils.Metrics().Len() > 0 {
		mb.updateCapacity(rm)
		rm.MoveTo(mb.metricsBuffer.ResourceMetrics().AppendEmpty())
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user config, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit(rmo ...ResourceMetricsOption) pmetric.Metrics {
	mb.EmitForResource(rmo...)
	metrics := mb.metricsBuffer
	mb.metricsBuffer = pmetric.NewMetrics()
	return metrics
}

// RecordContainerCPUTimeDataPoint adds a data point to container.cpu.time metric.
func (mb *MetricsBuilder) RecordContainerCPUTimeDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricContainerCPUTime.recordDataPoint(mb.startTime, ts, val)
}

// RecordContainerCPUUtilizationDataPoint adds a data point to container.cpu.utilization metric.
func (mb *MetricsBuilder) RecordContainerCPUUtilizationDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricContainerCPUUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordContainerFilesystemAvailableDataPoint adds a data point to container.filesystem.available metric.
func (mb *MetricsBuilder) RecordContainerFilesystemAvailableDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricContainerFilesystemAvailable.recordDataPoint(mb.startTime, ts, val)
}

// RecordContainerFilesystemCapacityDataPoint adds a data point to container.filesystem.capacity metric.
func (mb *MetricsBuilder) RecordContainerFilesystemCapacityDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricContainerFilesystemCapacity.recordDataPoint(mb.startTime, ts, val)
}

// RecordContainerFilesystemUsageDataPoint adds a data point to container.filesystem.usage metric.
func (mb *MetricsBuilder) RecordContainerFilesystemUsageDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricContainerFilesystemUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordContainerMemoryAvailableDataPoint adds a data point to container.memory.available metric.
func (mb *MetricsBuilder) RecordContainerMemoryAvailableDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricContainerMemoryAvailable.recordDataPoint(mb.startTime, ts, val)
}

// RecordContainerMemoryMajorPageFaultsDataPoint adds a data point to container.memory.major_page_faults metric.
func (mb *MetricsBuilder) RecordContainerMemoryMajorPageFaultsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricContainerMemoryMajorPageFaults.recordDataPoint(mb.startTime, ts, val)
}

// RecordContainerMemoryPageFaultsDataPoint adds a data point to container.memory.page_faults metric.
func (mb *MetricsBuilder) RecordContainerMemoryPageFaultsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricContainerMemoryPageFaults.recordDataPoint(mb.startTime, ts, val)
}

// RecordContainerMemoryRssDataPoint adds a data point to container.memory.rss metric.
func (mb *MetricsBuilder) RecordContainerMemoryRssDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricContainerMemoryRss.recordDataPoint(mb.startTime, ts, val)
}

// RecordContainerMemoryUsageDataPoint adds a data point to container.memory.usage metric.
func (mb *MetricsBuilder) RecordContainerMemoryUsageDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricContainerMemoryUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordContainerMemoryWorkingSetDataPoint adds a data point to container.memory.working_set metric.
func (mb *MetricsBuilder) RecordContainerMemoryWorkingSetDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricContainerMemoryWorkingSet.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sContainerCPUTimeDataPoint adds a data point to k8s.container.cpu.time metric.
func (mb *MetricsBuilder) RecordK8sContainerCPUTimeDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricK8sContainerCPUTime.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sContainerCPUUtilizationDataPoint adds a data point to k8s.container.cpu.utilization metric.
func (mb *MetricsBuilder) RecordK8sContainerCPUUtilizationDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricK8sContainerCPUUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sContainerFilesystemAvailableDataPoint adds a data point to k8s.container.filesystem.available metric.
func (mb *MetricsBuilder) RecordK8sContainerFilesystemAvailableDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sContainerFilesystemAvailable.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sContainerFilesystemCapacityDataPoint adds a data point to k8s.container.filesystem.capacity metric.
func (mb *MetricsBuilder) RecordK8sContainerFilesystemCapacityDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sContainerFilesystemCapacity.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sContainerFilesystemUsageDataPoint adds a data point to k8s.container.filesystem.usage metric.
func (mb *MetricsBuilder) RecordK8sContainerFilesystemUsageDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sContainerFilesystemUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sContainerMemoryAvailableDataPoint adds a data point to k8s.container.memory.available metric.
func (mb *MetricsBuilder) RecordK8sContainerMemoryAvailableDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sContainerMemoryAvailable.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sContainerMemoryMajorPageFaultsDataPoint adds a data point to k8s.container.memory.major_page_faults metric.
func (mb *MetricsBuilder) RecordK8sContainerMemoryMajorPageFaultsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sContainerMemoryMajorPageFaults.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sContainerMemoryPageFaultsDataPoint adds a data point to k8s.container.memory.page_faults metric.
func (mb *MetricsBuilder) RecordK8sContainerMemoryPageFaultsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sContainerMemoryPageFaults.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sContainerMemoryRssDataPoint adds a data point to k8s.container.memory.rss metric.
func (mb *MetricsBuilder) RecordK8sContainerMemoryRssDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sContainerMemoryRss.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sContainerMemoryUsageDataPoint adds a data point to k8s.container.memory.usage metric.
func (mb *MetricsBuilder) RecordK8sContainerMemoryUsageDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sContainerMemoryUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sContainerMemoryWorkingSetDataPoint adds a data point to k8s.container.memory.working_set metric.
func (mb *MetricsBuilder) RecordK8sContainerMemoryWorkingSetDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sContainerMemoryWorkingSet.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sNodeCPUTimeDataPoint adds a data point to k8s.node.cpu.time metric.
func (mb *MetricsBuilder) RecordK8sNodeCPUTimeDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricK8sNodeCPUTime.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sNodeCPUUtilizationDataPoint adds a data point to k8s.node.cpu.utilization metric.
func (mb *MetricsBuilder) RecordK8sNodeCPUUtilizationDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricK8sNodeCPUUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sNodeFilesystemAvailableDataPoint adds a data point to k8s.node.filesystem.available metric.
func (mb *MetricsBuilder) RecordK8sNodeFilesystemAvailableDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sNodeFilesystemAvailable.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sNodeFilesystemCapacityDataPoint adds a data point to k8s.node.filesystem.capacity metric.
func (mb *MetricsBuilder) RecordK8sNodeFilesystemCapacityDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sNodeFilesystemCapacity.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sNodeFilesystemUsageDataPoint adds a data point to k8s.node.filesystem.usage metric.
func (mb *MetricsBuilder) RecordK8sNodeFilesystemUsageDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sNodeFilesystemUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sNodeMemoryAvailableDataPoint adds a data point to k8s.node.memory.available metric.
func (mb *MetricsBuilder) RecordK8sNodeMemoryAvailableDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sNodeMemoryAvailable.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sNodeMemoryMajorPageFaultsDataPoint adds a data point to k8s.node.memory.major_page_faults metric.
func (mb *MetricsBuilder) RecordK8sNodeMemoryMajorPageFaultsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sNodeMemoryMajorPageFaults.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sNodeMemoryPageFaultsDataPoint adds a data point to k8s.node.memory.page_faults metric.
func (mb *MetricsBuilder) RecordK8sNodeMemoryPageFaultsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sNodeMemoryPageFaults.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sNodeMemoryRssDataPoint adds a data point to k8s.node.memory.rss metric.
func (mb *MetricsBuilder) RecordK8sNodeMemoryRssDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sNodeMemoryRss.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sNodeMemoryUsageDataPoint adds a data point to k8s.node.memory.usage metric.
func (mb *MetricsBuilder) RecordK8sNodeMemoryUsageDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sNodeMemoryUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sNodeMemoryWorkingSetDataPoint adds a data point to k8s.node.memory.working_set metric.
func (mb *MetricsBuilder) RecordK8sNodeMemoryWorkingSetDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sNodeMemoryWorkingSet.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sNodeNetworkErrorsDataPoint adds a data point to k8s.node.network.errors metric.
func (mb *MetricsBuilder) RecordK8sNodeNetworkErrorsDataPoint(ts pcommon.Timestamp, val int64, interfaceAttributeValue string, directionAttributeValue AttributeDirection) {
	mb.metricK8sNodeNetworkErrors.recordDataPoint(mb.startTime, ts, val, interfaceAttributeValue, directionAttributeValue.String())
}

// RecordK8sNodeNetworkIoDataPoint adds a data point to k8s.node.network.io metric.
func (mb *MetricsBuilder) RecordK8sNodeNetworkIoDataPoint(ts pcommon.Timestamp, val int64, interfaceAttributeValue string, directionAttributeValue AttributeDirection) {
	mb.metricK8sNodeNetworkIo.recordDataPoint(mb.startTime, ts, val, interfaceAttributeValue, directionAttributeValue.String())
}

// RecordK8sPodCPUTimeDataPoint adds a data point to k8s.pod.cpu.time metric.
func (mb *MetricsBuilder) RecordK8sPodCPUTimeDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricK8sPodCPUTime.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodCPUUtilizationDataPoint adds a data point to k8s.pod.cpu.utilization metric.
func (mb *MetricsBuilder) RecordK8sPodCPUUtilizationDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricK8sPodCPUUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodFilesystemAvailableDataPoint adds a data point to k8s.pod.filesystem.available metric.
func (mb *MetricsBuilder) RecordK8sPodFilesystemAvailableDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sPodFilesystemAvailable.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodFilesystemCapacityDataPoint adds a data point to k8s.pod.filesystem.capacity metric.
func (mb *MetricsBuilder) RecordK8sPodFilesystemCapacityDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sPodFilesystemCapacity.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodFilesystemUsageDataPoint adds a data point to k8s.pod.filesystem.usage metric.
func (mb *MetricsBuilder) RecordK8sPodFilesystemUsageDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sPodFilesystemUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodMemoryAvailableDataPoint adds a data point to k8s.pod.memory.available metric.
func (mb *MetricsBuilder) RecordK8sPodMemoryAvailableDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sPodMemoryAvailable.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodMemoryMajorPageFaultsDataPoint adds a data point to k8s.pod.memory.major_page_faults metric.
func (mb *MetricsBuilder) RecordK8sPodMemoryMajorPageFaultsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sPodMemoryMajorPageFaults.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodMemoryPageFaultsDataPoint adds a data point to k8s.pod.memory.page_faults metric.
func (mb *MetricsBuilder) RecordK8sPodMemoryPageFaultsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sPodMemoryPageFaults.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodMemoryRssDataPoint adds a data point to k8s.pod.memory.rss metric.
func (mb *MetricsBuilder) RecordK8sPodMemoryRssDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sPodMemoryRss.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodMemoryUsageDataPoint adds a data point to k8s.pod.memory.usage metric.
func (mb *MetricsBuilder) RecordK8sPodMemoryUsageDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sPodMemoryUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodMemoryWorkingSetDataPoint adds a data point to k8s.pod.memory.working_set metric.
func (mb *MetricsBuilder) RecordK8sPodMemoryWorkingSetDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sPodMemoryWorkingSet.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sPodNetworkErrorsDataPoint adds a data point to k8s.pod.network.errors metric.
func (mb *MetricsBuilder) RecordK8sPodNetworkErrorsDataPoint(ts pcommon.Timestamp, val int64, interfaceAttributeValue string, directionAttributeValue AttributeDirection) {
	mb.metricK8sPodNetworkErrors.recordDataPoint(mb.startTime, ts, val, interfaceAttributeValue, directionAttributeValue.String())
}

// RecordK8sPodNetworkIoDataPoint adds a data point to k8s.pod.network.io metric.
func (mb *MetricsBuilder) RecordK8sPodNetworkIoDataPoint(ts pcommon.Timestamp, val int64, interfaceAttributeValue string, directionAttributeValue AttributeDirection) {
	mb.metricK8sPodNetworkIo.recordDataPoint(mb.startTime, ts, val, interfaceAttributeValue, directionAttributeValue.String())
}

// RecordK8sVolumeAvailableDataPoint adds a data point to k8s.volume.available metric.
func (mb *MetricsBuilder) RecordK8sVolumeAvailableDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sVolumeAvailable.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sVolumeCapacityDataPoint adds a data point to k8s.volume.capacity metric.
func (mb *MetricsBuilder) RecordK8sVolumeCapacityDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sVolumeCapacity.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sVolumeInodesDataPoint adds a data point to k8s.volume.inodes metric.
func (mb *MetricsBuilder) RecordK8sVolumeInodesDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sVolumeInodes.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sVolumeInodesFreeDataPoint adds a data point to k8s.volume.inodes.free metric.
func (mb *MetricsBuilder) RecordK8sVolumeInodesFreeDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sVolumeInodesFree.recordDataPoint(mb.startTime, ts, val)
}

// RecordK8sVolumeInodesUsedDataPoint adds a data point to k8s.volume.inodes.used metric.
func (mb *MetricsBuilder) RecordK8sVolumeInodesUsedDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricK8sVolumeInodesUsed.recordDataPoint(mb.startTime, ts, val)
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...metricBuilderOption) {
	mb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op(mb)
	}
}
