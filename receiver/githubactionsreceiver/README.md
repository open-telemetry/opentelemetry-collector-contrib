# GitHub Actions Receiver

<!-- status autogenerated section -->
| Status        |           |
| ------------- |-----------|
| Stability     | [alpha]: traces   |
| Distributions | [] |
| Issues        | [![Open issues](https://img.shields.io/github/issues-search/open-telemetry/opentelemetry-collector-contrib?query=is%3Aissue%20is%3Aopen%20label%3Areceiver%2Fgithubactionsevent%20&label=open&color=orange&logo=opentelemetry)](https://github.com/open-telemetry/opentelemetry-collector-contrib/issues?q=is%3Aopen+is%3Aissue+label%3Areceiver%2Fgithubactionsevent) [![Closed issues](https://img.shields.io/github/issues-search/open-telemetry/opentelemetry-collector-contrib?query=is%3Aissue%20is%3Aclosed%20label%3Areceiver%2Fgithubactionsevent%20&label=closed&color=blue&logo=opentelemetry)](https://github.com/open-telemetry/opentelemetry-collector-contrib/issues?q=is%3Aclosed+is%3Aissue+label%3Areceiver%2Fgithubactionsevent) |
| [Code Owners](https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/CONTRIBUTING.md#becoming-a-code-owner)    | [@krzko](https://www.github.com/krzko), [@rich-bain](https://www.github.com/rich-bain) |

[alpha]: https://github.com/open-telemetry/opentelemetry-collector#alpha
<!-- end autogenerated section -->

The GitHub Actions Receiver processes GitHub Actions webhook events to observe workflows and jobs. It handles [`workflow_job`](https://docs.github.com/en/webhooks/webhook-events-and-payloads#workflow_job) and [`workflow_run`](https://docs.github.com/en/webhooks/webhook-events-and-payloads#workflow_run) event payloads, transforming them into `trace` telemetry.

Each GitHub Action workflow or job, along with its steps, are converted into trace spans, allowing the observation of workflow execution times, success, and failure rates.

If a secret is configured (recommended), it [validates the payload](https://docs.github.com/en/webhooks/using-webhooks/validating-webhook-deliveries) ensuring data integrity before processing.

The receiver supports linking spans to previous runs for `workflow_run` events, enhancing traceability across workflow attempts. This feature utilises deterministic Trace IDs generated based on the run ID and run attempt. When a `workflow_run` event contains a `PreviousAttemptURL`, and the run attempt is greater than `1`, the receiver automatically links the current run's root span to the previous run's Trace ID, providing a direct connection between sequential workflow attempts.

## Configuration

The following settings are required:

* `endpoint` (no default): The endpoint where you may point your webhook to emit events to

The following settings are optional:

* `path` (default: '/events'): Path where the receiver instance will accept events 
* `secret`: GitHub webhook hash signature

Example:
```yaml
receivers:
    githubactions:
        endpoint: localhost:19418
        path: /events
        secret: It's a Secret to Everybody
```
The full list of settings exposed for this receiver are documented [here](./config.go) with a detailed sample configuration [here](./testdata/config.yaml)

## Advanced Configuration

Several helper files are leveraged to provide additional capabilities automatically:

- [HTTP server settings](https://github.com/open-telemetry/opentelemetry-collector/blob/main/config/confighttp/README.md#server-configuration) including CORS
- [TLS and mTLS settings](https://github.com/open-telemetry/opentelemetry-collector/blob/main/config/configtls/README.md)

### Service Name Generation

The GitHub Actions Receiver dynamically generates the `service.name` attribute, which is crucial for identifying the source of telemetry data in observability platforms. This name helps in categorising and filtering traces originating from different GitHub repositories or actions workflows.

#### Default Service Name

By default, the service name is derived from the **GitHub repository's full name** (e.g., org/repo-name) provided in the payload. This name is then formatted to be all lowercase and to have slashes (/) and underscores (_) replaced with dashes (-), ensuring a clean, URL-friendly identifier.

#### Customisation Options

While the default naming convention should suffice for most use cases, there might be scenarios where a more descriptive or specific service name is required. For such cases, the receiver's configuration provides options for customization:

* **Custom Service Name**: A completely custom service.name that overrides the default naming convention. This is useful when you want to assign a specific, recognisable name to the telemetry data from a particular GitHub repository or workflow.

* **Service Name Prefix and Suffix**: These allow for the addition of prefixes or suffixes to the automatically generated service name, offering a balance between automatic naming and customization.

Here's an example snippet from a configuration file (config.yaml) demonstrating how to set these options:

```yaml
receivers:
  githubactionsreceiver:
    custom_service_name: "github-com-myorg" # Completely overrides the default service name
    service_name_prefix: "foo-" # Prepended to the default service name (ignored if custom_service_name is set)
    service_name_suffix: "-bar" # Appended to the default service name (ignored if custom_service_name is set)
```

## GitHub repository webhooks

Webhooks provide a way for notifications to be delivered to an external web server whenever certain events occur on GitHub.

### Delivery headers

HTTP POST payloads that are delivered to your webhook's configured URL endpoint will contain several special headers:

* `X-Hub-Signature`: This header is sent if the webhook is configured with a `secret`. This is the HMAC hex digest of the request body, and is generated using the SHA-1 hash function and the `secret` as the HMAC `key`. `X-Hub-Signature` is provided for compatibility with existing integrations. It's recommended that you use the more secure `X-Hub-Signature-256` instead.
* `X-Hub-Signature-256`: This header is sent if the webhook is configured with a `secret` (recommended). This is the HMAC hex digest of the request body, and is generated using the SHA-256 hash function and the `secret` as the HMAC `key`.
* `User-Agent`: This header will always have the prefix `GitHub-Hookshot/`.

### Creating webhooks

You can create webhooks to subscribe to specific events that occur on GitHub.

#### Creating a respositoty webhook

You can create a webhook to subscribe to events that occur in a specific repository. You must be a repository owner or have admin access in the repository to create webhooks in that repository.

1. On **GitHub.com**, navigate to the main page of the repository.
2. Under your repository name, click **Settings**. If you cannot see the "Settings" tab, select the dropdown menu, then click Settings.
3. In the left sidebar, click **Webhooks**.
4. Click Add **webhook**.
5. Under "Payload URL", type the URL where you'd like to receive payloads.
6. Select the **Content type** drop-down menu, and click a data format to receive the webhook payload in. 
    * Select `application/json`, which will deliver the JSON payload directly as the body of the `POST` request.
7. Optionally (recomended), under "Secret", type a string to use as a secret key. You should choose a random string of text with high entropy. You can use the webhook secret to limit incoming requests to only those originating from GitHub. 
8. Under "Which events would you like to trigger this webhook?"
    * Select **Let me select individual events**.
    * Uncheck **Pushes**, which is selected by default.
    * Select **Workflow jobs**.
    * Select **Workflow runs**.
9. To make the webhook active immediately after adding the configuration, select **Active**.
10. Click **Add webhook**.

You can use the GitHub web interface or the REST API to create a repository webhook. For more information about using the REST API to create a repository webhook, see [Repository Webhooks](https://docs.github.com/en/rest/webhooks/repos?apiVersion=2022-11-28#create-a-repository-webhook).

Alternatively you can use a configuration management tool such as [`terraform`](https://www.terraform.io/) with the [`github_repository_webhook`](https://registry.terraform.io/providers/integrations/github/latest/docs/resources/repository_webhook.html) resource, to configure webhooks.


### Deterministic IDs

The GitHub Actions Receiver generates deterministic IDs to ensure traceability and consistency across emitted spans. Hereâ€™s how the IDs are generated:

* **Trace ID**: Generated based on the run ID and run attempt, with a 't' appended to ensure uniqueness across workflow runs and to distinguish it as a trace ID.
* **Parent Span ID**: Derived from the workflow job ID and run attempt, with an 's' appended to distinguish it as a span ID and allow association of all steps under a job.
* **Span ID**: Specifically generated for each step within a job, using the job ID, run attempt, step name, and an optional step number, to ensure each step within a job can be uniquely identified.

These IDs allow for the correlation of telemetry data within the observability platform, enabling users to link their own spans to those emitted by the receiver.

#### Generating IDs

Below are example functions in a couple of langues for generating each ID, replicating the logic used by the receiver:

##### Generating IDs in `bash`

```bash
generate_trace_id() {
  run_id=$1
  run_attempt=$2
  echo -n "${run_id}${run_attempt}t" | openssl dgst -sha256 | sed 's/^.* //'
}

generate_parent_span_id() {
  job_id=$1
  run_attempt=$2
  echo -n "${job_id}${run_attempt}s" | openssl dgst -sha256 | sed 's/^.* //'
}

generate_span_id() {
  job_id=$1
  run_attempt=$2
  step_name=$3
  step_number=$4 # optional
  input="${job_id}${run_attempt}${step_name}${step_number}"
  echo -n "$input" | openssl dgst -sha256 | sed 's/^.* //'
}

trace_id=$(generate_trace_id 12345 1)
parent_span_id=$(generate_parent_span_id 12345 1)
span_id=$(generate_span_id 12345 1 "step-name" 1)

echo "Trace ID: ${trace_id:0:32}"
echo "Parent Span ID: ${parent_span_id:0:16}"
echo "Span ID: ${span_id:0:16}"
```

##### Generating IDs in `python`

```python
import hashlib
import binascii

def generate_trace_id(run_id, run_attempt):
    input_str = f"{run_id}{run_attempt}t"
    hashed = hashlib.sha256(input_str.encode()).digest()
    return binascii.hexlify(hashed).decode()[:32]

def generate_parent_span_id(job_id, run_attempt):
    input_str = f"{job_id}{run_attempt}s"
    hashed = hashlib.sha256(input_str.encode()).digest()
    return binascii.hexlify(hashed).decode()[:16]

def generate_span_id(job_id, run_attempt, step_name, step_number=None):
    step_number_str = str(step_number) if step_number is not None else ""
    input_str = f"{job_id}{run_attempt}{step_name}{step_number_str}"
    hashed = hashlib.sha256(input_str.encode()).digest()
    return binascii.hexlify(hashed).decode()[:16]

trace_id = generate_trace_id(12345, 1)
parent_span_id = generate_parent_span_id(12345, 1)
span_id = generate_span_id(12345, 1, "step-name", 1)

print("Trace ID:", trace_id)
print("Parent Span ID:", parent_span_id)
print("Span ID:", span_id)
```

##### Generating IDs in Other Languages

You can adapt the logic shown in the bash examples to any programming language that supports SHA-256 hashing. The key is to ensure the input string format matches between your code and the receiver for consistent ID generation.
