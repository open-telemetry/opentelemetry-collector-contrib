// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
	"go.opentelemetry.io/collector/scraper"
	conventions "go.opentelemetry.io/otel/semconv/v1.9.0"
)

var MetricsInfo = metricsInfo{
	SystemPsiCPUSomeAvg10: metricInfo{
		Name: "system.psi.cpu.some.avg10",
	},
	SystemPsiCPUSomeAvg300: metricInfo{
		Name: "system.psi.cpu.some.avg300",
	},
	SystemPsiCPUSomeAvg60: metricInfo{
		Name: "system.psi.cpu.some.avg60",
	},
	SystemPsiCPUSomeTotal: metricInfo{
		Name: "system.psi.cpu.some.total",
	},
	SystemPsiIoFullAvg10: metricInfo{
		Name: "system.psi.io.full.avg10",
	},
	SystemPsiIoFullAvg300: metricInfo{
		Name: "system.psi.io.full.avg300",
	},
	SystemPsiIoFullAvg60: metricInfo{
		Name: "system.psi.io.full.avg60",
	},
	SystemPsiIoFullTotal: metricInfo{
		Name: "system.psi.io.full.total",
	},
	SystemPsiIoSomeAvg10: metricInfo{
		Name: "system.psi.io.some.avg10",
	},
	SystemPsiIoSomeAvg300: metricInfo{
		Name: "system.psi.io.some.avg300",
	},
	SystemPsiIoSomeAvg60: metricInfo{
		Name: "system.psi.io.some.avg60",
	},
	SystemPsiIoSomeTotal: metricInfo{
		Name: "system.psi.io.some.total",
	},
	SystemPsiMemoryFullAvg10: metricInfo{
		Name: "system.psi.memory.full.avg10",
	},
	SystemPsiMemoryFullAvg300: metricInfo{
		Name: "system.psi.memory.full.avg300",
	},
	SystemPsiMemoryFullAvg60: metricInfo{
		Name: "system.psi.memory.full.avg60",
	},
	SystemPsiMemoryFullTotal: metricInfo{
		Name: "system.psi.memory.full.total",
	},
	SystemPsiMemorySomeAvg10: metricInfo{
		Name: "system.psi.memory.some.avg10",
	},
	SystemPsiMemorySomeAvg300: metricInfo{
		Name: "system.psi.memory.some.avg300",
	},
	SystemPsiMemorySomeAvg60: metricInfo{
		Name: "system.psi.memory.some.avg60",
	},
	SystemPsiMemorySomeTotal: metricInfo{
		Name: "system.psi.memory.some.total",
	},
}

type metricsInfo struct {
	SystemPsiCPUSomeAvg10     metricInfo
	SystemPsiCPUSomeAvg300    metricInfo
	SystemPsiCPUSomeAvg60     metricInfo
	SystemPsiCPUSomeTotal     metricInfo
	SystemPsiIoFullAvg10      metricInfo
	SystemPsiIoFullAvg300     metricInfo
	SystemPsiIoFullAvg60      metricInfo
	SystemPsiIoFullTotal      metricInfo
	SystemPsiIoSomeAvg10      metricInfo
	SystemPsiIoSomeAvg300     metricInfo
	SystemPsiIoSomeAvg60      metricInfo
	SystemPsiIoSomeTotal      metricInfo
	SystemPsiMemoryFullAvg10  metricInfo
	SystemPsiMemoryFullAvg300 metricInfo
	SystemPsiMemoryFullAvg60  metricInfo
	SystemPsiMemoryFullTotal  metricInfo
	SystemPsiMemorySomeAvg10  metricInfo
	SystemPsiMemorySomeAvg300 metricInfo
	SystemPsiMemorySomeAvg60  metricInfo
	SystemPsiMemorySomeTotal  metricInfo
}

type metricInfo struct {
	Name string
}

type metricSystemPsiCPUSomeAvg10 struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills system.psi.cpu.some.avg10 metric with initial data.
func (m *metricSystemPsiCPUSomeAvg10) init() {
	m.data.SetName("system.psi.cpu.some.avg10")
	m.data.SetDescription("CPU pressure stall information - some tasks waiting, 10 second average")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSystemPsiCPUSomeAvg10) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSystemPsiCPUSomeAvg10) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSystemPsiCPUSomeAvg10) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSystemPsiCPUSomeAvg10(cfg MetricConfig) metricSystemPsiCPUSomeAvg10 {
	m := metricSystemPsiCPUSomeAvg10{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSystemPsiCPUSomeAvg300 struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills system.psi.cpu.some.avg300 metric with initial data.
func (m *metricSystemPsiCPUSomeAvg300) init() {
	m.data.SetName("system.psi.cpu.some.avg300")
	m.data.SetDescription("CPU pressure stall information - some tasks waiting, 300 second average")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSystemPsiCPUSomeAvg300) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSystemPsiCPUSomeAvg300) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSystemPsiCPUSomeAvg300) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSystemPsiCPUSomeAvg300(cfg MetricConfig) metricSystemPsiCPUSomeAvg300 {
	m := metricSystemPsiCPUSomeAvg300{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSystemPsiCPUSomeAvg60 struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills system.psi.cpu.some.avg60 metric with initial data.
func (m *metricSystemPsiCPUSomeAvg60) init() {
	m.data.SetName("system.psi.cpu.some.avg60")
	m.data.SetDescription("CPU pressure stall information - some tasks waiting, 60 second average")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSystemPsiCPUSomeAvg60) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSystemPsiCPUSomeAvg60) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSystemPsiCPUSomeAvg60) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSystemPsiCPUSomeAvg60(cfg MetricConfig) metricSystemPsiCPUSomeAvg60 {
	m := metricSystemPsiCPUSomeAvg60{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSystemPsiCPUSomeTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills system.psi.cpu.some.total metric with initial data.
func (m *metricSystemPsiCPUSomeTotal) init() {
	m.data.SetName("system.psi.cpu.some.total")
	m.data.SetDescription("CPU pressure stall information - some tasks waiting, total time in microseconds")
	m.data.SetUnit("us")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSystemPsiCPUSomeTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSystemPsiCPUSomeTotal) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSystemPsiCPUSomeTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSystemPsiCPUSomeTotal(cfg MetricConfig) metricSystemPsiCPUSomeTotal {
	m := metricSystemPsiCPUSomeTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSystemPsiIoFullAvg10 struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills system.psi.io.full.avg10 metric with initial data.
func (m *metricSystemPsiIoFullAvg10) init() {
	m.data.SetName("system.psi.io.full.avg10")
	m.data.SetDescription("IO pressure stall information - all tasks waiting, 10 second average")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSystemPsiIoFullAvg10) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSystemPsiIoFullAvg10) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSystemPsiIoFullAvg10) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSystemPsiIoFullAvg10(cfg MetricConfig) metricSystemPsiIoFullAvg10 {
	m := metricSystemPsiIoFullAvg10{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSystemPsiIoFullAvg300 struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills system.psi.io.full.avg300 metric with initial data.
func (m *metricSystemPsiIoFullAvg300) init() {
	m.data.SetName("system.psi.io.full.avg300")
	m.data.SetDescription("IO pressure stall information - all tasks waiting, 300 second average")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSystemPsiIoFullAvg300) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSystemPsiIoFullAvg300) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSystemPsiIoFullAvg300) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSystemPsiIoFullAvg300(cfg MetricConfig) metricSystemPsiIoFullAvg300 {
	m := metricSystemPsiIoFullAvg300{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSystemPsiIoFullAvg60 struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills system.psi.io.full.avg60 metric with initial data.
func (m *metricSystemPsiIoFullAvg60) init() {
	m.data.SetName("system.psi.io.full.avg60")
	m.data.SetDescription("IO pressure stall information - all tasks waiting, 60 second average")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSystemPsiIoFullAvg60) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSystemPsiIoFullAvg60) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSystemPsiIoFullAvg60) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSystemPsiIoFullAvg60(cfg MetricConfig) metricSystemPsiIoFullAvg60 {
	m := metricSystemPsiIoFullAvg60{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSystemPsiIoFullTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills system.psi.io.full.total metric with initial data.
func (m *metricSystemPsiIoFullTotal) init() {
	m.data.SetName("system.psi.io.full.total")
	m.data.SetDescription("IO pressure stall information - all tasks waiting, total time in microseconds")
	m.data.SetUnit("us")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSystemPsiIoFullTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSystemPsiIoFullTotal) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSystemPsiIoFullTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSystemPsiIoFullTotal(cfg MetricConfig) metricSystemPsiIoFullTotal {
	m := metricSystemPsiIoFullTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSystemPsiIoSomeAvg10 struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills system.psi.io.some.avg10 metric with initial data.
func (m *metricSystemPsiIoSomeAvg10) init() {
	m.data.SetName("system.psi.io.some.avg10")
	m.data.SetDescription("IO pressure stall information - some tasks waiting, 10 second average")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSystemPsiIoSomeAvg10) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSystemPsiIoSomeAvg10) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSystemPsiIoSomeAvg10) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSystemPsiIoSomeAvg10(cfg MetricConfig) metricSystemPsiIoSomeAvg10 {
	m := metricSystemPsiIoSomeAvg10{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSystemPsiIoSomeAvg300 struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills system.psi.io.some.avg300 metric with initial data.
func (m *metricSystemPsiIoSomeAvg300) init() {
	m.data.SetName("system.psi.io.some.avg300")
	m.data.SetDescription("IO pressure stall information - some tasks waiting, 300 second average")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSystemPsiIoSomeAvg300) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSystemPsiIoSomeAvg300) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSystemPsiIoSomeAvg300) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSystemPsiIoSomeAvg300(cfg MetricConfig) metricSystemPsiIoSomeAvg300 {
	m := metricSystemPsiIoSomeAvg300{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSystemPsiIoSomeAvg60 struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills system.psi.io.some.avg60 metric with initial data.
func (m *metricSystemPsiIoSomeAvg60) init() {
	m.data.SetName("system.psi.io.some.avg60")
	m.data.SetDescription("IO pressure stall information - some tasks waiting, 60 second average")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSystemPsiIoSomeAvg60) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSystemPsiIoSomeAvg60) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSystemPsiIoSomeAvg60) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSystemPsiIoSomeAvg60(cfg MetricConfig) metricSystemPsiIoSomeAvg60 {
	m := metricSystemPsiIoSomeAvg60{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSystemPsiIoSomeTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills system.psi.io.some.total metric with initial data.
func (m *metricSystemPsiIoSomeTotal) init() {
	m.data.SetName("system.psi.io.some.total")
	m.data.SetDescription("IO pressure stall information - some tasks waiting, total time in microseconds")
	m.data.SetUnit("us")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSystemPsiIoSomeTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSystemPsiIoSomeTotal) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSystemPsiIoSomeTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSystemPsiIoSomeTotal(cfg MetricConfig) metricSystemPsiIoSomeTotal {
	m := metricSystemPsiIoSomeTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSystemPsiMemoryFullAvg10 struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills system.psi.memory.full.avg10 metric with initial data.
func (m *metricSystemPsiMemoryFullAvg10) init() {
	m.data.SetName("system.psi.memory.full.avg10")
	m.data.SetDescription("Memory pressure stall information - all tasks waiting, 10 second average")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSystemPsiMemoryFullAvg10) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSystemPsiMemoryFullAvg10) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSystemPsiMemoryFullAvg10) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSystemPsiMemoryFullAvg10(cfg MetricConfig) metricSystemPsiMemoryFullAvg10 {
	m := metricSystemPsiMemoryFullAvg10{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSystemPsiMemoryFullAvg300 struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills system.psi.memory.full.avg300 metric with initial data.
func (m *metricSystemPsiMemoryFullAvg300) init() {
	m.data.SetName("system.psi.memory.full.avg300")
	m.data.SetDescription("Memory pressure stall information - all tasks waiting, 300 second average")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSystemPsiMemoryFullAvg300) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSystemPsiMemoryFullAvg300) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSystemPsiMemoryFullAvg300) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSystemPsiMemoryFullAvg300(cfg MetricConfig) metricSystemPsiMemoryFullAvg300 {
	m := metricSystemPsiMemoryFullAvg300{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSystemPsiMemoryFullAvg60 struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills system.psi.memory.full.avg60 metric with initial data.
func (m *metricSystemPsiMemoryFullAvg60) init() {
	m.data.SetName("system.psi.memory.full.avg60")
	m.data.SetDescription("Memory pressure stall information - all tasks waiting, 60 second average")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSystemPsiMemoryFullAvg60) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSystemPsiMemoryFullAvg60) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSystemPsiMemoryFullAvg60) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSystemPsiMemoryFullAvg60(cfg MetricConfig) metricSystemPsiMemoryFullAvg60 {
	m := metricSystemPsiMemoryFullAvg60{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSystemPsiMemoryFullTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills system.psi.memory.full.total metric with initial data.
func (m *metricSystemPsiMemoryFullTotal) init() {
	m.data.SetName("system.psi.memory.full.total")
	m.data.SetDescription("Memory pressure stall information - all tasks waiting, total time in microseconds")
	m.data.SetUnit("us")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSystemPsiMemoryFullTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSystemPsiMemoryFullTotal) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSystemPsiMemoryFullTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSystemPsiMemoryFullTotal(cfg MetricConfig) metricSystemPsiMemoryFullTotal {
	m := metricSystemPsiMemoryFullTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSystemPsiMemorySomeAvg10 struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills system.psi.memory.some.avg10 metric with initial data.
func (m *metricSystemPsiMemorySomeAvg10) init() {
	m.data.SetName("system.psi.memory.some.avg10")
	m.data.SetDescription("Memory pressure stall information - some tasks waiting, 10 second average")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSystemPsiMemorySomeAvg10) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSystemPsiMemorySomeAvg10) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSystemPsiMemorySomeAvg10) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSystemPsiMemorySomeAvg10(cfg MetricConfig) metricSystemPsiMemorySomeAvg10 {
	m := metricSystemPsiMemorySomeAvg10{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSystemPsiMemorySomeAvg300 struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills system.psi.memory.some.avg300 metric with initial data.
func (m *metricSystemPsiMemorySomeAvg300) init() {
	m.data.SetName("system.psi.memory.some.avg300")
	m.data.SetDescription("Memory pressure stall information - some tasks waiting, 300 second average")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSystemPsiMemorySomeAvg300) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSystemPsiMemorySomeAvg300) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSystemPsiMemorySomeAvg300) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSystemPsiMemorySomeAvg300(cfg MetricConfig) metricSystemPsiMemorySomeAvg300 {
	m := metricSystemPsiMemorySomeAvg300{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSystemPsiMemorySomeAvg60 struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills system.psi.memory.some.avg60 metric with initial data.
func (m *metricSystemPsiMemorySomeAvg60) init() {
	m.data.SetName("system.psi.memory.some.avg60")
	m.data.SetDescription("Memory pressure stall information - some tasks waiting, 60 second average")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSystemPsiMemorySomeAvg60) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSystemPsiMemorySomeAvg60) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSystemPsiMemorySomeAvg60) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSystemPsiMemorySomeAvg60(cfg MetricConfig) metricSystemPsiMemorySomeAvg60 {
	m := metricSystemPsiMemorySomeAvg60{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSystemPsiMemorySomeTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills system.psi.memory.some.total metric with initial data.
func (m *metricSystemPsiMemorySomeTotal) init() {
	m.data.SetName("system.psi.memory.some.total")
	m.data.SetDescription("Memory pressure stall information - some tasks waiting, total time in microseconds")
	m.data.SetUnit("us")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSystemPsiMemorySomeTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSystemPsiMemorySomeTotal) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSystemPsiMemorySomeTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSystemPsiMemorySomeTotal(cfg MetricConfig) metricSystemPsiMemorySomeTotal {
	m := metricSystemPsiMemorySomeTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user config.
type MetricsBuilder struct {
	config                          MetricsBuilderConfig // config of the metrics builder.
	startTime                       pcommon.Timestamp    // start time that will be applied to all recorded data points.
	metricsCapacity                 int                  // maximum observed number of metrics per resource.
	metricsBuffer                   pmetric.Metrics      // accumulates metrics data before emitting.
	buildInfo                       component.BuildInfo  // contains version information.
	metricSystemPsiCPUSomeAvg10     metricSystemPsiCPUSomeAvg10
	metricSystemPsiCPUSomeAvg300    metricSystemPsiCPUSomeAvg300
	metricSystemPsiCPUSomeAvg60     metricSystemPsiCPUSomeAvg60
	metricSystemPsiCPUSomeTotal     metricSystemPsiCPUSomeTotal
	metricSystemPsiIoFullAvg10      metricSystemPsiIoFullAvg10
	metricSystemPsiIoFullAvg300     metricSystemPsiIoFullAvg300
	metricSystemPsiIoFullAvg60      metricSystemPsiIoFullAvg60
	metricSystemPsiIoFullTotal      metricSystemPsiIoFullTotal
	metricSystemPsiIoSomeAvg10      metricSystemPsiIoSomeAvg10
	metricSystemPsiIoSomeAvg300     metricSystemPsiIoSomeAvg300
	metricSystemPsiIoSomeAvg60      metricSystemPsiIoSomeAvg60
	metricSystemPsiIoSomeTotal      metricSystemPsiIoSomeTotal
	metricSystemPsiMemoryFullAvg10  metricSystemPsiMemoryFullAvg10
	metricSystemPsiMemoryFullAvg300 metricSystemPsiMemoryFullAvg300
	metricSystemPsiMemoryFullAvg60  metricSystemPsiMemoryFullAvg60
	metricSystemPsiMemoryFullTotal  metricSystemPsiMemoryFullTotal
	metricSystemPsiMemorySomeAvg10  metricSystemPsiMemorySomeAvg10
	metricSystemPsiMemorySomeAvg300 metricSystemPsiMemorySomeAvg300
	metricSystemPsiMemorySomeAvg60  metricSystemPsiMemorySomeAvg60
	metricSystemPsiMemorySomeTotal  metricSystemPsiMemorySomeTotal
}

// MetricBuilderOption applies changes to default metrics builder.
type MetricBuilderOption interface {
	apply(*MetricsBuilder)
}

type metricBuilderOptionFunc func(mb *MetricsBuilder)

func (mbof metricBuilderOptionFunc) apply(mb *MetricsBuilder) {
	mbof(mb)
}

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) MetricBuilderOption {
	return metricBuilderOptionFunc(func(mb *MetricsBuilder) {
		mb.startTime = startTime
	})
}
func NewMetricsBuilder(mbc MetricsBuilderConfig, settings scraper.Settings, options ...MetricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		config:                          mbc,
		startTime:                       pcommon.NewTimestampFromTime(time.Now()),
		metricsBuffer:                   pmetric.NewMetrics(),
		buildInfo:                       settings.BuildInfo,
		metricSystemPsiCPUSomeAvg10:     newMetricSystemPsiCPUSomeAvg10(mbc.Metrics.SystemPsiCPUSomeAvg10),
		metricSystemPsiCPUSomeAvg300:    newMetricSystemPsiCPUSomeAvg300(mbc.Metrics.SystemPsiCPUSomeAvg300),
		metricSystemPsiCPUSomeAvg60:     newMetricSystemPsiCPUSomeAvg60(mbc.Metrics.SystemPsiCPUSomeAvg60),
		metricSystemPsiCPUSomeTotal:     newMetricSystemPsiCPUSomeTotal(mbc.Metrics.SystemPsiCPUSomeTotal),
		metricSystemPsiIoFullAvg10:      newMetricSystemPsiIoFullAvg10(mbc.Metrics.SystemPsiIoFullAvg10),
		metricSystemPsiIoFullAvg300:     newMetricSystemPsiIoFullAvg300(mbc.Metrics.SystemPsiIoFullAvg300),
		metricSystemPsiIoFullAvg60:      newMetricSystemPsiIoFullAvg60(mbc.Metrics.SystemPsiIoFullAvg60),
		metricSystemPsiIoFullTotal:      newMetricSystemPsiIoFullTotal(mbc.Metrics.SystemPsiIoFullTotal),
		metricSystemPsiIoSomeAvg10:      newMetricSystemPsiIoSomeAvg10(mbc.Metrics.SystemPsiIoSomeAvg10),
		metricSystemPsiIoSomeAvg300:     newMetricSystemPsiIoSomeAvg300(mbc.Metrics.SystemPsiIoSomeAvg300),
		metricSystemPsiIoSomeAvg60:      newMetricSystemPsiIoSomeAvg60(mbc.Metrics.SystemPsiIoSomeAvg60),
		metricSystemPsiIoSomeTotal:      newMetricSystemPsiIoSomeTotal(mbc.Metrics.SystemPsiIoSomeTotal),
		metricSystemPsiMemoryFullAvg10:  newMetricSystemPsiMemoryFullAvg10(mbc.Metrics.SystemPsiMemoryFullAvg10),
		metricSystemPsiMemoryFullAvg300: newMetricSystemPsiMemoryFullAvg300(mbc.Metrics.SystemPsiMemoryFullAvg300),
		metricSystemPsiMemoryFullAvg60:  newMetricSystemPsiMemoryFullAvg60(mbc.Metrics.SystemPsiMemoryFullAvg60),
		metricSystemPsiMemoryFullTotal:  newMetricSystemPsiMemoryFullTotal(mbc.Metrics.SystemPsiMemoryFullTotal),
		metricSystemPsiMemorySomeAvg10:  newMetricSystemPsiMemorySomeAvg10(mbc.Metrics.SystemPsiMemorySomeAvg10),
		metricSystemPsiMemorySomeAvg300: newMetricSystemPsiMemorySomeAvg300(mbc.Metrics.SystemPsiMemorySomeAvg300),
		metricSystemPsiMemorySomeAvg60:  newMetricSystemPsiMemorySomeAvg60(mbc.Metrics.SystemPsiMemorySomeAvg60),
		metricSystemPsiMemorySomeTotal:  newMetricSystemPsiMemorySomeTotal(mbc.Metrics.SystemPsiMemorySomeTotal),
	}

	for _, op := range options {
		op.apply(mb)
	}
	return mb
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (mb *MetricsBuilder) updateCapacity(rm pmetric.ResourceMetrics) {
	if mb.metricsCapacity < rm.ScopeMetrics().At(0).Metrics().Len() {
		mb.metricsCapacity = rm.ScopeMetrics().At(0).Metrics().Len()
	}
}

// ResourceMetricsOption applies changes to provided resource metrics.
type ResourceMetricsOption interface {
	apply(pmetric.ResourceMetrics)
}

type resourceMetricsOptionFunc func(pmetric.ResourceMetrics)

func (rmof resourceMetricsOptionFunc) apply(rm pmetric.ResourceMetrics) {
	rmof(rm)
}

// WithResource sets the provided resource on the emitted ResourceMetrics.
// It's recommended to use ResourceBuilder to create the resource.
func WithResource(res pcommon.Resource) ResourceMetricsOption {
	return resourceMetricsOptionFunc(func(rm pmetric.ResourceMetrics) {
		res.CopyTo(rm.Resource())
	})
}

// WithStartTimeOverride overrides start time for all the resource metrics data points.
// This option should be only used if different start time has to be set on metrics coming from different resources.
func WithStartTimeOverride(start pcommon.Timestamp) ResourceMetricsOption {
	return resourceMetricsOptionFunc(func(rm pmetric.ResourceMetrics) {
		var dps pmetric.NumberDataPointSlice
		metrics := rm.ScopeMetrics().At(0).Metrics()
		for i := 0; i < metrics.Len(); i++ {
			switch metrics.At(i).Type() {
			case pmetric.MetricTypeGauge:
				dps = metrics.At(i).Gauge().DataPoints()
			case pmetric.MetricTypeSum:
				dps = metrics.At(i).Sum().DataPoints()
			}
			for j := 0; j < dps.Len(); j++ {
				dps.At(j).SetStartTimestamp(start)
			}
		}
	})
}

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead.
// Resource attributes should be provided as ResourceMetricsOption arguments.
func (mb *MetricsBuilder) EmitForResource(options ...ResourceMetricsOption) {
	rm := pmetric.NewResourceMetrics()
	rm.SetSchemaUrl(conventions.SchemaURL)
	ils := rm.ScopeMetrics().AppendEmpty()
	ils.Scope().SetName(ScopeName)
	ils.Scope().SetVersion(mb.buildInfo.Version)
	ils.Metrics().EnsureCapacity(mb.metricsCapacity)
	mb.metricSystemPsiCPUSomeAvg10.emit(ils.Metrics())
	mb.metricSystemPsiCPUSomeAvg300.emit(ils.Metrics())
	mb.metricSystemPsiCPUSomeAvg60.emit(ils.Metrics())
	mb.metricSystemPsiCPUSomeTotal.emit(ils.Metrics())
	mb.metricSystemPsiIoFullAvg10.emit(ils.Metrics())
	mb.metricSystemPsiIoFullAvg300.emit(ils.Metrics())
	mb.metricSystemPsiIoFullAvg60.emit(ils.Metrics())
	mb.metricSystemPsiIoFullTotal.emit(ils.Metrics())
	mb.metricSystemPsiIoSomeAvg10.emit(ils.Metrics())
	mb.metricSystemPsiIoSomeAvg300.emit(ils.Metrics())
	mb.metricSystemPsiIoSomeAvg60.emit(ils.Metrics())
	mb.metricSystemPsiIoSomeTotal.emit(ils.Metrics())
	mb.metricSystemPsiMemoryFullAvg10.emit(ils.Metrics())
	mb.metricSystemPsiMemoryFullAvg300.emit(ils.Metrics())
	mb.metricSystemPsiMemoryFullAvg60.emit(ils.Metrics())
	mb.metricSystemPsiMemoryFullTotal.emit(ils.Metrics())
	mb.metricSystemPsiMemorySomeAvg10.emit(ils.Metrics())
	mb.metricSystemPsiMemorySomeAvg300.emit(ils.Metrics())
	mb.metricSystemPsiMemorySomeAvg60.emit(ils.Metrics())
	mb.metricSystemPsiMemorySomeTotal.emit(ils.Metrics())

	for _, op := range options {
		op.apply(rm)
	}

	if ils.Metrics().Len() > 0 {
		mb.updateCapacity(rm)
		rm.MoveTo(mb.metricsBuffer.ResourceMetrics().AppendEmpty())
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user config, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit(options ...ResourceMetricsOption) pmetric.Metrics {
	mb.EmitForResource(options...)
	metrics := mb.metricsBuffer
	mb.metricsBuffer = pmetric.NewMetrics()
	return metrics
}

// RecordSystemPsiCPUSomeAvg10DataPoint adds a data point to system.psi.cpu.some.avg10 metric.
func (mb *MetricsBuilder) RecordSystemPsiCPUSomeAvg10DataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSystemPsiCPUSomeAvg10.recordDataPoint(mb.startTime, ts, val)
}

// RecordSystemPsiCPUSomeAvg300DataPoint adds a data point to system.psi.cpu.some.avg300 metric.
func (mb *MetricsBuilder) RecordSystemPsiCPUSomeAvg300DataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSystemPsiCPUSomeAvg300.recordDataPoint(mb.startTime, ts, val)
}

// RecordSystemPsiCPUSomeAvg60DataPoint adds a data point to system.psi.cpu.some.avg60 metric.
func (mb *MetricsBuilder) RecordSystemPsiCPUSomeAvg60DataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSystemPsiCPUSomeAvg60.recordDataPoint(mb.startTime, ts, val)
}

// RecordSystemPsiCPUSomeTotalDataPoint adds a data point to system.psi.cpu.some.total metric.
func (mb *MetricsBuilder) RecordSystemPsiCPUSomeTotalDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSystemPsiCPUSomeTotal.recordDataPoint(mb.startTime, ts, val)
}

// RecordSystemPsiIoFullAvg10DataPoint adds a data point to system.psi.io.full.avg10 metric.
func (mb *MetricsBuilder) RecordSystemPsiIoFullAvg10DataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSystemPsiIoFullAvg10.recordDataPoint(mb.startTime, ts, val)
}

// RecordSystemPsiIoFullAvg300DataPoint adds a data point to system.psi.io.full.avg300 metric.
func (mb *MetricsBuilder) RecordSystemPsiIoFullAvg300DataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSystemPsiIoFullAvg300.recordDataPoint(mb.startTime, ts, val)
}

// RecordSystemPsiIoFullAvg60DataPoint adds a data point to system.psi.io.full.avg60 metric.
func (mb *MetricsBuilder) RecordSystemPsiIoFullAvg60DataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSystemPsiIoFullAvg60.recordDataPoint(mb.startTime, ts, val)
}

// RecordSystemPsiIoFullTotalDataPoint adds a data point to system.psi.io.full.total metric.
func (mb *MetricsBuilder) RecordSystemPsiIoFullTotalDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSystemPsiIoFullTotal.recordDataPoint(mb.startTime, ts, val)
}

// RecordSystemPsiIoSomeAvg10DataPoint adds a data point to system.psi.io.some.avg10 metric.
func (mb *MetricsBuilder) RecordSystemPsiIoSomeAvg10DataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSystemPsiIoSomeAvg10.recordDataPoint(mb.startTime, ts, val)
}

// RecordSystemPsiIoSomeAvg300DataPoint adds a data point to system.psi.io.some.avg300 metric.
func (mb *MetricsBuilder) RecordSystemPsiIoSomeAvg300DataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSystemPsiIoSomeAvg300.recordDataPoint(mb.startTime, ts, val)
}

// RecordSystemPsiIoSomeAvg60DataPoint adds a data point to system.psi.io.some.avg60 metric.
func (mb *MetricsBuilder) RecordSystemPsiIoSomeAvg60DataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSystemPsiIoSomeAvg60.recordDataPoint(mb.startTime, ts, val)
}

// RecordSystemPsiIoSomeTotalDataPoint adds a data point to system.psi.io.some.total metric.
func (mb *MetricsBuilder) RecordSystemPsiIoSomeTotalDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSystemPsiIoSomeTotal.recordDataPoint(mb.startTime, ts, val)
}

// RecordSystemPsiMemoryFullAvg10DataPoint adds a data point to system.psi.memory.full.avg10 metric.
func (mb *MetricsBuilder) RecordSystemPsiMemoryFullAvg10DataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSystemPsiMemoryFullAvg10.recordDataPoint(mb.startTime, ts, val)
}

// RecordSystemPsiMemoryFullAvg300DataPoint adds a data point to system.psi.memory.full.avg300 metric.
func (mb *MetricsBuilder) RecordSystemPsiMemoryFullAvg300DataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSystemPsiMemoryFullAvg300.recordDataPoint(mb.startTime, ts, val)
}

// RecordSystemPsiMemoryFullAvg60DataPoint adds a data point to system.psi.memory.full.avg60 metric.
func (mb *MetricsBuilder) RecordSystemPsiMemoryFullAvg60DataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSystemPsiMemoryFullAvg60.recordDataPoint(mb.startTime, ts, val)
}

// RecordSystemPsiMemoryFullTotalDataPoint adds a data point to system.psi.memory.full.total metric.
func (mb *MetricsBuilder) RecordSystemPsiMemoryFullTotalDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSystemPsiMemoryFullTotal.recordDataPoint(mb.startTime, ts, val)
}

// RecordSystemPsiMemorySomeAvg10DataPoint adds a data point to system.psi.memory.some.avg10 metric.
func (mb *MetricsBuilder) RecordSystemPsiMemorySomeAvg10DataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSystemPsiMemorySomeAvg10.recordDataPoint(mb.startTime, ts, val)
}

// RecordSystemPsiMemorySomeAvg300DataPoint adds a data point to system.psi.memory.some.avg300 metric.
func (mb *MetricsBuilder) RecordSystemPsiMemorySomeAvg300DataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSystemPsiMemorySomeAvg300.recordDataPoint(mb.startTime, ts, val)
}

// RecordSystemPsiMemorySomeAvg60DataPoint adds a data point to system.psi.memory.some.avg60 metric.
func (mb *MetricsBuilder) RecordSystemPsiMemorySomeAvg60DataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSystemPsiMemorySomeAvg60.recordDataPoint(mb.startTime, ts, val)
}

// RecordSystemPsiMemorySomeTotalDataPoint adds a data point to system.psi.memory.some.total metric.
func (mb *MetricsBuilder) RecordSystemPsiMemorySomeTotalDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSystemPsiMemorySomeTotal.recordDataPoint(mb.startTime, ts, val)
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...MetricBuilderOption) {
	mb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op.apply(mb)
	}
}
