// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
	"go.opentelemetry.io/collector/receiver"
)

var MetricsInfo = metricsInfo{
	CiscoBgpSessionMessagesInputCount: metricInfo{
		Name: "cisco_bgp_session_messages_input_count",
	},
	CiscoBgpSessionMessagesOutputCount: metricInfo{
		Name: "cisco_bgp_session_messages_output_count",
	},
	CiscoBgpSessionPrefixesReceivedCount: metricInfo{
		Name: "cisco_bgp_session_prefixes_received_count",
	},
	CiscoBgpSessionUp: metricInfo{
		Name: "cisco_bgp_session_up",
	},
	CiscoCollectDurationSeconds: metricInfo{
		Name: "cisco_collect_duration_seconds",
	},
	CiscoCollectorDurationSeconds: metricInfo{
		Name: "cisco_collector_duration_seconds",
	},
	CiscoEnvironmentPowerUp: metricInfo{
		Name: "cisco_environment_power_up",
	},
	CiscoEnvironmentSensorTemp: metricInfo{
		Name: "cisco_environment_sensor_temp",
	},
	CiscoFactsCPUFiveMinutesPercent: metricInfo{
		Name: "cisco_facts_cpu_five_minutes_percent",
	},
	CiscoFactsCPUFiveSecondsPercent: metricInfo{
		Name: "cisco_facts_cpu_five_seconds_percent",
	},
	CiscoFactsCPUInterruptPercent: metricInfo{
		Name: "cisco_facts_cpu_interrupt_percent",
	},
	CiscoFactsCPUOneMinutePercent: metricInfo{
		Name: "cisco_facts_cpu_one_minute_percent",
	},
	CiscoFactsMemoryFree: metricInfo{
		Name: "cisco_facts_memory_free",
	},
	CiscoFactsMemoryTotal: metricInfo{
		Name: "cisco_facts_memory_total",
	},
	CiscoFactsMemoryUsed: metricInfo{
		Name: "cisco_facts_memory_used",
	},
	CiscoFactsVersion: metricInfo{
		Name: "cisco_facts_version",
	},
	CiscoInterfaceAdminUp: metricInfo{
		Name: "cisco_interface_admin_up",
	},
	CiscoInterfaceErrorStatus: metricInfo{
		Name: "cisco_interface_error_status",
	},
	CiscoInterfaceReceiveBroadcast: metricInfo{
		Name: "cisco_interface_receive_broadcast",
	},
	CiscoInterfaceReceiveBytes: metricInfo{
		Name: "cisco_interface_receive_bytes",
	},
	CiscoInterfaceReceiveDrops: metricInfo{
		Name: "cisco_interface_receive_drops",
	},
	CiscoInterfaceReceiveErrors: metricInfo{
		Name: "cisco_interface_receive_errors",
	},
	CiscoInterfaceReceiveMulticast: metricInfo{
		Name: "cisco_interface_receive_multicast",
	},
	CiscoInterfaceTransmitBytes: metricInfo{
		Name: "cisco_interface_transmit_bytes",
	},
	CiscoInterfaceTransmitDrops: metricInfo{
		Name: "cisco_interface_transmit_drops",
	},
	CiscoInterfaceTransmitErrors: metricInfo{
		Name: "cisco_interface_transmit_errors",
	},
	CiscoInterfaceUp: metricInfo{
		Name: "cisco_interface_up",
	},
	CiscoOpticsRx: metricInfo{
		Name: "cisco_optics_rx",
	},
	CiscoOpticsTx: metricInfo{
		Name: "cisco_optics_tx",
	},
	CiscoUp: metricInfo{
		Name: "cisco_up",
	},
}

type metricsInfo struct {
	CiscoBgpSessionMessagesInputCount    metricInfo
	CiscoBgpSessionMessagesOutputCount   metricInfo
	CiscoBgpSessionPrefixesReceivedCount metricInfo
	CiscoBgpSessionUp                    metricInfo
	CiscoCollectDurationSeconds          metricInfo
	CiscoCollectorDurationSeconds        metricInfo
	CiscoEnvironmentPowerUp              metricInfo
	CiscoEnvironmentSensorTemp           metricInfo
	CiscoFactsCPUFiveMinutesPercent      metricInfo
	CiscoFactsCPUFiveSecondsPercent      metricInfo
	CiscoFactsCPUInterruptPercent        metricInfo
	CiscoFactsCPUOneMinutePercent        metricInfo
	CiscoFactsMemoryFree                 metricInfo
	CiscoFactsMemoryTotal                metricInfo
	CiscoFactsMemoryUsed                 metricInfo
	CiscoFactsVersion                    metricInfo
	CiscoInterfaceAdminUp                metricInfo
	CiscoInterfaceErrorStatus            metricInfo
	CiscoInterfaceReceiveBroadcast       metricInfo
	CiscoInterfaceReceiveBytes           metricInfo
	CiscoInterfaceReceiveDrops           metricInfo
	CiscoInterfaceReceiveErrors          metricInfo
	CiscoInterfaceReceiveMulticast       metricInfo
	CiscoInterfaceTransmitBytes          metricInfo
	CiscoInterfaceTransmitDrops          metricInfo
	CiscoInterfaceTransmitErrors         metricInfo
	CiscoInterfaceUp                     metricInfo
	CiscoOpticsRx                        metricInfo
	CiscoOpticsTx                        metricInfo
	CiscoUp                              metricInfo
}

type metricInfo struct {
	Name string
}

type metricCiscoBgpSessionMessagesInputCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills cisco_bgp_session_messages_input_count metric with initial data.
func (m *metricCiscoBgpSessionMessagesInputCount) init() {
	m.data.SetName("cisco_bgp_session_messages_input_count")
	m.data.SetDescription("Number of received BGP messages")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricCiscoBgpSessionMessagesInputCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, targetAttributeValue string, asnAttributeValue string, ipAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("target", targetAttributeValue)
	dp.Attributes().PutStr("asn", asnAttributeValue)
	dp.Attributes().PutStr("ip", ipAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCiscoBgpSessionMessagesInputCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCiscoBgpSessionMessagesInputCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCiscoBgpSessionMessagesInputCount(cfg MetricConfig) metricCiscoBgpSessionMessagesInputCount {
	m := metricCiscoBgpSessionMessagesInputCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCiscoBgpSessionMessagesOutputCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills cisco_bgp_session_messages_output_count metric with initial data.
func (m *metricCiscoBgpSessionMessagesOutputCount) init() {
	m.data.SetName("cisco_bgp_session_messages_output_count")
	m.data.SetDescription("Number of transmitted BGP messages")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricCiscoBgpSessionMessagesOutputCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, targetAttributeValue string, asnAttributeValue string, ipAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("target", targetAttributeValue)
	dp.Attributes().PutStr("asn", asnAttributeValue)
	dp.Attributes().PutStr("ip", ipAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCiscoBgpSessionMessagesOutputCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCiscoBgpSessionMessagesOutputCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCiscoBgpSessionMessagesOutputCount(cfg MetricConfig) metricCiscoBgpSessionMessagesOutputCount {
	m := metricCiscoBgpSessionMessagesOutputCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCiscoBgpSessionPrefixesReceivedCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills cisco_bgp_session_prefixes_received_count metric with initial data.
func (m *metricCiscoBgpSessionPrefixesReceivedCount) init() {
	m.data.SetName("cisco_bgp_session_prefixes_received_count")
	m.data.SetDescription("Number of received BGP prefixes")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricCiscoBgpSessionPrefixesReceivedCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, targetAttributeValue string, asnAttributeValue string, ipAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("target", targetAttributeValue)
	dp.Attributes().PutStr("asn", asnAttributeValue)
	dp.Attributes().PutStr("ip", ipAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCiscoBgpSessionPrefixesReceivedCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCiscoBgpSessionPrefixesReceivedCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCiscoBgpSessionPrefixesReceivedCount(cfg MetricConfig) metricCiscoBgpSessionPrefixesReceivedCount {
	m := metricCiscoBgpSessionPrefixesReceivedCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCiscoBgpSessionUp struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills cisco_bgp_session_up metric with initial data.
func (m *metricCiscoBgpSessionUp) init() {
	m.data.SetName("cisco_bgp_session_up")
	m.data.SetDescription("BGP session establishment status (1=up, 0=down)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricCiscoBgpSessionUp) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, targetAttributeValue string, asnAttributeValue string, ipAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("target", targetAttributeValue)
	dp.Attributes().PutStr("asn", asnAttributeValue)
	dp.Attributes().PutStr("ip", ipAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCiscoBgpSessionUp) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCiscoBgpSessionUp) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCiscoBgpSessionUp(cfg MetricConfig) metricCiscoBgpSessionUp {
	m := metricCiscoBgpSessionUp{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCiscoCollectDurationSeconds struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills cisco_collect_duration_seconds metric with initial data.
func (m *metricCiscoCollectDurationSeconds) init() {
	m.data.SetName("cisco_collect_duration_seconds")
	m.data.SetDescription("Individual collector performance timing")
	m.data.SetUnit("s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricCiscoCollectDurationSeconds) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, targetAttributeValue string, collectorAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("target", targetAttributeValue)
	dp.Attributes().PutStr("collector", collectorAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCiscoCollectDurationSeconds) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCiscoCollectDurationSeconds) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCiscoCollectDurationSeconds(cfg MetricConfig) metricCiscoCollectDurationSeconds {
	m := metricCiscoCollectDurationSeconds{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCiscoCollectorDurationSeconds struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills cisco_collector_duration_seconds metric with initial data.
func (m *metricCiscoCollectorDurationSeconds) init() {
	m.data.SetName("cisco_collector_duration_seconds")
	m.data.SetDescription("Total scrape duration per device")
	m.data.SetUnit("s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricCiscoCollectorDurationSeconds) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, targetAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("target", targetAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCiscoCollectorDurationSeconds) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCiscoCollectorDurationSeconds) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCiscoCollectorDurationSeconds(cfg MetricConfig) metricCiscoCollectorDurationSeconds {
	m := metricCiscoCollectorDurationSeconds{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCiscoEnvironmentPowerUp struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills cisco_environment_power_up metric with initial data.
func (m *metricCiscoEnvironmentPowerUp) init() {
	m.data.SetName("cisco_environment_power_up")
	m.data.SetDescription("Power supply operational status (1=up, 0=down)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricCiscoEnvironmentPowerUp) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, targetAttributeValue string, itemAttributeValue string, statusAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("target", targetAttributeValue)
	dp.Attributes().PutStr("item", itemAttributeValue)
	dp.Attributes().PutStr("status", statusAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCiscoEnvironmentPowerUp) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCiscoEnvironmentPowerUp) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCiscoEnvironmentPowerUp(cfg MetricConfig) metricCiscoEnvironmentPowerUp {
	m := metricCiscoEnvironmentPowerUp{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCiscoEnvironmentSensorTemp struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills cisco_environment_sensor_temp metric with initial data.
func (m *metricCiscoEnvironmentSensorTemp) init() {
	m.data.SetName("cisco_environment_sensor_temp")
	m.data.SetDescription("Environment sensor temperature reading")
	m.data.SetUnit("Cel")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricCiscoEnvironmentSensorTemp) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, targetAttributeValue string, itemAttributeValue string, statusAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("target", targetAttributeValue)
	dp.Attributes().PutStr("item", itemAttributeValue)
	dp.Attributes().PutStr("status", statusAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCiscoEnvironmentSensorTemp) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCiscoEnvironmentSensorTemp) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCiscoEnvironmentSensorTemp(cfg MetricConfig) metricCiscoEnvironmentSensorTemp {
	m := metricCiscoEnvironmentSensorTemp{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCiscoFactsCPUFiveMinutesPercent struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills cisco_facts_cpu_five_minutes_percent metric with initial data.
func (m *metricCiscoFactsCPUFiveMinutesPercent) init() {
	m.data.SetName("cisco_facts_cpu_five_minutes_percent")
	m.data.SetDescription("CPU utilization for five minutes")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricCiscoFactsCPUFiveMinutesPercent) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, targetAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("target", targetAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCiscoFactsCPUFiveMinutesPercent) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCiscoFactsCPUFiveMinutesPercent) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCiscoFactsCPUFiveMinutesPercent(cfg MetricConfig) metricCiscoFactsCPUFiveMinutesPercent {
	m := metricCiscoFactsCPUFiveMinutesPercent{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCiscoFactsCPUFiveSecondsPercent struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills cisco_facts_cpu_five_seconds_percent metric with initial data.
func (m *metricCiscoFactsCPUFiveSecondsPercent) init() {
	m.data.SetName("cisco_facts_cpu_five_seconds_percent")
	m.data.SetDescription("CPU utilization for five seconds")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricCiscoFactsCPUFiveSecondsPercent) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, targetAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("target", targetAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCiscoFactsCPUFiveSecondsPercent) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCiscoFactsCPUFiveSecondsPercent) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCiscoFactsCPUFiveSecondsPercent(cfg MetricConfig) metricCiscoFactsCPUFiveSecondsPercent {
	m := metricCiscoFactsCPUFiveSecondsPercent{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCiscoFactsCPUInterruptPercent struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills cisco_facts_cpu_interrupt_percent metric with initial data.
func (m *metricCiscoFactsCPUInterruptPercent) init() {
	m.data.SetName("cisco_facts_cpu_interrupt_percent")
	m.data.SetDescription("Interrupt percentage")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricCiscoFactsCPUInterruptPercent) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, targetAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("target", targetAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCiscoFactsCPUInterruptPercent) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCiscoFactsCPUInterruptPercent) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCiscoFactsCPUInterruptPercent(cfg MetricConfig) metricCiscoFactsCPUInterruptPercent {
	m := metricCiscoFactsCPUInterruptPercent{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCiscoFactsCPUOneMinutePercent struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills cisco_facts_cpu_one_minute_percent metric with initial data.
func (m *metricCiscoFactsCPUOneMinutePercent) init() {
	m.data.SetName("cisco_facts_cpu_one_minute_percent")
	m.data.SetDescription("CPU utilization for one minute")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricCiscoFactsCPUOneMinutePercent) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, targetAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("target", targetAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCiscoFactsCPUOneMinutePercent) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCiscoFactsCPUOneMinutePercent) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCiscoFactsCPUOneMinutePercent(cfg MetricConfig) metricCiscoFactsCPUOneMinutePercent {
	m := metricCiscoFactsCPUOneMinutePercent{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCiscoFactsMemoryFree struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills cisco_facts_memory_free metric with initial data.
func (m *metricCiscoFactsMemoryFree) init() {
	m.data.SetName("cisco_facts_memory_free")
	m.data.SetDescription("Free memory in bytes")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricCiscoFactsMemoryFree) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, targetAttributeValue string, typeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("target", targetAttributeValue)
	dp.Attributes().PutStr("type", typeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCiscoFactsMemoryFree) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCiscoFactsMemoryFree) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCiscoFactsMemoryFree(cfg MetricConfig) metricCiscoFactsMemoryFree {
	m := metricCiscoFactsMemoryFree{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCiscoFactsMemoryTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills cisco_facts_memory_total metric with initial data.
func (m *metricCiscoFactsMemoryTotal) init() {
	m.data.SetName("cisco_facts_memory_total")
	m.data.SetDescription("Total memory in bytes")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricCiscoFactsMemoryTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, targetAttributeValue string, typeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("target", targetAttributeValue)
	dp.Attributes().PutStr("type", typeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCiscoFactsMemoryTotal) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCiscoFactsMemoryTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCiscoFactsMemoryTotal(cfg MetricConfig) metricCiscoFactsMemoryTotal {
	m := metricCiscoFactsMemoryTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCiscoFactsMemoryUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills cisco_facts_memory_used metric with initial data.
func (m *metricCiscoFactsMemoryUsed) init() {
	m.data.SetName("cisco_facts_memory_used")
	m.data.SetDescription("Used memory in bytes")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricCiscoFactsMemoryUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, targetAttributeValue string, typeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("target", targetAttributeValue)
	dp.Attributes().PutStr("type", typeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCiscoFactsMemoryUsed) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCiscoFactsMemoryUsed) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCiscoFactsMemoryUsed(cfg MetricConfig) metricCiscoFactsMemoryUsed {
	m := metricCiscoFactsMemoryUsed{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCiscoFactsVersion struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills cisco_facts_version metric with initial data.
func (m *metricCiscoFactsVersion) init() {
	m.data.SetName("cisco_facts_version")
	m.data.SetDescription("Running OS version (binary indicator with version attribute)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricCiscoFactsVersion) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, targetAttributeValue string, versionAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("target", targetAttributeValue)
	dp.Attributes().PutStr("version", versionAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCiscoFactsVersion) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCiscoFactsVersion) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCiscoFactsVersion(cfg MetricConfig) metricCiscoFactsVersion {
	m := metricCiscoFactsVersion{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCiscoInterfaceAdminUp struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills cisco_interface_admin_up metric with initial data.
func (m *metricCiscoInterfaceAdminUp) init() {
	m.data.SetName("cisco_interface_admin_up")
	m.data.SetDescription("Interface admin operational status (1=up, 0=down)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricCiscoInterfaceAdminUp) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, targetAttributeValue string, nameAttributeValue string, descriptionAttributeValue string, macAttributeValue string, speedAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("target", targetAttributeValue)
	dp.Attributes().PutStr("name", nameAttributeValue)
	dp.Attributes().PutStr("description", descriptionAttributeValue)
	dp.Attributes().PutStr("mac", macAttributeValue)
	dp.Attributes().PutStr("speed", speedAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCiscoInterfaceAdminUp) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCiscoInterfaceAdminUp) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCiscoInterfaceAdminUp(cfg MetricConfig) metricCiscoInterfaceAdminUp {
	m := metricCiscoInterfaceAdminUp{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCiscoInterfaceErrorStatus struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills cisco_interface_error_status metric with initial data.
func (m *metricCiscoInterfaceErrorStatus) init() {
	m.data.SetName("cisco_interface_error_status")
	m.data.SetDescription("Admin and operational status differ (1=error, 0=no error)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricCiscoInterfaceErrorStatus) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, targetAttributeValue string, nameAttributeValue string, descriptionAttributeValue string, macAttributeValue string, speedAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("target", targetAttributeValue)
	dp.Attributes().PutStr("name", nameAttributeValue)
	dp.Attributes().PutStr("description", descriptionAttributeValue)
	dp.Attributes().PutStr("mac", macAttributeValue)
	dp.Attributes().PutStr("speed", speedAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCiscoInterfaceErrorStatus) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCiscoInterfaceErrorStatus) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCiscoInterfaceErrorStatus(cfg MetricConfig) metricCiscoInterfaceErrorStatus {
	m := metricCiscoInterfaceErrorStatus{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCiscoInterfaceReceiveBroadcast struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills cisco_interface_receive_broadcast metric with initial data.
func (m *metricCiscoInterfaceReceiveBroadcast) init() {
	m.data.SetName("cisco_interface_receive_broadcast")
	m.data.SetDescription("Received broadcast packets")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricCiscoInterfaceReceiveBroadcast) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, targetAttributeValue string, nameAttributeValue string, descriptionAttributeValue string, macAttributeValue string, speedAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("target", targetAttributeValue)
	dp.Attributes().PutStr("name", nameAttributeValue)
	dp.Attributes().PutStr("description", descriptionAttributeValue)
	dp.Attributes().PutStr("mac", macAttributeValue)
	dp.Attributes().PutStr("speed", speedAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCiscoInterfaceReceiveBroadcast) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCiscoInterfaceReceiveBroadcast) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCiscoInterfaceReceiveBroadcast(cfg MetricConfig) metricCiscoInterfaceReceiveBroadcast {
	m := metricCiscoInterfaceReceiveBroadcast{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCiscoInterfaceReceiveBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills cisco_interface_receive_bytes metric with initial data.
func (m *metricCiscoInterfaceReceiveBytes) init() {
	m.data.SetName("cisco_interface_receive_bytes")
	m.data.SetDescription("Received data in bytes")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricCiscoInterfaceReceiveBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, targetAttributeValue string, nameAttributeValue string, descriptionAttributeValue string, macAttributeValue string, speedAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("target", targetAttributeValue)
	dp.Attributes().PutStr("name", nameAttributeValue)
	dp.Attributes().PutStr("description", descriptionAttributeValue)
	dp.Attributes().PutStr("mac", macAttributeValue)
	dp.Attributes().PutStr("speed", speedAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCiscoInterfaceReceiveBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCiscoInterfaceReceiveBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCiscoInterfaceReceiveBytes(cfg MetricConfig) metricCiscoInterfaceReceiveBytes {
	m := metricCiscoInterfaceReceiveBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCiscoInterfaceReceiveDrops struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills cisco_interface_receive_drops metric with initial data.
func (m *metricCiscoInterfaceReceiveDrops) init() {
	m.data.SetName("cisco_interface_receive_drops")
	m.data.SetDescription("Number of dropped incoming packets")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricCiscoInterfaceReceiveDrops) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, targetAttributeValue string, nameAttributeValue string, descriptionAttributeValue string, macAttributeValue string, speedAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("target", targetAttributeValue)
	dp.Attributes().PutStr("name", nameAttributeValue)
	dp.Attributes().PutStr("description", descriptionAttributeValue)
	dp.Attributes().PutStr("mac", macAttributeValue)
	dp.Attributes().PutStr("speed", speedAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCiscoInterfaceReceiveDrops) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCiscoInterfaceReceiveDrops) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCiscoInterfaceReceiveDrops(cfg MetricConfig) metricCiscoInterfaceReceiveDrops {
	m := metricCiscoInterfaceReceiveDrops{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCiscoInterfaceReceiveErrors struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills cisco_interface_receive_errors metric with initial data.
func (m *metricCiscoInterfaceReceiveErrors) init() {
	m.data.SetName("cisco_interface_receive_errors")
	m.data.SetDescription("Number of errors caused by incoming packets")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricCiscoInterfaceReceiveErrors) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, targetAttributeValue string, nameAttributeValue string, descriptionAttributeValue string, macAttributeValue string, speedAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("target", targetAttributeValue)
	dp.Attributes().PutStr("name", nameAttributeValue)
	dp.Attributes().PutStr("description", descriptionAttributeValue)
	dp.Attributes().PutStr("mac", macAttributeValue)
	dp.Attributes().PutStr("speed", speedAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCiscoInterfaceReceiveErrors) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCiscoInterfaceReceiveErrors) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCiscoInterfaceReceiveErrors(cfg MetricConfig) metricCiscoInterfaceReceiveErrors {
	m := metricCiscoInterfaceReceiveErrors{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCiscoInterfaceReceiveMulticast struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills cisco_interface_receive_multicast metric with initial data.
func (m *metricCiscoInterfaceReceiveMulticast) init() {
	m.data.SetName("cisco_interface_receive_multicast")
	m.data.SetDescription("Received multicast packets")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricCiscoInterfaceReceiveMulticast) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, targetAttributeValue string, nameAttributeValue string, descriptionAttributeValue string, macAttributeValue string, speedAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("target", targetAttributeValue)
	dp.Attributes().PutStr("name", nameAttributeValue)
	dp.Attributes().PutStr("description", descriptionAttributeValue)
	dp.Attributes().PutStr("mac", macAttributeValue)
	dp.Attributes().PutStr("speed", speedAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCiscoInterfaceReceiveMulticast) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCiscoInterfaceReceiveMulticast) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCiscoInterfaceReceiveMulticast(cfg MetricConfig) metricCiscoInterfaceReceiveMulticast {
	m := metricCiscoInterfaceReceiveMulticast{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCiscoInterfaceTransmitBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills cisco_interface_transmit_bytes metric with initial data.
func (m *metricCiscoInterfaceTransmitBytes) init() {
	m.data.SetName("cisco_interface_transmit_bytes")
	m.data.SetDescription("Transmitted data in bytes")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricCiscoInterfaceTransmitBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, targetAttributeValue string, nameAttributeValue string, descriptionAttributeValue string, macAttributeValue string, speedAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("target", targetAttributeValue)
	dp.Attributes().PutStr("name", nameAttributeValue)
	dp.Attributes().PutStr("description", descriptionAttributeValue)
	dp.Attributes().PutStr("mac", macAttributeValue)
	dp.Attributes().PutStr("speed", speedAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCiscoInterfaceTransmitBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCiscoInterfaceTransmitBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCiscoInterfaceTransmitBytes(cfg MetricConfig) metricCiscoInterfaceTransmitBytes {
	m := metricCiscoInterfaceTransmitBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCiscoInterfaceTransmitDrops struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills cisco_interface_transmit_drops metric with initial data.
func (m *metricCiscoInterfaceTransmitDrops) init() {
	m.data.SetName("cisco_interface_transmit_drops")
	m.data.SetDescription("Number of dropped outgoing packets")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricCiscoInterfaceTransmitDrops) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, targetAttributeValue string, nameAttributeValue string, descriptionAttributeValue string, macAttributeValue string, speedAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("target", targetAttributeValue)
	dp.Attributes().PutStr("name", nameAttributeValue)
	dp.Attributes().PutStr("description", descriptionAttributeValue)
	dp.Attributes().PutStr("mac", macAttributeValue)
	dp.Attributes().PutStr("speed", speedAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCiscoInterfaceTransmitDrops) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCiscoInterfaceTransmitDrops) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCiscoInterfaceTransmitDrops(cfg MetricConfig) metricCiscoInterfaceTransmitDrops {
	m := metricCiscoInterfaceTransmitDrops{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCiscoInterfaceTransmitErrors struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills cisco_interface_transmit_errors metric with initial data.
func (m *metricCiscoInterfaceTransmitErrors) init() {
	m.data.SetName("cisco_interface_transmit_errors")
	m.data.SetDescription("Number of errors caused by outgoing packets")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricCiscoInterfaceTransmitErrors) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, targetAttributeValue string, nameAttributeValue string, descriptionAttributeValue string, macAttributeValue string, speedAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("target", targetAttributeValue)
	dp.Attributes().PutStr("name", nameAttributeValue)
	dp.Attributes().PutStr("description", descriptionAttributeValue)
	dp.Attributes().PutStr("mac", macAttributeValue)
	dp.Attributes().PutStr("speed", speedAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCiscoInterfaceTransmitErrors) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCiscoInterfaceTransmitErrors) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCiscoInterfaceTransmitErrors(cfg MetricConfig) metricCiscoInterfaceTransmitErrors {
	m := metricCiscoInterfaceTransmitErrors{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCiscoInterfaceUp struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills cisco_interface_up metric with initial data.
func (m *metricCiscoInterfaceUp) init() {
	m.data.SetName("cisco_interface_up")
	m.data.SetDescription("Interface operational status (1=up, 0=down)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricCiscoInterfaceUp) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, targetAttributeValue string, nameAttributeValue string, descriptionAttributeValue string, macAttributeValue string, speedAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("target", targetAttributeValue)
	dp.Attributes().PutStr("name", nameAttributeValue)
	dp.Attributes().PutStr("description", descriptionAttributeValue)
	dp.Attributes().PutStr("mac", macAttributeValue)
	dp.Attributes().PutStr("speed", speedAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCiscoInterfaceUp) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCiscoInterfaceUp) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCiscoInterfaceUp(cfg MetricConfig) metricCiscoInterfaceUp {
	m := metricCiscoInterfaceUp{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCiscoOpticsRx struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills cisco_optics_rx metric with initial data.
func (m *metricCiscoOpticsRx) init() {
	m.data.SetName("cisco_optics_rx")
	m.data.SetDescription("Optical receive power")
	m.data.SetUnit("dBm")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricCiscoOpticsRx) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, targetAttributeValue string, interfaceAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("target", targetAttributeValue)
	dp.Attributes().PutStr("interface", interfaceAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCiscoOpticsRx) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCiscoOpticsRx) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCiscoOpticsRx(cfg MetricConfig) metricCiscoOpticsRx {
	m := metricCiscoOpticsRx{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCiscoOpticsTx struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills cisco_optics_tx metric with initial data.
func (m *metricCiscoOpticsTx) init() {
	m.data.SetName("cisco_optics_tx")
	m.data.SetDescription("Optical transmit power")
	m.data.SetUnit("dBm")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricCiscoOpticsTx) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, targetAttributeValue string, interfaceAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("target", targetAttributeValue)
	dp.Attributes().PutStr("interface", interfaceAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCiscoOpticsTx) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCiscoOpticsTx) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCiscoOpticsTx(cfg MetricConfig) metricCiscoOpticsTx {
	m := metricCiscoOpticsTx{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCiscoUp struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills cisco_up metric with initial data.
func (m *metricCiscoUp) init() {
	m.data.SetName("cisco_up")
	m.data.SetDescription("Device connectivity status (1=connected, 0=disconnected)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricCiscoUp) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, targetAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("target", targetAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCiscoUp) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCiscoUp) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCiscoUp(cfg MetricConfig) metricCiscoUp {
	m := metricCiscoUp{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user config.
type MetricsBuilder struct {
	config                                     MetricsBuilderConfig // config of the metrics builder.
	startTime                                  pcommon.Timestamp    // start time that will be applied to all recorded data points.
	metricsCapacity                            int                  // maximum observed number of metrics per resource.
	metricsBuffer                              pmetric.Metrics      // accumulates metrics data before emitting.
	buildInfo                                  component.BuildInfo  // contains version information.
	metricCiscoBgpSessionMessagesInputCount    metricCiscoBgpSessionMessagesInputCount
	metricCiscoBgpSessionMessagesOutputCount   metricCiscoBgpSessionMessagesOutputCount
	metricCiscoBgpSessionPrefixesReceivedCount metricCiscoBgpSessionPrefixesReceivedCount
	metricCiscoBgpSessionUp                    metricCiscoBgpSessionUp
	metricCiscoCollectDurationSeconds          metricCiscoCollectDurationSeconds
	metricCiscoCollectorDurationSeconds        metricCiscoCollectorDurationSeconds
	metricCiscoEnvironmentPowerUp              metricCiscoEnvironmentPowerUp
	metricCiscoEnvironmentSensorTemp           metricCiscoEnvironmentSensorTemp
	metricCiscoFactsCPUFiveMinutesPercent      metricCiscoFactsCPUFiveMinutesPercent
	metricCiscoFactsCPUFiveSecondsPercent      metricCiscoFactsCPUFiveSecondsPercent
	metricCiscoFactsCPUInterruptPercent        metricCiscoFactsCPUInterruptPercent
	metricCiscoFactsCPUOneMinutePercent        metricCiscoFactsCPUOneMinutePercent
	metricCiscoFactsMemoryFree                 metricCiscoFactsMemoryFree
	metricCiscoFactsMemoryTotal                metricCiscoFactsMemoryTotal
	metricCiscoFactsMemoryUsed                 metricCiscoFactsMemoryUsed
	metricCiscoFactsVersion                    metricCiscoFactsVersion
	metricCiscoInterfaceAdminUp                metricCiscoInterfaceAdminUp
	metricCiscoInterfaceErrorStatus            metricCiscoInterfaceErrorStatus
	metricCiscoInterfaceReceiveBroadcast       metricCiscoInterfaceReceiveBroadcast
	metricCiscoInterfaceReceiveBytes           metricCiscoInterfaceReceiveBytes
	metricCiscoInterfaceReceiveDrops           metricCiscoInterfaceReceiveDrops
	metricCiscoInterfaceReceiveErrors          metricCiscoInterfaceReceiveErrors
	metricCiscoInterfaceReceiveMulticast       metricCiscoInterfaceReceiveMulticast
	metricCiscoInterfaceTransmitBytes          metricCiscoInterfaceTransmitBytes
	metricCiscoInterfaceTransmitDrops          metricCiscoInterfaceTransmitDrops
	metricCiscoInterfaceTransmitErrors         metricCiscoInterfaceTransmitErrors
	metricCiscoInterfaceUp                     metricCiscoInterfaceUp
	metricCiscoOpticsRx                        metricCiscoOpticsRx
	metricCiscoOpticsTx                        metricCiscoOpticsTx
	metricCiscoUp                              metricCiscoUp
}

// MetricBuilderOption applies changes to default metrics builder.
type MetricBuilderOption interface {
	apply(*MetricsBuilder)
}

type metricBuilderOptionFunc func(mb *MetricsBuilder)

func (mbof metricBuilderOptionFunc) apply(mb *MetricsBuilder) {
	mbof(mb)
}

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) MetricBuilderOption {
	return metricBuilderOptionFunc(func(mb *MetricsBuilder) {
		mb.startTime = startTime
	})
}
func NewMetricsBuilder(mbc MetricsBuilderConfig, settings receiver.Settings, options ...MetricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		config:                                   mbc,
		startTime:                                pcommon.NewTimestampFromTime(time.Now()),
		metricsBuffer:                            pmetric.NewMetrics(),
		buildInfo:                                settings.BuildInfo,
		metricCiscoBgpSessionMessagesInputCount:  newMetricCiscoBgpSessionMessagesInputCount(mbc.Metrics.CiscoBgpSessionMessagesInputCount),
		metricCiscoBgpSessionMessagesOutputCount: newMetricCiscoBgpSessionMessagesOutputCount(mbc.Metrics.CiscoBgpSessionMessagesOutputCount),
		metricCiscoBgpSessionPrefixesReceivedCount: newMetricCiscoBgpSessionPrefixesReceivedCount(mbc.Metrics.CiscoBgpSessionPrefixesReceivedCount),
		metricCiscoBgpSessionUp:                    newMetricCiscoBgpSessionUp(mbc.Metrics.CiscoBgpSessionUp),
		metricCiscoCollectDurationSeconds:          newMetricCiscoCollectDurationSeconds(mbc.Metrics.CiscoCollectDurationSeconds),
		metricCiscoCollectorDurationSeconds:        newMetricCiscoCollectorDurationSeconds(mbc.Metrics.CiscoCollectorDurationSeconds),
		metricCiscoEnvironmentPowerUp:              newMetricCiscoEnvironmentPowerUp(mbc.Metrics.CiscoEnvironmentPowerUp),
		metricCiscoEnvironmentSensorTemp:           newMetricCiscoEnvironmentSensorTemp(mbc.Metrics.CiscoEnvironmentSensorTemp),
		metricCiscoFactsCPUFiveMinutesPercent:      newMetricCiscoFactsCPUFiveMinutesPercent(mbc.Metrics.CiscoFactsCPUFiveMinutesPercent),
		metricCiscoFactsCPUFiveSecondsPercent:      newMetricCiscoFactsCPUFiveSecondsPercent(mbc.Metrics.CiscoFactsCPUFiveSecondsPercent),
		metricCiscoFactsCPUInterruptPercent:        newMetricCiscoFactsCPUInterruptPercent(mbc.Metrics.CiscoFactsCPUInterruptPercent),
		metricCiscoFactsCPUOneMinutePercent:        newMetricCiscoFactsCPUOneMinutePercent(mbc.Metrics.CiscoFactsCPUOneMinutePercent),
		metricCiscoFactsMemoryFree:                 newMetricCiscoFactsMemoryFree(mbc.Metrics.CiscoFactsMemoryFree),
		metricCiscoFactsMemoryTotal:                newMetricCiscoFactsMemoryTotal(mbc.Metrics.CiscoFactsMemoryTotal),
		metricCiscoFactsMemoryUsed:                 newMetricCiscoFactsMemoryUsed(mbc.Metrics.CiscoFactsMemoryUsed),
		metricCiscoFactsVersion:                    newMetricCiscoFactsVersion(mbc.Metrics.CiscoFactsVersion),
		metricCiscoInterfaceAdminUp:                newMetricCiscoInterfaceAdminUp(mbc.Metrics.CiscoInterfaceAdminUp),
		metricCiscoInterfaceErrorStatus:            newMetricCiscoInterfaceErrorStatus(mbc.Metrics.CiscoInterfaceErrorStatus),
		metricCiscoInterfaceReceiveBroadcast:       newMetricCiscoInterfaceReceiveBroadcast(mbc.Metrics.CiscoInterfaceReceiveBroadcast),
		metricCiscoInterfaceReceiveBytes:           newMetricCiscoInterfaceReceiveBytes(mbc.Metrics.CiscoInterfaceReceiveBytes),
		metricCiscoInterfaceReceiveDrops:           newMetricCiscoInterfaceReceiveDrops(mbc.Metrics.CiscoInterfaceReceiveDrops),
		metricCiscoInterfaceReceiveErrors:          newMetricCiscoInterfaceReceiveErrors(mbc.Metrics.CiscoInterfaceReceiveErrors),
		metricCiscoInterfaceReceiveMulticast:       newMetricCiscoInterfaceReceiveMulticast(mbc.Metrics.CiscoInterfaceReceiveMulticast),
		metricCiscoInterfaceTransmitBytes:          newMetricCiscoInterfaceTransmitBytes(mbc.Metrics.CiscoInterfaceTransmitBytes),
		metricCiscoInterfaceTransmitDrops:          newMetricCiscoInterfaceTransmitDrops(mbc.Metrics.CiscoInterfaceTransmitDrops),
		metricCiscoInterfaceTransmitErrors:         newMetricCiscoInterfaceTransmitErrors(mbc.Metrics.CiscoInterfaceTransmitErrors),
		metricCiscoInterfaceUp:                     newMetricCiscoInterfaceUp(mbc.Metrics.CiscoInterfaceUp),
		metricCiscoOpticsRx:                        newMetricCiscoOpticsRx(mbc.Metrics.CiscoOpticsRx),
		metricCiscoOpticsTx:                        newMetricCiscoOpticsTx(mbc.Metrics.CiscoOpticsTx),
		metricCiscoUp:                              newMetricCiscoUp(mbc.Metrics.CiscoUp),
	}

	for _, op := range options {
		op.apply(mb)
	}
	return mb
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (mb *MetricsBuilder) updateCapacity(rm pmetric.ResourceMetrics) {
	if mb.metricsCapacity < rm.ScopeMetrics().At(0).Metrics().Len() {
		mb.metricsCapacity = rm.ScopeMetrics().At(0).Metrics().Len()
	}
}

// ResourceMetricsOption applies changes to provided resource metrics.
type ResourceMetricsOption interface {
	apply(pmetric.ResourceMetrics)
}

type resourceMetricsOptionFunc func(pmetric.ResourceMetrics)

func (rmof resourceMetricsOptionFunc) apply(rm pmetric.ResourceMetrics) {
	rmof(rm)
}

// WithResource sets the provided resource on the emitted ResourceMetrics.
// It's recommended to use ResourceBuilder to create the resource.
func WithResource(res pcommon.Resource) ResourceMetricsOption {
	return resourceMetricsOptionFunc(func(rm pmetric.ResourceMetrics) {
		res.CopyTo(rm.Resource())
	})
}

// WithStartTimeOverride overrides start time for all the resource metrics data points.
// This option should be only used if different start time has to be set on metrics coming from different resources.
func WithStartTimeOverride(start pcommon.Timestamp) ResourceMetricsOption {
	return resourceMetricsOptionFunc(func(rm pmetric.ResourceMetrics) {
		var dps pmetric.NumberDataPointSlice
		metrics := rm.ScopeMetrics().At(0).Metrics()
		for i := 0; i < metrics.Len(); i++ {
			switch metrics.At(i).Type() {
			case pmetric.MetricTypeGauge:
				dps = metrics.At(i).Gauge().DataPoints()
			case pmetric.MetricTypeSum:
				dps = metrics.At(i).Sum().DataPoints()
			}
			for j := 0; j < dps.Len(); j++ {
				dps.At(j).SetStartTimestamp(start)
			}
		}
	})
}

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead.
// Resource attributes should be provided as ResourceMetricsOption arguments.
func (mb *MetricsBuilder) EmitForResource(options ...ResourceMetricsOption) {
	rm := pmetric.NewResourceMetrics()
	ils := rm.ScopeMetrics().AppendEmpty()
	ils.Scope().SetName(ScopeName)
	ils.Scope().SetVersion(mb.buildInfo.Version)
	ils.Metrics().EnsureCapacity(mb.metricsCapacity)
	mb.metricCiscoBgpSessionMessagesInputCount.emit(ils.Metrics())
	mb.metricCiscoBgpSessionMessagesOutputCount.emit(ils.Metrics())
	mb.metricCiscoBgpSessionPrefixesReceivedCount.emit(ils.Metrics())
	mb.metricCiscoBgpSessionUp.emit(ils.Metrics())
	mb.metricCiscoCollectDurationSeconds.emit(ils.Metrics())
	mb.metricCiscoCollectorDurationSeconds.emit(ils.Metrics())
	mb.metricCiscoEnvironmentPowerUp.emit(ils.Metrics())
	mb.metricCiscoEnvironmentSensorTemp.emit(ils.Metrics())
	mb.metricCiscoFactsCPUFiveMinutesPercent.emit(ils.Metrics())
	mb.metricCiscoFactsCPUFiveSecondsPercent.emit(ils.Metrics())
	mb.metricCiscoFactsCPUInterruptPercent.emit(ils.Metrics())
	mb.metricCiscoFactsCPUOneMinutePercent.emit(ils.Metrics())
	mb.metricCiscoFactsMemoryFree.emit(ils.Metrics())
	mb.metricCiscoFactsMemoryTotal.emit(ils.Metrics())
	mb.metricCiscoFactsMemoryUsed.emit(ils.Metrics())
	mb.metricCiscoFactsVersion.emit(ils.Metrics())
	mb.metricCiscoInterfaceAdminUp.emit(ils.Metrics())
	mb.metricCiscoInterfaceErrorStatus.emit(ils.Metrics())
	mb.metricCiscoInterfaceReceiveBroadcast.emit(ils.Metrics())
	mb.metricCiscoInterfaceReceiveBytes.emit(ils.Metrics())
	mb.metricCiscoInterfaceReceiveDrops.emit(ils.Metrics())
	mb.metricCiscoInterfaceReceiveErrors.emit(ils.Metrics())
	mb.metricCiscoInterfaceReceiveMulticast.emit(ils.Metrics())
	mb.metricCiscoInterfaceTransmitBytes.emit(ils.Metrics())
	mb.metricCiscoInterfaceTransmitDrops.emit(ils.Metrics())
	mb.metricCiscoInterfaceTransmitErrors.emit(ils.Metrics())
	mb.metricCiscoInterfaceUp.emit(ils.Metrics())
	mb.metricCiscoOpticsRx.emit(ils.Metrics())
	mb.metricCiscoOpticsTx.emit(ils.Metrics())
	mb.metricCiscoUp.emit(ils.Metrics())

	for _, op := range options {
		op.apply(rm)
	}

	if ils.Metrics().Len() > 0 {
		mb.updateCapacity(rm)
		rm.MoveTo(mb.metricsBuffer.ResourceMetrics().AppendEmpty())
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user config, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit(options ...ResourceMetricsOption) pmetric.Metrics {
	mb.EmitForResource(options...)
	metrics := mb.metricsBuffer
	mb.metricsBuffer = pmetric.NewMetrics()
	return metrics
}

// RecordCiscoBgpSessionMessagesInputCountDataPoint adds a data point to cisco_bgp_session_messages_input_count metric.
func (mb *MetricsBuilder) RecordCiscoBgpSessionMessagesInputCountDataPoint(ts pcommon.Timestamp, val int64, targetAttributeValue string, asnAttributeValue string, ipAttributeValue string) {
	mb.metricCiscoBgpSessionMessagesInputCount.recordDataPoint(mb.startTime, ts, val, targetAttributeValue, asnAttributeValue, ipAttributeValue)
}

// RecordCiscoBgpSessionMessagesOutputCountDataPoint adds a data point to cisco_bgp_session_messages_output_count metric.
func (mb *MetricsBuilder) RecordCiscoBgpSessionMessagesOutputCountDataPoint(ts pcommon.Timestamp, val int64, targetAttributeValue string, asnAttributeValue string, ipAttributeValue string) {
	mb.metricCiscoBgpSessionMessagesOutputCount.recordDataPoint(mb.startTime, ts, val, targetAttributeValue, asnAttributeValue, ipAttributeValue)
}

// RecordCiscoBgpSessionPrefixesReceivedCountDataPoint adds a data point to cisco_bgp_session_prefixes_received_count metric.
func (mb *MetricsBuilder) RecordCiscoBgpSessionPrefixesReceivedCountDataPoint(ts pcommon.Timestamp, val int64, targetAttributeValue string, asnAttributeValue string, ipAttributeValue string) {
	mb.metricCiscoBgpSessionPrefixesReceivedCount.recordDataPoint(mb.startTime, ts, val, targetAttributeValue, asnAttributeValue, ipAttributeValue)
}

// RecordCiscoBgpSessionUpDataPoint adds a data point to cisco_bgp_session_up metric.
func (mb *MetricsBuilder) RecordCiscoBgpSessionUpDataPoint(ts pcommon.Timestamp, val int64, targetAttributeValue string, asnAttributeValue string, ipAttributeValue string) {
	mb.metricCiscoBgpSessionUp.recordDataPoint(mb.startTime, ts, val, targetAttributeValue, asnAttributeValue, ipAttributeValue)
}

// RecordCiscoCollectDurationSecondsDataPoint adds a data point to cisco_collect_duration_seconds metric.
func (mb *MetricsBuilder) RecordCiscoCollectDurationSecondsDataPoint(ts pcommon.Timestamp, val float64, targetAttributeValue string, collectorAttributeValue string) {
	mb.metricCiscoCollectDurationSeconds.recordDataPoint(mb.startTime, ts, val, targetAttributeValue, collectorAttributeValue)
}

// RecordCiscoCollectorDurationSecondsDataPoint adds a data point to cisco_collector_duration_seconds metric.
func (mb *MetricsBuilder) RecordCiscoCollectorDurationSecondsDataPoint(ts pcommon.Timestamp, val float64, targetAttributeValue string) {
	mb.metricCiscoCollectorDurationSeconds.recordDataPoint(mb.startTime, ts, val, targetAttributeValue)
}

// RecordCiscoEnvironmentPowerUpDataPoint adds a data point to cisco_environment_power_up metric.
func (mb *MetricsBuilder) RecordCiscoEnvironmentPowerUpDataPoint(ts pcommon.Timestamp, val int64, targetAttributeValue string, itemAttributeValue string, statusAttributeValue string) {
	mb.metricCiscoEnvironmentPowerUp.recordDataPoint(mb.startTime, ts, val, targetAttributeValue, itemAttributeValue, statusAttributeValue)
}

// RecordCiscoEnvironmentSensorTempDataPoint adds a data point to cisco_environment_sensor_temp metric.
func (mb *MetricsBuilder) RecordCiscoEnvironmentSensorTempDataPoint(ts pcommon.Timestamp, val float64, targetAttributeValue string, itemAttributeValue string, statusAttributeValue string) {
	mb.metricCiscoEnvironmentSensorTemp.recordDataPoint(mb.startTime, ts, val, targetAttributeValue, itemAttributeValue, statusAttributeValue)
}

// RecordCiscoFactsCPUFiveMinutesPercentDataPoint adds a data point to cisco_facts_cpu_five_minutes_percent metric.
func (mb *MetricsBuilder) RecordCiscoFactsCPUFiveMinutesPercentDataPoint(ts pcommon.Timestamp, val float64, targetAttributeValue string) {
	mb.metricCiscoFactsCPUFiveMinutesPercent.recordDataPoint(mb.startTime, ts, val, targetAttributeValue)
}

// RecordCiscoFactsCPUFiveSecondsPercentDataPoint adds a data point to cisco_facts_cpu_five_seconds_percent metric.
func (mb *MetricsBuilder) RecordCiscoFactsCPUFiveSecondsPercentDataPoint(ts pcommon.Timestamp, val float64, targetAttributeValue string) {
	mb.metricCiscoFactsCPUFiveSecondsPercent.recordDataPoint(mb.startTime, ts, val, targetAttributeValue)
}

// RecordCiscoFactsCPUInterruptPercentDataPoint adds a data point to cisco_facts_cpu_interrupt_percent metric.
func (mb *MetricsBuilder) RecordCiscoFactsCPUInterruptPercentDataPoint(ts pcommon.Timestamp, val float64, targetAttributeValue string) {
	mb.metricCiscoFactsCPUInterruptPercent.recordDataPoint(mb.startTime, ts, val, targetAttributeValue)
}

// RecordCiscoFactsCPUOneMinutePercentDataPoint adds a data point to cisco_facts_cpu_one_minute_percent metric.
func (mb *MetricsBuilder) RecordCiscoFactsCPUOneMinutePercentDataPoint(ts pcommon.Timestamp, val float64, targetAttributeValue string) {
	mb.metricCiscoFactsCPUOneMinutePercent.recordDataPoint(mb.startTime, ts, val, targetAttributeValue)
}

// RecordCiscoFactsMemoryFreeDataPoint adds a data point to cisco_facts_memory_free metric.
func (mb *MetricsBuilder) RecordCiscoFactsMemoryFreeDataPoint(ts pcommon.Timestamp, val int64, targetAttributeValue string, typeAttributeValue string) {
	mb.metricCiscoFactsMemoryFree.recordDataPoint(mb.startTime, ts, val, targetAttributeValue, typeAttributeValue)
}

// RecordCiscoFactsMemoryTotalDataPoint adds a data point to cisco_facts_memory_total metric.
func (mb *MetricsBuilder) RecordCiscoFactsMemoryTotalDataPoint(ts pcommon.Timestamp, val int64, targetAttributeValue string, typeAttributeValue string) {
	mb.metricCiscoFactsMemoryTotal.recordDataPoint(mb.startTime, ts, val, targetAttributeValue, typeAttributeValue)
}

// RecordCiscoFactsMemoryUsedDataPoint adds a data point to cisco_facts_memory_used metric.
func (mb *MetricsBuilder) RecordCiscoFactsMemoryUsedDataPoint(ts pcommon.Timestamp, val int64, targetAttributeValue string, typeAttributeValue string) {
	mb.metricCiscoFactsMemoryUsed.recordDataPoint(mb.startTime, ts, val, targetAttributeValue, typeAttributeValue)
}

// RecordCiscoFactsVersionDataPoint adds a data point to cisco_facts_version metric.
func (mb *MetricsBuilder) RecordCiscoFactsVersionDataPoint(ts pcommon.Timestamp, val int64, targetAttributeValue string, versionAttributeValue string) {
	mb.metricCiscoFactsVersion.recordDataPoint(mb.startTime, ts, val, targetAttributeValue, versionAttributeValue)
}

// RecordCiscoInterfaceAdminUpDataPoint adds a data point to cisco_interface_admin_up metric.
func (mb *MetricsBuilder) RecordCiscoInterfaceAdminUpDataPoint(ts pcommon.Timestamp, val int64, targetAttributeValue string, nameAttributeValue string, descriptionAttributeValue string, macAttributeValue string, speedAttributeValue string) {
	mb.metricCiscoInterfaceAdminUp.recordDataPoint(mb.startTime, ts, val, targetAttributeValue, nameAttributeValue, descriptionAttributeValue, macAttributeValue, speedAttributeValue)
}

// RecordCiscoInterfaceErrorStatusDataPoint adds a data point to cisco_interface_error_status metric.
func (mb *MetricsBuilder) RecordCiscoInterfaceErrorStatusDataPoint(ts pcommon.Timestamp, val int64, targetAttributeValue string, nameAttributeValue string, descriptionAttributeValue string, macAttributeValue string, speedAttributeValue string) {
	mb.metricCiscoInterfaceErrorStatus.recordDataPoint(mb.startTime, ts, val, targetAttributeValue, nameAttributeValue, descriptionAttributeValue, macAttributeValue, speedAttributeValue)
}

// RecordCiscoInterfaceReceiveBroadcastDataPoint adds a data point to cisco_interface_receive_broadcast metric.
func (mb *MetricsBuilder) RecordCiscoInterfaceReceiveBroadcastDataPoint(ts pcommon.Timestamp, val int64, targetAttributeValue string, nameAttributeValue string, descriptionAttributeValue string, macAttributeValue string, speedAttributeValue string) {
	mb.metricCiscoInterfaceReceiveBroadcast.recordDataPoint(mb.startTime, ts, val, targetAttributeValue, nameAttributeValue, descriptionAttributeValue, macAttributeValue, speedAttributeValue)
}

// RecordCiscoInterfaceReceiveBytesDataPoint adds a data point to cisco_interface_receive_bytes metric.
func (mb *MetricsBuilder) RecordCiscoInterfaceReceiveBytesDataPoint(ts pcommon.Timestamp, val int64, targetAttributeValue string, nameAttributeValue string, descriptionAttributeValue string, macAttributeValue string, speedAttributeValue string) {
	mb.metricCiscoInterfaceReceiveBytes.recordDataPoint(mb.startTime, ts, val, targetAttributeValue, nameAttributeValue, descriptionAttributeValue, macAttributeValue, speedAttributeValue)
}

// RecordCiscoInterfaceReceiveDropsDataPoint adds a data point to cisco_interface_receive_drops metric.
func (mb *MetricsBuilder) RecordCiscoInterfaceReceiveDropsDataPoint(ts pcommon.Timestamp, val int64, targetAttributeValue string, nameAttributeValue string, descriptionAttributeValue string, macAttributeValue string, speedAttributeValue string) {
	mb.metricCiscoInterfaceReceiveDrops.recordDataPoint(mb.startTime, ts, val, targetAttributeValue, nameAttributeValue, descriptionAttributeValue, macAttributeValue, speedAttributeValue)
}

// RecordCiscoInterfaceReceiveErrorsDataPoint adds a data point to cisco_interface_receive_errors metric.
func (mb *MetricsBuilder) RecordCiscoInterfaceReceiveErrorsDataPoint(ts pcommon.Timestamp, val int64, targetAttributeValue string, nameAttributeValue string, descriptionAttributeValue string, macAttributeValue string, speedAttributeValue string) {
	mb.metricCiscoInterfaceReceiveErrors.recordDataPoint(mb.startTime, ts, val, targetAttributeValue, nameAttributeValue, descriptionAttributeValue, macAttributeValue, speedAttributeValue)
}

// RecordCiscoInterfaceReceiveMulticastDataPoint adds a data point to cisco_interface_receive_multicast metric.
func (mb *MetricsBuilder) RecordCiscoInterfaceReceiveMulticastDataPoint(ts pcommon.Timestamp, val int64, targetAttributeValue string, nameAttributeValue string, descriptionAttributeValue string, macAttributeValue string, speedAttributeValue string) {
	mb.metricCiscoInterfaceReceiveMulticast.recordDataPoint(mb.startTime, ts, val, targetAttributeValue, nameAttributeValue, descriptionAttributeValue, macAttributeValue, speedAttributeValue)
}

// RecordCiscoInterfaceTransmitBytesDataPoint adds a data point to cisco_interface_transmit_bytes metric.
func (mb *MetricsBuilder) RecordCiscoInterfaceTransmitBytesDataPoint(ts pcommon.Timestamp, val int64, targetAttributeValue string, nameAttributeValue string, descriptionAttributeValue string, macAttributeValue string, speedAttributeValue string) {
	mb.metricCiscoInterfaceTransmitBytes.recordDataPoint(mb.startTime, ts, val, targetAttributeValue, nameAttributeValue, descriptionAttributeValue, macAttributeValue, speedAttributeValue)
}

// RecordCiscoInterfaceTransmitDropsDataPoint adds a data point to cisco_interface_transmit_drops metric.
func (mb *MetricsBuilder) RecordCiscoInterfaceTransmitDropsDataPoint(ts pcommon.Timestamp, val int64, targetAttributeValue string, nameAttributeValue string, descriptionAttributeValue string, macAttributeValue string, speedAttributeValue string) {
	mb.metricCiscoInterfaceTransmitDrops.recordDataPoint(mb.startTime, ts, val, targetAttributeValue, nameAttributeValue, descriptionAttributeValue, macAttributeValue, speedAttributeValue)
}

// RecordCiscoInterfaceTransmitErrorsDataPoint adds a data point to cisco_interface_transmit_errors metric.
func (mb *MetricsBuilder) RecordCiscoInterfaceTransmitErrorsDataPoint(ts pcommon.Timestamp, val int64, targetAttributeValue string, nameAttributeValue string, descriptionAttributeValue string, macAttributeValue string, speedAttributeValue string) {
	mb.metricCiscoInterfaceTransmitErrors.recordDataPoint(mb.startTime, ts, val, targetAttributeValue, nameAttributeValue, descriptionAttributeValue, macAttributeValue, speedAttributeValue)
}

// RecordCiscoInterfaceUpDataPoint adds a data point to cisco_interface_up metric.
func (mb *MetricsBuilder) RecordCiscoInterfaceUpDataPoint(ts pcommon.Timestamp, val int64, targetAttributeValue string, nameAttributeValue string, descriptionAttributeValue string, macAttributeValue string, speedAttributeValue string) {
	mb.metricCiscoInterfaceUp.recordDataPoint(mb.startTime, ts, val, targetAttributeValue, nameAttributeValue, descriptionAttributeValue, macAttributeValue, speedAttributeValue)
}

// RecordCiscoOpticsRxDataPoint adds a data point to cisco_optics_rx metric.
func (mb *MetricsBuilder) RecordCiscoOpticsRxDataPoint(ts pcommon.Timestamp, val float64, targetAttributeValue string, interfaceAttributeValue string) {
	mb.metricCiscoOpticsRx.recordDataPoint(mb.startTime, ts, val, targetAttributeValue, interfaceAttributeValue)
}

// RecordCiscoOpticsTxDataPoint adds a data point to cisco_optics_tx metric.
func (mb *MetricsBuilder) RecordCiscoOpticsTxDataPoint(ts pcommon.Timestamp, val float64, targetAttributeValue string, interfaceAttributeValue string) {
	mb.metricCiscoOpticsTx.recordDataPoint(mb.startTime, ts, val, targetAttributeValue, interfaceAttributeValue)
}

// RecordCiscoUpDataPoint adds a data point to cisco_up metric.
func (mb *MetricsBuilder) RecordCiscoUpDataPoint(ts pcommon.Timestamp, val int64, targetAttributeValue string) {
	mb.metricCiscoUp.recordDataPoint(mb.startTime, ts, val, targetAttributeValue)
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...MetricBuilderOption) {
	mb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op.apply(mb)
	}
}
