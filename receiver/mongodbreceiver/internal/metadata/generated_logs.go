// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"context"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/filter"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/plog"
	"go.opentelemetry.io/collector/receiver"
	"go.opentelemetry.io/otel/trace"
)

type eventMongodbQuerySample struct {
	data   plog.LogRecordSlice // data buffer for generated log records.
	config EventConfig         // event config provided by user.
}

func (e *eventMongodbQuerySample) recordEvent(ctx context.Context, timestamp pcommon.Timestamp, mongodbNamespaceAttributeValue string, mongodbObfuscatedCommandAttributeValue string, mongodbQuerySignatureAttributeValue string, mongodbDurationMicrosAttributeValue int64, mongodbExplainPlanAttributeValue string) {
	if !e.config.Enabled {
		return
	}
	dp := e.data.AppendEmpty()
	dp.SetEventName("mongodb.query.sample")
	dp.SetTimestamp(timestamp)

	if span := trace.SpanContextFromContext(ctx); span.IsValid() {
		dp.SetTraceID(pcommon.TraceID(span.TraceID()))
		dp.SetSpanID(pcommon.SpanID(span.SpanID()))
	}
	dp.Attributes().PutStr("mongodb.namespace", mongodbNamespaceAttributeValue)
	dp.Attributes().PutStr("mongodb.obfuscated_command", mongodbObfuscatedCommandAttributeValue)
	dp.Attributes().PutStr("mongodb.query.signature", mongodbQuerySignatureAttributeValue)
	dp.Attributes().PutInt("mongodb.duration_micros", mongodbDurationMicrosAttributeValue)
	dp.Attributes().PutStr("mongodb.explain_plan", mongodbExplainPlanAttributeValue)

}

// emit appends recorded event data to a events slice and prepares it for recording another set of log records.
func (e *eventMongodbQuerySample) emit(lrs plog.LogRecordSlice) {
	if e.config.Enabled && e.data.Len() > 0 {
		e.data.MoveAndAppendTo(lrs)
	}
}

func newEventMongodbQuerySample(cfg EventConfig) eventMongodbQuerySample {
	e := eventMongodbQuerySample{config: cfg}
	if cfg.Enabled {
		e.data = plog.NewLogRecordSlice()
	}
	return e
}

// LogsBuilder provides an interface for scrapers to report logs while taking care of all the transformations
// required to produce log representation defined in metadata and user config.
type LogsBuilder struct {
	config                         LogsBuilderConfig // config of the logs builder.
	logsBuffer                     plog.Logs
	logRecordsBuffer               plog.LogRecordSlice
	buildInfo                      component.BuildInfo // contains version information.
	resourceAttributeIncludeFilter map[string]filter.Filter
	resourceAttributeExcludeFilter map[string]filter.Filter
	eventMongodbQuerySample        eventMongodbQuerySample
}

// LogBuilderOption applies changes to default logs builder.
type LogBuilderOption interface {
	apply(*LogsBuilder)
}

func NewLogsBuilder(lbc LogsBuilderConfig, settings receiver.Settings) *LogsBuilder {
	lb := &LogsBuilder{
		config:                         lbc,
		logsBuffer:                     plog.NewLogs(),
		logRecordsBuffer:               plog.NewLogRecordSlice(),
		buildInfo:                      settings.BuildInfo,
		eventMongodbQuerySample:        newEventMongodbQuerySample(lbc.Events.MongodbQuerySample),
		resourceAttributeIncludeFilter: make(map[string]filter.Filter),
		resourceAttributeExcludeFilter: make(map[string]filter.Filter),
	}
	if lbc.ResourceAttributes.Database.EventsInclude != nil {
		lb.resourceAttributeIncludeFilter["database"] = filter.CreateFilter(lbc.ResourceAttributes.Database.EventsInclude)
	}
	if lbc.ResourceAttributes.Database.EventsExclude != nil {
		lb.resourceAttributeExcludeFilter["database"] = filter.CreateFilter(lbc.ResourceAttributes.Database.EventsExclude)
	}
	if lbc.ResourceAttributes.ServerAddress.EventsInclude != nil {
		lb.resourceAttributeIncludeFilter["server.address"] = filter.CreateFilter(lbc.ResourceAttributes.ServerAddress.EventsInclude)
	}
	if lbc.ResourceAttributes.ServerAddress.EventsExclude != nil {
		lb.resourceAttributeExcludeFilter["server.address"] = filter.CreateFilter(lbc.ResourceAttributes.ServerAddress.EventsExclude)
	}
	if lbc.ResourceAttributes.ServerPort.EventsInclude != nil {
		lb.resourceAttributeIncludeFilter["server.port"] = filter.CreateFilter(lbc.ResourceAttributes.ServerPort.EventsInclude)
	}
	if lbc.ResourceAttributes.ServerPort.EventsExclude != nil {
		lb.resourceAttributeExcludeFilter["server.port"] = filter.CreateFilter(lbc.ResourceAttributes.ServerPort.EventsExclude)
	}

	return lb
}

// NewResourceBuilder returns a new resource builder that should be used to build a resource associated with for the emitted logs.
func (lb *LogsBuilder) NewResourceBuilder() *ResourceBuilder {
	return NewResourceBuilder(lb.config.ResourceAttributes)
}

// ResourceLogsOption applies changes to provided resource logs.
type ResourceLogsOption interface {
	apply(plog.ResourceLogs)
}

type resourceLogsOptionFunc func(plog.ResourceLogs)

func (rlof resourceLogsOptionFunc) apply(rl plog.ResourceLogs) {
	rlof(rl)
}

// WithLogsResource sets the provided resource on the emitted ResourceLogs.
// It's recommended to use ResourceBuilder to create the resource.
func WithLogsResource(res pcommon.Resource) ResourceLogsOption {
	return resourceLogsOptionFunc(func(rl plog.ResourceLogs) {
		res.CopyTo(rl.Resource())
	})
}

// AppendLogRecord adds a log record to the logs builder.
func (lb *LogsBuilder) AppendLogRecord(lr plog.LogRecord) {
	lr.MoveTo(lb.logRecordsBuffer.AppendEmpty())
}

// EmitForResource saves all the generated logs under a new resource and updates the internal state to be ready for
// recording another set of log records as part of another resource. This function can be helpful when one scraper
// needs to emit logs from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead.
// Resource attributes should be provided as ResourceLogsOption arguments.
func (lb *LogsBuilder) EmitForResource(options ...ResourceLogsOption) {
	rl := plog.NewResourceLogs()
	ils := rl.ScopeLogs().AppendEmpty()
	ils.Scope().SetName(ScopeName)
	ils.Scope().SetVersion(lb.buildInfo.Version)
	lb.eventMongodbQuerySample.emit(ils.LogRecords())

	for _, op := range options {
		op.apply(rl)
	}

	if lb.logRecordsBuffer.Len() > 0 {
		lb.logRecordsBuffer.MoveAndAppendTo(ils.LogRecords())
		lb.logRecordsBuffer = plog.NewLogRecordSlice()
	}

	for attr, filter := range lb.resourceAttributeIncludeFilter {
		if val, ok := rl.Resource().Attributes().Get(attr); ok && !filter.Matches(val.AsString()) {
			return
		}
	}
	for attr, filter := range lb.resourceAttributeExcludeFilter {
		if val, ok := rl.Resource().Attributes().Get(attr); ok && filter.Matches(val.AsString()) {
			return
		}
	}

	if ils.LogRecords().Len() > 0 {
		rl.MoveTo(lb.logsBuffer.ResourceLogs().AppendEmpty())
	}
}

// Emit returns all the logs accumulated by the logs builder and updates the internal state to be ready for
// recording another set of logs. This function will be responsible for applying all the transformations required to
// produce logs representation defined in metadata and user config.
func (lb *LogsBuilder) Emit(options ...ResourceLogsOption) plog.Logs {
	lb.EmitForResource(options...)
	logs := lb.logsBuffer
	lb.logsBuffer = plog.NewLogs()
	return logs
}

// RecordMongodbQuerySampleEvent adds a log record of mongodb.query.sample event.
func (lb *LogsBuilder) RecordMongodbQuerySampleEvent(ctx context.Context, timestamp pcommon.Timestamp, mongodbNamespaceAttributeValue string, mongodbObfuscatedCommandAttributeValue string, mongodbQuerySignatureAttributeValue string, mongodbDurationMicrosAttributeValue int64, mongodbExplainPlanAttributeValue string) {
	lb.eventMongodbQuerySample.recordEvent(ctx, timestamp, mongodbNamespaceAttributeValue, mongodbObfuscatedCommandAttributeValue, mongodbQuerySignatureAttributeValue, mongodbDurationMicrosAttributeValue, mongodbExplainPlanAttributeValue)
}
