// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
	"go.opentelemetry.io/collector/receiver"
)

var MetricsInfo = metricsInfo{
	IpvsDestinationConnectionActiveCount: metricInfo{
		Name: "ipvs.destination.connection.active.count",
	},
	IpvsDestinationConnectionInactiveCount: metricInfo{
		Name: "ipvs.destination.connection.inactive.count",
	},
	IpvsDestinationConnectionRate: metricInfo{
		Name: "ipvs.destination.connection.rate",
	},
	IpvsDestinationConnectionTotal: metricInfo{
		Name: "ipvs.destination.connection.total",
	},
	IpvsDestinationConnectionWeight: metricInfo{
		Name: "ipvs.destination.connection.weight",
	},
	IpvsDestinationInRate: metricInfo{
		Name: "ipvs.destination.in.rate",
	},
	IpvsDestinationInTotal: metricInfo{
		Name: "ipvs.destination.in.total",
	},
	IpvsDestinationOutRate: metricInfo{
		Name: "ipvs.destination.out.rate",
	},
	IpvsDestinationOutTotal: metricInfo{
		Name: "ipvs.destination.out.total",
	},
	IpvsDestinationPacketInRate: metricInfo{
		Name: "ipvs.destination.packet.in.rate",
	},
	IpvsDestinationPacketInTotal: metricInfo{
		Name: "ipvs.destination.packet.in.total",
	},
	IpvsDestinationPacketOutRate: metricInfo{
		Name: "ipvs.destination.packet.out.rate",
	},
	IpvsDestinationPacketOutTotal: metricInfo{
		Name: "ipvs.destination.packet.out.total",
	},
	IpvsServiceConnectionRate: metricInfo{
		Name: "ipvs.service.connection.rate",
	},
	IpvsServiceConnectionTotal: metricInfo{
		Name: "ipvs.service.connection.total",
	},
	IpvsServiceInRate: metricInfo{
		Name: "ipvs.service.in.rate",
	},
	IpvsServiceInTotal: metricInfo{
		Name: "ipvs.service.in.total",
	},
	IpvsServiceOutRate: metricInfo{
		Name: "ipvs.service.out.rate",
	},
	IpvsServiceOutTotal: metricInfo{
		Name: "ipvs.service.out.total",
	},
	IpvsServicePacketInRate: metricInfo{
		Name: "ipvs.service.packet.in.rate",
	},
	IpvsServicePacketInTotal: metricInfo{
		Name: "ipvs.service.packet.in.total",
	},
	IpvsServicePacketOutRate: metricInfo{
		Name: "ipvs.service.packet.out.rate",
	},
	IpvsServicePacketOutTotal: metricInfo{
		Name: "ipvs.service.packet.out.total",
	},
}

type metricsInfo struct {
	IpvsDestinationConnectionActiveCount   metricInfo
	IpvsDestinationConnectionInactiveCount metricInfo
	IpvsDestinationConnectionRate          metricInfo
	IpvsDestinationConnectionTotal         metricInfo
	IpvsDestinationConnectionWeight        metricInfo
	IpvsDestinationInRate                  metricInfo
	IpvsDestinationInTotal                 metricInfo
	IpvsDestinationOutRate                 metricInfo
	IpvsDestinationOutTotal                metricInfo
	IpvsDestinationPacketInRate            metricInfo
	IpvsDestinationPacketInTotal           metricInfo
	IpvsDestinationPacketOutRate           metricInfo
	IpvsDestinationPacketOutTotal          metricInfo
	IpvsServiceConnectionRate              metricInfo
	IpvsServiceConnectionTotal             metricInfo
	IpvsServiceInRate                      metricInfo
	IpvsServiceInTotal                     metricInfo
	IpvsServiceOutRate                     metricInfo
	IpvsServiceOutTotal                    metricInfo
	IpvsServicePacketInRate                metricInfo
	IpvsServicePacketInTotal               metricInfo
	IpvsServicePacketOutRate               metricInfo
	IpvsServicePacketOutTotal              metricInfo
}

type metricInfo struct {
	Name string
}

type metricIpvsDestinationConnectionActiveCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills ipvs.destination.connection.active.count metric with initial data.
func (m *metricIpvsDestinationConnectionActiveCount) init() {
	m.data.SetName("ipvs.destination.connection.active.count")
	m.data.SetDescription("Number of active connections to the destination.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricIpvsDestinationConnectionActiveCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string, ripAddressAttributeValue string, ripFamilyAttributeValue string, ripPortAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sched", schedAttributeValue)
	dp.Attributes().PutStr("netmask", netmaskAttributeValue)
	dp.Attributes().PutStr("protocol", protocolAttributeValue)
	dp.Attributes().PutStr("vip_address", vipAddressAttributeValue)
	dp.Attributes().PutStr("vip_family", vipFamilyAttributeValue)
	dp.Attributes().PutStr("vip_port", vipPortAttributeValue)
	dp.Attributes().PutStr("rip_address", ripAddressAttributeValue)
	dp.Attributes().PutStr("rip_family", ripFamilyAttributeValue)
	dp.Attributes().PutStr("rip_port", ripPortAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIpvsDestinationConnectionActiveCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIpvsDestinationConnectionActiveCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIpvsDestinationConnectionActiveCount(cfg MetricConfig) metricIpvsDestinationConnectionActiveCount {
	m := metricIpvsDestinationConnectionActiveCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricIpvsDestinationConnectionInactiveCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills ipvs.destination.connection.inactive.count metric with initial data.
func (m *metricIpvsDestinationConnectionInactiveCount) init() {
	m.data.SetName("ipvs.destination.connection.inactive.count")
	m.data.SetDescription("Number of inactive connections to the destination.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricIpvsDestinationConnectionInactiveCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string, ripAddressAttributeValue string, ripFamilyAttributeValue string, ripPortAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sched", schedAttributeValue)
	dp.Attributes().PutStr("netmask", netmaskAttributeValue)
	dp.Attributes().PutStr("protocol", protocolAttributeValue)
	dp.Attributes().PutStr("vip_address", vipAddressAttributeValue)
	dp.Attributes().PutStr("vip_family", vipFamilyAttributeValue)
	dp.Attributes().PutStr("vip_port", vipPortAttributeValue)
	dp.Attributes().PutStr("rip_address", ripAddressAttributeValue)
	dp.Attributes().PutStr("rip_family", ripFamilyAttributeValue)
	dp.Attributes().PutStr("rip_port", ripPortAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIpvsDestinationConnectionInactiveCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIpvsDestinationConnectionInactiveCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIpvsDestinationConnectionInactiveCount(cfg MetricConfig) metricIpvsDestinationConnectionInactiveCount {
	m := metricIpvsDestinationConnectionInactiveCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricIpvsDestinationConnectionRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills ipvs.destination.connection.rate metric with initial data.
func (m *metricIpvsDestinationConnectionRate) init() {
	m.data.SetName("ipvs.destination.connection.rate")
	m.data.SetDescription("Current connection rate (connections per second) to the destination.")
	m.data.SetUnit("1/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricIpvsDestinationConnectionRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string, ripAddressAttributeValue string, ripFamilyAttributeValue string, ripPortAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sched", schedAttributeValue)
	dp.Attributes().PutStr("netmask", netmaskAttributeValue)
	dp.Attributes().PutStr("protocol", protocolAttributeValue)
	dp.Attributes().PutStr("vip_address", vipAddressAttributeValue)
	dp.Attributes().PutStr("vip_family", vipFamilyAttributeValue)
	dp.Attributes().PutStr("vip_port", vipPortAttributeValue)
	dp.Attributes().PutStr("rip_address", ripAddressAttributeValue)
	dp.Attributes().PutStr("rip_family", ripFamilyAttributeValue)
	dp.Attributes().PutStr("rip_port", ripPortAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIpvsDestinationConnectionRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIpvsDestinationConnectionRate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIpvsDestinationConnectionRate(cfg MetricConfig) metricIpvsDestinationConnectionRate {
	m := metricIpvsDestinationConnectionRate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricIpvsDestinationConnectionTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills ipvs.destination.connection.total metric with initial data.
func (m *metricIpvsDestinationConnectionTotal) init() {
	m.data.SetName("ipvs.destination.connection.total")
	m.data.SetDescription("Cumulative number of connections to the destination.")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricIpvsDestinationConnectionTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string, ripAddressAttributeValue string, ripFamilyAttributeValue string, ripPortAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sched", schedAttributeValue)
	dp.Attributes().PutStr("netmask", netmaskAttributeValue)
	dp.Attributes().PutStr("protocol", protocolAttributeValue)
	dp.Attributes().PutStr("vip_address", vipAddressAttributeValue)
	dp.Attributes().PutStr("vip_family", vipFamilyAttributeValue)
	dp.Attributes().PutStr("vip_port", vipPortAttributeValue)
	dp.Attributes().PutStr("rip_address", ripAddressAttributeValue)
	dp.Attributes().PutStr("rip_family", ripFamilyAttributeValue)
	dp.Attributes().PutStr("rip_port", ripPortAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIpvsDestinationConnectionTotal) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIpvsDestinationConnectionTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIpvsDestinationConnectionTotal(cfg MetricConfig) metricIpvsDestinationConnectionTotal {
	m := metricIpvsDestinationConnectionTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricIpvsDestinationConnectionWeight struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills ipvs.destination.connection.weight metric with initial data.
func (m *metricIpvsDestinationConnectionWeight) init() {
	m.data.SetName("ipvs.destination.connection.weight")
	m.data.SetDescription("Current connection weight to the destination.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricIpvsDestinationConnectionWeight) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string, ripAddressAttributeValue string, ripFamilyAttributeValue string, ripPortAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sched", schedAttributeValue)
	dp.Attributes().PutStr("netmask", netmaskAttributeValue)
	dp.Attributes().PutStr("protocol", protocolAttributeValue)
	dp.Attributes().PutStr("vip_address", vipAddressAttributeValue)
	dp.Attributes().PutStr("vip_family", vipFamilyAttributeValue)
	dp.Attributes().PutStr("vip_port", vipPortAttributeValue)
	dp.Attributes().PutStr("rip_address", ripAddressAttributeValue)
	dp.Attributes().PutStr("rip_family", ripFamilyAttributeValue)
	dp.Attributes().PutStr("rip_port", ripPortAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIpvsDestinationConnectionWeight) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIpvsDestinationConnectionWeight) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIpvsDestinationConnectionWeight(cfg MetricConfig) metricIpvsDestinationConnectionWeight {
	m := metricIpvsDestinationConnectionWeight{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricIpvsDestinationInRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills ipvs.destination.in.rate metric with initial data.
func (m *metricIpvsDestinationInRate) init() {
	m.data.SetName("ipvs.destination.in.rate")
	m.data.SetDescription("Current incoming bytes rate (bytes per second) to the destination.")
	m.data.SetUnit("By/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricIpvsDestinationInRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string, ripAddressAttributeValue string, ripFamilyAttributeValue string, ripPortAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sched", schedAttributeValue)
	dp.Attributes().PutStr("netmask", netmaskAttributeValue)
	dp.Attributes().PutStr("protocol", protocolAttributeValue)
	dp.Attributes().PutStr("vip_address", vipAddressAttributeValue)
	dp.Attributes().PutStr("vip_family", vipFamilyAttributeValue)
	dp.Attributes().PutStr("vip_port", vipPortAttributeValue)
	dp.Attributes().PutStr("rip_address", ripAddressAttributeValue)
	dp.Attributes().PutStr("rip_family", ripFamilyAttributeValue)
	dp.Attributes().PutStr("rip_port", ripPortAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIpvsDestinationInRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIpvsDestinationInRate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIpvsDestinationInRate(cfg MetricConfig) metricIpvsDestinationInRate {
	m := metricIpvsDestinationInRate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricIpvsDestinationInTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills ipvs.destination.in.total metric with initial data.
func (m *metricIpvsDestinationInTotal) init() {
	m.data.SetName("ipvs.destination.in.total")
	m.data.SetDescription("Cumulative number of incoming bytes to the destination.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricIpvsDestinationInTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string, ripAddressAttributeValue string, ripFamilyAttributeValue string, ripPortAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sched", schedAttributeValue)
	dp.Attributes().PutStr("netmask", netmaskAttributeValue)
	dp.Attributes().PutStr("protocol", protocolAttributeValue)
	dp.Attributes().PutStr("vip_address", vipAddressAttributeValue)
	dp.Attributes().PutStr("vip_family", vipFamilyAttributeValue)
	dp.Attributes().PutStr("vip_port", vipPortAttributeValue)
	dp.Attributes().PutStr("rip_address", ripAddressAttributeValue)
	dp.Attributes().PutStr("rip_family", ripFamilyAttributeValue)
	dp.Attributes().PutStr("rip_port", ripPortAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIpvsDestinationInTotal) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIpvsDestinationInTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIpvsDestinationInTotal(cfg MetricConfig) metricIpvsDestinationInTotal {
	m := metricIpvsDestinationInTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricIpvsDestinationOutRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills ipvs.destination.out.rate metric with initial data.
func (m *metricIpvsDestinationOutRate) init() {
	m.data.SetName("ipvs.destination.out.rate")
	m.data.SetDescription("Current outgoing bytes rate (bytes per second) from the destination.")
	m.data.SetUnit("By/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricIpvsDestinationOutRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string, ripAddressAttributeValue string, ripFamilyAttributeValue string, ripPortAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sched", schedAttributeValue)
	dp.Attributes().PutStr("netmask", netmaskAttributeValue)
	dp.Attributes().PutStr("protocol", protocolAttributeValue)
	dp.Attributes().PutStr("vip_address", vipAddressAttributeValue)
	dp.Attributes().PutStr("vip_family", vipFamilyAttributeValue)
	dp.Attributes().PutStr("vip_port", vipPortAttributeValue)
	dp.Attributes().PutStr("rip_address", ripAddressAttributeValue)
	dp.Attributes().PutStr("rip_family", ripFamilyAttributeValue)
	dp.Attributes().PutStr("rip_port", ripPortAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIpvsDestinationOutRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIpvsDestinationOutRate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIpvsDestinationOutRate(cfg MetricConfig) metricIpvsDestinationOutRate {
	m := metricIpvsDestinationOutRate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricIpvsDestinationOutTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills ipvs.destination.out.total metric with initial data.
func (m *metricIpvsDestinationOutTotal) init() {
	m.data.SetName("ipvs.destination.out.total")
	m.data.SetDescription("Cumulative number of outgoing bytes from the destination.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricIpvsDestinationOutTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string, ripAddressAttributeValue string, ripFamilyAttributeValue string, ripPortAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sched", schedAttributeValue)
	dp.Attributes().PutStr("netmask", netmaskAttributeValue)
	dp.Attributes().PutStr("protocol", protocolAttributeValue)
	dp.Attributes().PutStr("vip_address", vipAddressAttributeValue)
	dp.Attributes().PutStr("vip_family", vipFamilyAttributeValue)
	dp.Attributes().PutStr("vip_port", vipPortAttributeValue)
	dp.Attributes().PutStr("rip_address", ripAddressAttributeValue)
	dp.Attributes().PutStr("rip_family", ripFamilyAttributeValue)
	dp.Attributes().PutStr("rip_port", ripPortAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIpvsDestinationOutTotal) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIpvsDestinationOutTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIpvsDestinationOutTotal(cfg MetricConfig) metricIpvsDestinationOutTotal {
	m := metricIpvsDestinationOutTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricIpvsDestinationPacketInRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills ipvs.destination.packet.in.rate metric with initial data.
func (m *metricIpvsDestinationPacketInRate) init() {
	m.data.SetName("ipvs.destination.packet.in.rate")
	m.data.SetDescription("Current incoming packet rate (packets per second) to the destination.")
	m.data.SetUnit("1/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricIpvsDestinationPacketInRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string, ripAddressAttributeValue string, ripFamilyAttributeValue string, ripPortAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sched", schedAttributeValue)
	dp.Attributes().PutStr("netmask", netmaskAttributeValue)
	dp.Attributes().PutStr("protocol", protocolAttributeValue)
	dp.Attributes().PutStr("vip_address", vipAddressAttributeValue)
	dp.Attributes().PutStr("vip_family", vipFamilyAttributeValue)
	dp.Attributes().PutStr("vip_port", vipPortAttributeValue)
	dp.Attributes().PutStr("rip_address", ripAddressAttributeValue)
	dp.Attributes().PutStr("rip_family", ripFamilyAttributeValue)
	dp.Attributes().PutStr("rip_port", ripPortAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIpvsDestinationPacketInRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIpvsDestinationPacketInRate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIpvsDestinationPacketInRate(cfg MetricConfig) metricIpvsDestinationPacketInRate {
	m := metricIpvsDestinationPacketInRate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricIpvsDestinationPacketInTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills ipvs.destination.packet.in.total metric with initial data.
func (m *metricIpvsDestinationPacketInTotal) init() {
	m.data.SetName("ipvs.destination.packet.in.total")
	m.data.SetDescription("Cumulative number of incoming packets to the destination.")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricIpvsDestinationPacketInTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string, ripAddressAttributeValue string, ripFamilyAttributeValue string, ripPortAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sched", schedAttributeValue)
	dp.Attributes().PutStr("netmask", netmaskAttributeValue)
	dp.Attributes().PutStr("protocol", protocolAttributeValue)
	dp.Attributes().PutStr("vip_address", vipAddressAttributeValue)
	dp.Attributes().PutStr("vip_family", vipFamilyAttributeValue)
	dp.Attributes().PutStr("vip_port", vipPortAttributeValue)
	dp.Attributes().PutStr("rip_address", ripAddressAttributeValue)
	dp.Attributes().PutStr("rip_family", ripFamilyAttributeValue)
	dp.Attributes().PutStr("rip_port", ripPortAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIpvsDestinationPacketInTotal) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIpvsDestinationPacketInTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIpvsDestinationPacketInTotal(cfg MetricConfig) metricIpvsDestinationPacketInTotal {
	m := metricIpvsDestinationPacketInTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricIpvsDestinationPacketOutRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills ipvs.destination.packet.out.rate metric with initial data.
func (m *metricIpvsDestinationPacketOutRate) init() {
	m.data.SetName("ipvs.destination.packet.out.rate")
	m.data.SetDescription("Current outgoing packet rate (packets per second) from the destination.")
	m.data.SetUnit("1/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricIpvsDestinationPacketOutRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string, ripAddressAttributeValue string, ripFamilyAttributeValue string, ripPortAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sched", schedAttributeValue)
	dp.Attributes().PutStr("netmask", netmaskAttributeValue)
	dp.Attributes().PutStr("protocol", protocolAttributeValue)
	dp.Attributes().PutStr("vip_address", vipAddressAttributeValue)
	dp.Attributes().PutStr("vip_family", vipFamilyAttributeValue)
	dp.Attributes().PutStr("vip_port", vipPortAttributeValue)
	dp.Attributes().PutStr("rip_address", ripAddressAttributeValue)
	dp.Attributes().PutStr("rip_family", ripFamilyAttributeValue)
	dp.Attributes().PutStr("rip_port", ripPortAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIpvsDestinationPacketOutRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIpvsDestinationPacketOutRate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIpvsDestinationPacketOutRate(cfg MetricConfig) metricIpvsDestinationPacketOutRate {
	m := metricIpvsDestinationPacketOutRate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricIpvsDestinationPacketOutTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills ipvs.destination.packet.out.total metric with initial data.
func (m *metricIpvsDestinationPacketOutTotal) init() {
	m.data.SetName("ipvs.destination.packet.out.total")
	m.data.SetDescription("Cumulative number of outgoing packets from the destination.")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricIpvsDestinationPacketOutTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string, ripAddressAttributeValue string, ripFamilyAttributeValue string, ripPortAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sched", schedAttributeValue)
	dp.Attributes().PutStr("netmask", netmaskAttributeValue)
	dp.Attributes().PutStr("protocol", protocolAttributeValue)
	dp.Attributes().PutStr("vip_address", vipAddressAttributeValue)
	dp.Attributes().PutStr("vip_family", vipFamilyAttributeValue)
	dp.Attributes().PutStr("vip_port", vipPortAttributeValue)
	dp.Attributes().PutStr("rip_address", ripAddressAttributeValue)
	dp.Attributes().PutStr("rip_family", ripFamilyAttributeValue)
	dp.Attributes().PutStr("rip_port", ripPortAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIpvsDestinationPacketOutTotal) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIpvsDestinationPacketOutTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIpvsDestinationPacketOutTotal(cfg MetricConfig) metricIpvsDestinationPacketOutTotal {
	m := metricIpvsDestinationPacketOutTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricIpvsServiceConnectionRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills ipvs.service.connection.rate metric with initial data.
func (m *metricIpvsServiceConnectionRate) init() {
	m.data.SetName("ipvs.service.connection.rate")
	m.data.SetDescription("Current connection rate (connections per second) for the service.")
	m.data.SetUnit("1/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricIpvsServiceConnectionRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sched", schedAttributeValue)
	dp.Attributes().PutStr("netmask", netmaskAttributeValue)
	dp.Attributes().PutStr("protocol", protocolAttributeValue)
	dp.Attributes().PutStr("vip_address", vipAddressAttributeValue)
	dp.Attributes().PutStr("vip_family", vipFamilyAttributeValue)
	dp.Attributes().PutStr("vip_port", vipPortAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIpvsServiceConnectionRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIpvsServiceConnectionRate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIpvsServiceConnectionRate(cfg MetricConfig) metricIpvsServiceConnectionRate {
	m := metricIpvsServiceConnectionRate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricIpvsServiceConnectionTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills ipvs.service.connection.total metric with initial data.
func (m *metricIpvsServiceConnectionTotal) init() {
	m.data.SetName("ipvs.service.connection.total")
	m.data.SetDescription("Cumulative number of connections for the service.")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricIpvsServiceConnectionTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sched", schedAttributeValue)
	dp.Attributes().PutStr("netmask", netmaskAttributeValue)
	dp.Attributes().PutStr("protocol", protocolAttributeValue)
	dp.Attributes().PutStr("vip_address", vipAddressAttributeValue)
	dp.Attributes().PutStr("vip_family", vipFamilyAttributeValue)
	dp.Attributes().PutStr("vip_port", vipPortAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIpvsServiceConnectionTotal) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIpvsServiceConnectionTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIpvsServiceConnectionTotal(cfg MetricConfig) metricIpvsServiceConnectionTotal {
	m := metricIpvsServiceConnectionTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricIpvsServiceInRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills ipvs.service.in.rate metric with initial data.
func (m *metricIpvsServiceInRate) init() {
	m.data.SetName("ipvs.service.in.rate")
	m.data.SetDescription("Current incoming bytes rate (bytes per second) for the service.")
	m.data.SetUnit("By/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricIpvsServiceInRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sched", schedAttributeValue)
	dp.Attributes().PutStr("netmask", netmaskAttributeValue)
	dp.Attributes().PutStr("protocol", protocolAttributeValue)
	dp.Attributes().PutStr("vip_address", vipAddressAttributeValue)
	dp.Attributes().PutStr("vip_family", vipFamilyAttributeValue)
	dp.Attributes().PutStr("vip_port", vipPortAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIpvsServiceInRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIpvsServiceInRate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIpvsServiceInRate(cfg MetricConfig) metricIpvsServiceInRate {
	m := metricIpvsServiceInRate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricIpvsServiceInTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills ipvs.service.in.total metric with initial data.
func (m *metricIpvsServiceInTotal) init() {
	m.data.SetName("ipvs.service.in.total")
	m.data.SetDescription("Cumulative number of incoming bytes for the service.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricIpvsServiceInTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sched", schedAttributeValue)
	dp.Attributes().PutStr("netmask", netmaskAttributeValue)
	dp.Attributes().PutStr("protocol", protocolAttributeValue)
	dp.Attributes().PutStr("vip_address", vipAddressAttributeValue)
	dp.Attributes().PutStr("vip_family", vipFamilyAttributeValue)
	dp.Attributes().PutStr("vip_port", vipPortAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIpvsServiceInTotal) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIpvsServiceInTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIpvsServiceInTotal(cfg MetricConfig) metricIpvsServiceInTotal {
	m := metricIpvsServiceInTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricIpvsServiceOutRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills ipvs.service.out.rate metric with initial data.
func (m *metricIpvsServiceOutRate) init() {
	m.data.SetName("ipvs.service.out.rate")
	m.data.SetDescription("Current outgoing bytes rate (bytes per second) for the service.")
	m.data.SetUnit("By/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricIpvsServiceOutRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sched", schedAttributeValue)
	dp.Attributes().PutStr("netmask", netmaskAttributeValue)
	dp.Attributes().PutStr("protocol", protocolAttributeValue)
	dp.Attributes().PutStr("vip_address", vipAddressAttributeValue)
	dp.Attributes().PutStr("vip_family", vipFamilyAttributeValue)
	dp.Attributes().PutStr("vip_port", vipPortAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIpvsServiceOutRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIpvsServiceOutRate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIpvsServiceOutRate(cfg MetricConfig) metricIpvsServiceOutRate {
	m := metricIpvsServiceOutRate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricIpvsServiceOutTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills ipvs.service.out.total metric with initial data.
func (m *metricIpvsServiceOutTotal) init() {
	m.data.SetName("ipvs.service.out.total")
	m.data.SetDescription("Cumulative number of outgoing bytes for the service.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricIpvsServiceOutTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sched", schedAttributeValue)
	dp.Attributes().PutStr("netmask", netmaskAttributeValue)
	dp.Attributes().PutStr("protocol", protocolAttributeValue)
	dp.Attributes().PutStr("vip_address", vipAddressAttributeValue)
	dp.Attributes().PutStr("vip_family", vipFamilyAttributeValue)
	dp.Attributes().PutStr("vip_port", vipPortAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIpvsServiceOutTotal) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIpvsServiceOutTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIpvsServiceOutTotal(cfg MetricConfig) metricIpvsServiceOutTotal {
	m := metricIpvsServiceOutTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricIpvsServicePacketInRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills ipvs.service.packet.in.rate metric with initial data.
func (m *metricIpvsServicePacketInRate) init() {
	m.data.SetName("ipvs.service.packet.in.rate")
	m.data.SetDescription("Current incoming packet rate (packets per second) for the service.")
	m.data.SetUnit("1/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricIpvsServicePacketInRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sched", schedAttributeValue)
	dp.Attributes().PutStr("netmask", netmaskAttributeValue)
	dp.Attributes().PutStr("protocol", protocolAttributeValue)
	dp.Attributes().PutStr("vip_address", vipAddressAttributeValue)
	dp.Attributes().PutStr("vip_family", vipFamilyAttributeValue)
	dp.Attributes().PutStr("vip_port", vipPortAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIpvsServicePacketInRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIpvsServicePacketInRate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIpvsServicePacketInRate(cfg MetricConfig) metricIpvsServicePacketInRate {
	m := metricIpvsServicePacketInRate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricIpvsServicePacketInTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills ipvs.service.packet.in.total metric with initial data.
func (m *metricIpvsServicePacketInTotal) init() {
	m.data.SetName("ipvs.service.packet.in.total")
	m.data.SetDescription("Cumulative number of incoming packets for the service.")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricIpvsServicePacketInTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sched", schedAttributeValue)
	dp.Attributes().PutStr("netmask", netmaskAttributeValue)
	dp.Attributes().PutStr("protocol", protocolAttributeValue)
	dp.Attributes().PutStr("vip_address", vipAddressAttributeValue)
	dp.Attributes().PutStr("vip_family", vipFamilyAttributeValue)
	dp.Attributes().PutStr("vip_port", vipPortAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIpvsServicePacketInTotal) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIpvsServicePacketInTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIpvsServicePacketInTotal(cfg MetricConfig) metricIpvsServicePacketInTotal {
	m := metricIpvsServicePacketInTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricIpvsServicePacketOutRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills ipvs.service.packet.out.rate metric with initial data.
func (m *metricIpvsServicePacketOutRate) init() {
	m.data.SetName("ipvs.service.packet.out.rate")
	m.data.SetDescription("Current outgoing packet rate (packets per second) for the service.")
	m.data.SetUnit("1/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricIpvsServicePacketOutRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sched", schedAttributeValue)
	dp.Attributes().PutStr("netmask", netmaskAttributeValue)
	dp.Attributes().PutStr("protocol", protocolAttributeValue)
	dp.Attributes().PutStr("vip_address", vipAddressAttributeValue)
	dp.Attributes().PutStr("vip_family", vipFamilyAttributeValue)
	dp.Attributes().PutStr("vip_port", vipPortAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIpvsServicePacketOutRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIpvsServicePacketOutRate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIpvsServicePacketOutRate(cfg MetricConfig) metricIpvsServicePacketOutRate {
	m := metricIpvsServicePacketOutRate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricIpvsServicePacketOutTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills ipvs.service.packet.out.total metric with initial data.
func (m *metricIpvsServicePacketOutTotal) init() {
	m.data.SetName("ipvs.service.packet.out.total")
	m.data.SetDescription("Cumulative number of outgoing packets for the service.")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricIpvsServicePacketOutTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sched", schedAttributeValue)
	dp.Attributes().PutStr("netmask", netmaskAttributeValue)
	dp.Attributes().PutStr("protocol", protocolAttributeValue)
	dp.Attributes().PutStr("vip_address", vipAddressAttributeValue)
	dp.Attributes().PutStr("vip_family", vipFamilyAttributeValue)
	dp.Attributes().PutStr("vip_port", vipPortAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIpvsServicePacketOutTotal) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIpvsServicePacketOutTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIpvsServicePacketOutTotal(cfg MetricConfig) metricIpvsServicePacketOutTotal {
	m := metricIpvsServicePacketOutTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user config.
type MetricsBuilder struct {
	config                                       MetricsBuilderConfig // config of the metrics builder.
	startTime                                    pcommon.Timestamp    // start time that will be applied to all recorded data points.
	metricsCapacity                              int                  // maximum observed number of metrics per resource.
	metricsBuffer                                pmetric.Metrics      // accumulates metrics data before emitting.
	buildInfo                                    component.BuildInfo  // contains version information.
	metricIpvsDestinationConnectionActiveCount   metricIpvsDestinationConnectionActiveCount
	metricIpvsDestinationConnectionInactiveCount metricIpvsDestinationConnectionInactiveCount
	metricIpvsDestinationConnectionRate          metricIpvsDestinationConnectionRate
	metricIpvsDestinationConnectionTotal         metricIpvsDestinationConnectionTotal
	metricIpvsDestinationConnectionWeight        metricIpvsDestinationConnectionWeight
	metricIpvsDestinationInRate                  metricIpvsDestinationInRate
	metricIpvsDestinationInTotal                 metricIpvsDestinationInTotal
	metricIpvsDestinationOutRate                 metricIpvsDestinationOutRate
	metricIpvsDestinationOutTotal                metricIpvsDestinationOutTotal
	metricIpvsDestinationPacketInRate            metricIpvsDestinationPacketInRate
	metricIpvsDestinationPacketInTotal           metricIpvsDestinationPacketInTotal
	metricIpvsDestinationPacketOutRate           metricIpvsDestinationPacketOutRate
	metricIpvsDestinationPacketOutTotal          metricIpvsDestinationPacketOutTotal
	metricIpvsServiceConnectionRate              metricIpvsServiceConnectionRate
	metricIpvsServiceConnectionTotal             metricIpvsServiceConnectionTotal
	metricIpvsServiceInRate                      metricIpvsServiceInRate
	metricIpvsServiceInTotal                     metricIpvsServiceInTotal
	metricIpvsServiceOutRate                     metricIpvsServiceOutRate
	metricIpvsServiceOutTotal                    metricIpvsServiceOutTotal
	metricIpvsServicePacketInRate                metricIpvsServicePacketInRate
	metricIpvsServicePacketInTotal               metricIpvsServicePacketInTotal
	metricIpvsServicePacketOutRate               metricIpvsServicePacketOutRate
	metricIpvsServicePacketOutTotal              metricIpvsServicePacketOutTotal
}

// MetricBuilderOption applies changes to default metrics builder.
type MetricBuilderOption interface {
	apply(*MetricsBuilder)
}

type metricBuilderOptionFunc func(mb *MetricsBuilder)

func (mbof metricBuilderOptionFunc) apply(mb *MetricsBuilder) {
	mbof(mb)
}

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) MetricBuilderOption {
	return metricBuilderOptionFunc(func(mb *MetricsBuilder) {
		mb.startTime = startTime
	})
}
func NewMetricsBuilder(mbc MetricsBuilderConfig, settings receiver.Settings, options ...MetricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		config:        mbc,
		startTime:     pcommon.NewTimestampFromTime(time.Now()),
		metricsBuffer: pmetric.NewMetrics(),
		buildInfo:     settings.BuildInfo,
		metricIpvsDestinationConnectionActiveCount:   newMetricIpvsDestinationConnectionActiveCount(mbc.Metrics.IpvsDestinationConnectionActiveCount),
		metricIpvsDestinationConnectionInactiveCount: newMetricIpvsDestinationConnectionInactiveCount(mbc.Metrics.IpvsDestinationConnectionInactiveCount),
		metricIpvsDestinationConnectionRate:          newMetricIpvsDestinationConnectionRate(mbc.Metrics.IpvsDestinationConnectionRate),
		metricIpvsDestinationConnectionTotal:         newMetricIpvsDestinationConnectionTotal(mbc.Metrics.IpvsDestinationConnectionTotal),
		metricIpvsDestinationConnectionWeight:        newMetricIpvsDestinationConnectionWeight(mbc.Metrics.IpvsDestinationConnectionWeight),
		metricIpvsDestinationInRate:                  newMetricIpvsDestinationInRate(mbc.Metrics.IpvsDestinationInRate),
		metricIpvsDestinationInTotal:                 newMetricIpvsDestinationInTotal(mbc.Metrics.IpvsDestinationInTotal),
		metricIpvsDestinationOutRate:                 newMetricIpvsDestinationOutRate(mbc.Metrics.IpvsDestinationOutRate),
		metricIpvsDestinationOutTotal:                newMetricIpvsDestinationOutTotal(mbc.Metrics.IpvsDestinationOutTotal),
		metricIpvsDestinationPacketInRate:            newMetricIpvsDestinationPacketInRate(mbc.Metrics.IpvsDestinationPacketInRate),
		metricIpvsDestinationPacketInTotal:           newMetricIpvsDestinationPacketInTotal(mbc.Metrics.IpvsDestinationPacketInTotal),
		metricIpvsDestinationPacketOutRate:           newMetricIpvsDestinationPacketOutRate(mbc.Metrics.IpvsDestinationPacketOutRate),
		metricIpvsDestinationPacketOutTotal:          newMetricIpvsDestinationPacketOutTotal(mbc.Metrics.IpvsDestinationPacketOutTotal),
		metricIpvsServiceConnectionRate:              newMetricIpvsServiceConnectionRate(mbc.Metrics.IpvsServiceConnectionRate),
		metricIpvsServiceConnectionTotal:             newMetricIpvsServiceConnectionTotal(mbc.Metrics.IpvsServiceConnectionTotal),
		metricIpvsServiceInRate:                      newMetricIpvsServiceInRate(mbc.Metrics.IpvsServiceInRate),
		metricIpvsServiceInTotal:                     newMetricIpvsServiceInTotal(mbc.Metrics.IpvsServiceInTotal),
		metricIpvsServiceOutRate:                     newMetricIpvsServiceOutRate(mbc.Metrics.IpvsServiceOutRate),
		metricIpvsServiceOutTotal:                    newMetricIpvsServiceOutTotal(mbc.Metrics.IpvsServiceOutTotal),
		metricIpvsServicePacketInRate:                newMetricIpvsServicePacketInRate(mbc.Metrics.IpvsServicePacketInRate),
		metricIpvsServicePacketInTotal:               newMetricIpvsServicePacketInTotal(mbc.Metrics.IpvsServicePacketInTotal),
		metricIpvsServicePacketOutRate:               newMetricIpvsServicePacketOutRate(mbc.Metrics.IpvsServicePacketOutRate),
		metricIpvsServicePacketOutTotal:              newMetricIpvsServicePacketOutTotal(mbc.Metrics.IpvsServicePacketOutTotal),
	}

	for _, op := range options {
		op.apply(mb)
	}
	return mb
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (mb *MetricsBuilder) updateCapacity(rm pmetric.ResourceMetrics) {
	if mb.metricsCapacity < rm.ScopeMetrics().At(0).Metrics().Len() {
		mb.metricsCapacity = rm.ScopeMetrics().At(0).Metrics().Len()
	}
}

// ResourceMetricsOption applies changes to provided resource metrics.
type ResourceMetricsOption interface {
	apply(pmetric.ResourceMetrics)
}

type resourceMetricsOptionFunc func(pmetric.ResourceMetrics)

func (rmof resourceMetricsOptionFunc) apply(rm pmetric.ResourceMetrics) {
	rmof(rm)
}

// WithResource sets the provided resource on the emitted ResourceMetrics.
// It's recommended to use ResourceBuilder to create the resource.
func WithResource(res pcommon.Resource) ResourceMetricsOption {
	return resourceMetricsOptionFunc(func(rm pmetric.ResourceMetrics) {
		res.CopyTo(rm.Resource())
	})
}

// WithStartTimeOverride overrides start time for all the resource metrics data points.
// This option should be only used if different start time has to be set on metrics coming from different resources.
func WithStartTimeOverride(start pcommon.Timestamp) ResourceMetricsOption {
	return resourceMetricsOptionFunc(func(rm pmetric.ResourceMetrics) {
		var dps pmetric.NumberDataPointSlice
		metrics := rm.ScopeMetrics().At(0).Metrics()
		for i := 0; i < metrics.Len(); i++ {
			switch metrics.At(i).Type() {
			case pmetric.MetricTypeGauge:
				dps = metrics.At(i).Gauge().DataPoints()
			case pmetric.MetricTypeSum:
				dps = metrics.At(i).Sum().DataPoints()
			}
			for j := 0; j < dps.Len(); j++ {
				dps.At(j).SetStartTimestamp(start)
			}
		}
	})
}

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead.
// Resource attributes should be provided as ResourceMetricsOption arguments.
func (mb *MetricsBuilder) EmitForResource(options ...ResourceMetricsOption) {
	rm := pmetric.NewResourceMetrics()
	ils := rm.ScopeMetrics().AppendEmpty()
	ils.Scope().SetName(ScopeName)
	ils.Scope().SetVersion(mb.buildInfo.Version)
	ils.Metrics().EnsureCapacity(mb.metricsCapacity)
	mb.metricIpvsDestinationConnectionActiveCount.emit(ils.Metrics())
	mb.metricIpvsDestinationConnectionInactiveCount.emit(ils.Metrics())
	mb.metricIpvsDestinationConnectionRate.emit(ils.Metrics())
	mb.metricIpvsDestinationConnectionTotal.emit(ils.Metrics())
	mb.metricIpvsDestinationConnectionWeight.emit(ils.Metrics())
	mb.metricIpvsDestinationInRate.emit(ils.Metrics())
	mb.metricIpvsDestinationInTotal.emit(ils.Metrics())
	mb.metricIpvsDestinationOutRate.emit(ils.Metrics())
	mb.metricIpvsDestinationOutTotal.emit(ils.Metrics())
	mb.metricIpvsDestinationPacketInRate.emit(ils.Metrics())
	mb.metricIpvsDestinationPacketInTotal.emit(ils.Metrics())
	mb.metricIpvsDestinationPacketOutRate.emit(ils.Metrics())
	mb.metricIpvsDestinationPacketOutTotal.emit(ils.Metrics())
	mb.metricIpvsServiceConnectionRate.emit(ils.Metrics())
	mb.metricIpvsServiceConnectionTotal.emit(ils.Metrics())
	mb.metricIpvsServiceInRate.emit(ils.Metrics())
	mb.metricIpvsServiceInTotal.emit(ils.Metrics())
	mb.metricIpvsServiceOutRate.emit(ils.Metrics())
	mb.metricIpvsServiceOutTotal.emit(ils.Metrics())
	mb.metricIpvsServicePacketInRate.emit(ils.Metrics())
	mb.metricIpvsServicePacketInTotal.emit(ils.Metrics())
	mb.metricIpvsServicePacketOutRate.emit(ils.Metrics())
	mb.metricIpvsServicePacketOutTotal.emit(ils.Metrics())

	for _, op := range options {
		op.apply(rm)
	}

	if ils.Metrics().Len() > 0 {
		mb.updateCapacity(rm)
		rm.MoveTo(mb.metricsBuffer.ResourceMetrics().AppendEmpty())
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user config, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit(options ...ResourceMetricsOption) pmetric.Metrics {
	mb.EmitForResource(options...)
	metrics := mb.metricsBuffer
	mb.metricsBuffer = pmetric.NewMetrics()
	return metrics
}

// RecordIpvsDestinationConnectionActiveCountDataPoint adds a data point to ipvs.destination.connection.active.count metric.
func (mb *MetricsBuilder) RecordIpvsDestinationConnectionActiveCountDataPoint(ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string, ripAddressAttributeValue string, ripFamilyAttributeValue string, ripPortAttributeValue string) {
	mb.metricIpvsDestinationConnectionActiveCount.recordDataPoint(mb.startTime, ts, val, schedAttributeValue, netmaskAttributeValue, protocolAttributeValue, vipAddressAttributeValue, vipFamilyAttributeValue, vipPortAttributeValue, ripAddressAttributeValue, ripFamilyAttributeValue, ripPortAttributeValue)
}

// RecordIpvsDestinationConnectionInactiveCountDataPoint adds a data point to ipvs.destination.connection.inactive.count metric.
func (mb *MetricsBuilder) RecordIpvsDestinationConnectionInactiveCountDataPoint(ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string, ripAddressAttributeValue string, ripFamilyAttributeValue string, ripPortAttributeValue string) {
	mb.metricIpvsDestinationConnectionInactiveCount.recordDataPoint(mb.startTime, ts, val, schedAttributeValue, netmaskAttributeValue, protocolAttributeValue, vipAddressAttributeValue, vipFamilyAttributeValue, vipPortAttributeValue, ripAddressAttributeValue, ripFamilyAttributeValue, ripPortAttributeValue)
}

// RecordIpvsDestinationConnectionRateDataPoint adds a data point to ipvs.destination.connection.rate metric.
func (mb *MetricsBuilder) RecordIpvsDestinationConnectionRateDataPoint(ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string, ripAddressAttributeValue string, ripFamilyAttributeValue string, ripPortAttributeValue string) {
	mb.metricIpvsDestinationConnectionRate.recordDataPoint(mb.startTime, ts, val, schedAttributeValue, netmaskAttributeValue, protocolAttributeValue, vipAddressAttributeValue, vipFamilyAttributeValue, vipPortAttributeValue, ripAddressAttributeValue, ripFamilyAttributeValue, ripPortAttributeValue)
}

// RecordIpvsDestinationConnectionTotalDataPoint adds a data point to ipvs.destination.connection.total metric.
func (mb *MetricsBuilder) RecordIpvsDestinationConnectionTotalDataPoint(ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string, ripAddressAttributeValue string, ripFamilyAttributeValue string, ripPortAttributeValue string) {
	mb.metricIpvsDestinationConnectionTotal.recordDataPoint(mb.startTime, ts, val, schedAttributeValue, netmaskAttributeValue, protocolAttributeValue, vipAddressAttributeValue, vipFamilyAttributeValue, vipPortAttributeValue, ripAddressAttributeValue, ripFamilyAttributeValue, ripPortAttributeValue)
}

// RecordIpvsDestinationConnectionWeightDataPoint adds a data point to ipvs.destination.connection.weight metric.
func (mb *MetricsBuilder) RecordIpvsDestinationConnectionWeightDataPoint(ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string, ripAddressAttributeValue string, ripFamilyAttributeValue string, ripPortAttributeValue string) {
	mb.metricIpvsDestinationConnectionWeight.recordDataPoint(mb.startTime, ts, val, schedAttributeValue, netmaskAttributeValue, protocolAttributeValue, vipAddressAttributeValue, vipFamilyAttributeValue, vipPortAttributeValue, ripAddressAttributeValue, ripFamilyAttributeValue, ripPortAttributeValue)
}

// RecordIpvsDestinationInRateDataPoint adds a data point to ipvs.destination.in.rate metric.
func (mb *MetricsBuilder) RecordIpvsDestinationInRateDataPoint(ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string, ripAddressAttributeValue string, ripFamilyAttributeValue string, ripPortAttributeValue string) {
	mb.metricIpvsDestinationInRate.recordDataPoint(mb.startTime, ts, val, schedAttributeValue, netmaskAttributeValue, protocolAttributeValue, vipAddressAttributeValue, vipFamilyAttributeValue, vipPortAttributeValue, ripAddressAttributeValue, ripFamilyAttributeValue, ripPortAttributeValue)
}

// RecordIpvsDestinationInTotalDataPoint adds a data point to ipvs.destination.in.total metric.
func (mb *MetricsBuilder) RecordIpvsDestinationInTotalDataPoint(ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string, ripAddressAttributeValue string, ripFamilyAttributeValue string, ripPortAttributeValue string) {
	mb.metricIpvsDestinationInTotal.recordDataPoint(mb.startTime, ts, val, schedAttributeValue, netmaskAttributeValue, protocolAttributeValue, vipAddressAttributeValue, vipFamilyAttributeValue, vipPortAttributeValue, ripAddressAttributeValue, ripFamilyAttributeValue, ripPortAttributeValue)
}

// RecordIpvsDestinationOutRateDataPoint adds a data point to ipvs.destination.out.rate metric.
func (mb *MetricsBuilder) RecordIpvsDestinationOutRateDataPoint(ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string, ripAddressAttributeValue string, ripFamilyAttributeValue string, ripPortAttributeValue string) {
	mb.metricIpvsDestinationOutRate.recordDataPoint(mb.startTime, ts, val, schedAttributeValue, netmaskAttributeValue, protocolAttributeValue, vipAddressAttributeValue, vipFamilyAttributeValue, vipPortAttributeValue, ripAddressAttributeValue, ripFamilyAttributeValue, ripPortAttributeValue)
}

// RecordIpvsDestinationOutTotalDataPoint adds a data point to ipvs.destination.out.total metric.
func (mb *MetricsBuilder) RecordIpvsDestinationOutTotalDataPoint(ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string, ripAddressAttributeValue string, ripFamilyAttributeValue string, ripPortAttributeValue string) {
	mb.metricIpvsDestinationOutTotal.recordDataPoint(mb.startTime, ts, val, schedAttributeValue, netmaskAttributeValue, protocolAttributeValue, vipAddressAttributeValue, vipFamilyAttributeValue, vipPortAttributeValue, ripAddressAttributeValue, ripFamilyAttributeValue, ripPortAttributeValue)
}

// RecordIpvsDestinationPacketInRateDataPoint adds a data point to ipvs.destination.packet.in.rate metric.
func (mb *MetricsBuilder) RecordIpvsDestinationPacketInRateDataPoint(ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string, ripAddressAttributeValue string, ripFamilyAttributeValue string, ripPortAttributeValue string) {
	mb.metricIpvsDestinationPacketInRate.recordDataPoint(mb.startTime, ts, val, schedAttributeValue, netmaskAttributeValue, protocolAttributeValue, vipAddressAttributeValue, vipFamilyAttributeValue, vipPortAttributeValue, ripAddressAttributeValue, ripFamilyAttributeValue, ripPortAttributeValue)
}

// RecordIpvsDestinationPacketInTotalDataPoint adds a data point to ipvs.destination.packet.in.total metric.
func (mb *MetricsBuilder) RecordIpvsDestinationPacketInTotalDataPoint(ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string, ripAddressAttributeValue string, ripFamilyAttributeValue string, ripPortAttributeValue string) {
	mb.metricIpvsDestinationPacketInTotal.recordDataPoint(mb.startTime, ts, val, schedAttributeValue, netmaskAttributeValue, protocolAttributeValue, vipAddressAttributeValue, vipFamilyAttributeValue, vipPortAttributeValue, ripAddressAttributeValue, ripFamilyAttributeValue, ripPortAttributeValue)
}

// RecordIpvsDestinationPacketOutRateDataPoint adds a data point to ipvs.destination.packet.out.rate metric.
func (mb *MetricsBuilder) RecordIpvsDestinationPacketOutRateDataPoint(ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string, ripAddressAttributeValue string, ripFamilyAttributeValue string, ripPortAttributeValue string) {
	mb.metricIpvsDestinationPacketOutRate.recordDataPoint(mb.startTime, ts, val, schedAttributeValue, netmaskAttributeValue, protocolAttributeValue, vipAddressAttributeValue, vipFamilyAttributeValue, vipPortAttributeValue, ripAddressAttributeValue, ripFamilyAttributeValue, ripPortAttributeValue)
}

// RecordIpvsDestinationPacketOutTotalDataPoint adds a data point to ipvs.destination.packet.out.total metric.
func (mb *MetricsBuilder) RecordIpvsDestinationPacketOutTotalDataPoint(ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string, ripAddressAttributeValue string, ripFamilyAttributeValue string, ripPortAttributeValue string) {
	mb.metricIpvsDestinationPacketOutTotal.recordDataPoint(mb.startTime, ts, val, schedAttributeValue, netmaskAttributeValue, protocolAttributeValue, vipAddressAttributeValue, vipFamilyAttributeValue, vipPortAttributeValue, ripAddressAttributeValue, ripFamilyAttributeValue, ripPortAttributeValue)
}

// RecordIpvsServiceConnectionRateDataPoint adds a data point to ipvs.service.connection.rate metric.
func (mb *MetricsBuilder) RecordIpvsServiceConnectionRateDataPoint(ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string) {
	mb.metricIpvsServiceConnectionRate.recordDataPoint(mb.startTime, ts, val, schedAttributeValue, netmaskAttributeValue, protocolAttributeValue, vipAddressAttributeValue, vipFamilyAttributeValue, vipPortAttributeValue)
}

// RecordIpvsServiceConnectionTotalDataPoint adds a data point to ipvs.service.connection.total metric.
func (mb *MetricsBuilder) RecordIpvsServiceConnectionTotalDataPoint(ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string) {
	mb.metricIpvsServiceConnectionTotal.recordDataPoint(mb.startTime, ts, val, schedAttributeValue, netmaskAttributeValue, protocolAttributeValue, vipAddressAttributeValue, vipFamilyAttributeValue, vipPortAttributeValue)
}

// RecordIpvsServiceInRateDataPoint adds a data point to ipvs.service.in.rate metric.
func (mb *MetricsBuilder) RecordIpvsServiceInRateDataPoint(ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string) {
	mb.metricIpvsServiceInRate.recordDataPoint(mb.startTime, ts, val, schedAttributeValue, netmaskAttributeValue, protocolAttributeValue, vipAddressAttributeValue, vipFamilyAttributeValue, vipPortAttributeValue)
}

// RecordIpvsServiceInTotalDataPoint adds a data point to ipvs.service.in.total metric.
func (mb *MetricsBuilder) RecordIpvsServiceInTotalDataPoint(ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string) {
	mb.metricIpvsServiceInTotal.recordDataPoint(mb.startTime, ts, val, schedAttributeValue, netmaskAttributeValue, protocolAttributeValue, vipAddressAttributeValue, vipFamilyAttributeValue, vipPortAttributeValue)
}

// RecordIpvsServiceOutRateDataPoint adds a data point to ipvs.service.out.rate metric.
func (mb *MetricsBuilder) RecordIpvsServiceOutRateDataPoint(ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string) {
	mb.metricIpvsServiceOutRate.recordDataPoint(mb.startTime, ts, val, schedAttributeValue, netmaskAttributeValue, protocolAttributeValue, vipAddressAttributeValue, vipFamilyAttributeValue, vipPortAttributeValue)
}

// RecordIpvsServiceOutTotalDataPoint adds a data point to ipvs.service.out.total metric.
func (mb *MetricsBuilder) RecordIpvsServiceOutTotalDataPoint(ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string) {
	mb.metricIpvsServiceOutTotal.recordDataPoint(mb.startTime, ts, val, schedAttributeValue, netmaskAttributeValue, protocolAttributeValue, vipAddressAttributeValue, vipFamilyAttributeValue, vipPortAttributeValue)
}

// RecordIpvsServicePacketInRateDataPoint adds a data point to ipvs.service.packet.in.rate metric.
func (mb *MetricsBuilder) RecordIpvsServicePacketInRateDataPoint(ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string) {
	mb.metricIpvsServicePacketInRate.recordDataPoint(mb.startTime, ts, val, schedAttributeValue, netmaskAttributeValue, protocolAttributeValue, vipAddressAttributeValue, vipFamilyAttributeValue, vipPortAttributeValue)
}

// RecordIpvsServicePacketInTotalDataPoint adds a data point to ipvs.service.packet.in.total metric.
func (mb *MetricsBuilder) RecordIpvsServicePacketInTotalDataPoint(ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string) {
	mb.metricIpvsServicePacketInTotal.recordDataPoint(mb.startTime, ts, val, schedAttributeValue, netmaskAttributeValue, protocolAttributeValue, vipAddressAttributeValue, vipFamilyAttributeValue, vipPortAttributeValue)
}

// RecordIpvsServicePacketOutRateDataPoint adds a data point to ipvs.service.packet.out.rate metric.
func (mb *MetricsBuilder) RecordIpvsServicePacketOutRateDataPoint(ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string) {
	mb.metricIpvsServicePacketOutRate.recordDataPoint(mb.startTime, ts, val, schedAttributeValue, netmaskAttributeValue, protocolAttributeValue, vipAddressAttributeValue, vipFamilyAttributeValue, vipPortAttributeValue)
}

// RecordIpvsServicePacketOutTotalDataPoint adds a data point to ipvs.service.packet.out.total metric.
func (mb *MetricsBuilder) RecordIpvsServicePacketOutTotalDataPoint(ts pcommon.Timestamp, val int64, schedAttributeValue string, netmaskAttributeValue string, protocolAttributeValue string, vipAddressAttributeValue string, vipFamilyAttributeValue string, vipPortAttributeValue string) {
	mb.metricIpvsServicePacketOutTotal.recordDataPoint(mb.startTime, ts, val, schedAttributeValue, netmaskAttributeValue, protocolAttributeValue, vipAddressAttributeValue, vipFamilyAttributeValue, vipPortAttributeValue)
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...MetricBuilderOption) {
	mb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op.apply(mb)
	}
}
