// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
)

// MetricSettings provides common settings for a particular metric.
type MetricSettings struct {
	Enabled bool `mapstructure:"enabled"`
}

// MetricsSettings provides settings for oracledbreceiver metrics.
type MetricsSettings struct {
	OracledbSessionCPUUsage          MetricSettings `mapstructure:"oracledb.session.cpu_usage"`
	OracledbSessionEnqueueDeadlocks  MetricSettings `mapstructure:"oracledb.session.enqueue_deadlocks"`
	OracledbSessionExchangeDeadlocks MetricSettings `mapstructure:"oracledb.session.exchange_deadlocks"`
	OracledbSessionExecuteCount      MetricSettings `mapstructure:"oracledb.session.execute_count"`
	OracledbSessionHardParses        MetricSettings `mapstructure:"oracledb.session.hard_parses"`
	OracledbSessionLogicalReads      MetricSettings `mapstructure:"oracledb.session.logical_reads"`
	OracledbSessionParseCountTotal   MetricSettings `mapstructure:"oracledb.session.parse_count_total"`
	OracledbSessionPgaMemory         MetricSettings `mapstructure:"oracledb.session.pga_memory"`
	OracledbSessionPhysicalReads     MetricSettings `mapstructure:"oracledb.session.physical_reads"`
	OracledbSessionSoftParses        MetricSettings `mapstructure:"oracledb.session.soft_parses"`
	OracledbSessionUserCommits       MetricSettings `mapstructure:"oracledb.session.user_commits"`
	OracledbSessionUserRollbacks     MetricSettings `mapstructure:"oracledb.session.user_rollbacks"`
	OracledbSystemResourceLimits     MetricSettings `mapstructure:"oracledb.system.resource_limits"`
	OracledbSystemSessionCount       MetricSettings `mapstructure:"oracledb.system.session_count"`
	OracledbTablespaceMaxSize        MetricSettings `mapstructure:"oracledb.tablespace.max_size"`
	OracledbTablespaceSize           MetricSettings `mapstructure:"oracledb.tablespace.size"`
}

func DefaultMetricsSettings() MetricsSettings {
	return MetricsSettings{
		OracledbSessionCPUUsage: MetricSettings{
			Enabled: true,
		},
		OracledbSessionEnqueueDeadlocks: MetricSettings{
			Enabled: true,
		},
		OracledbSessionExchangeDeadlocks: MetricSettings{
			Enabled: true,
		},
		OracledbSessionExecuteCount: MetricSettings{
			Enabled: true,
		},
		OracledbSessionHardParses: MetricSettings{
			Enabled: true,
		},
		OracledbSessionLogicalReads: MetricSettings{
			Enabled: true,
		},
		OracledbSessionParseCountTotal: MetricSettings{
			Enabled: true,
		},
		OracledbSessionPgaMemory: MetricSettings{
			Enabled: true,
		},
		OracledbSessionPhysicalReads: MetricSettings{
			Enabled: true,
		},
		OracledbSessionSoftParses: MetricSettings{
			Enabled: true,
		},
		OracledbSessionUserCommits: MetricSettings{
			Enabled: true,
		},
		OracledbSessionUserRollbacks: MetricSettings{
			Enabled: true,
		},
		OracledbSystemResourceLimits: MetricSettings{
			Enabled: true,
		},
		OracledbSystemSessionCount: MetricSettings{
			Enabled: true,
		},
		OracledbTablespaceMaxSize: MetricSettings{
			Enabled: true,
		},
		OracledbTablespaceSize: MetricSettings{
			Enabled: true,
		},
	}
}

type metricOracledbSessionCPUUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.session.cpu_usage metric with initial data.
func (m *metricOracledbSessionCPUUsage) init() {
	m.data.SetName("oracledb.session.cpu_usage")
	m.data.SetDescription("CPU usage (%)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricOracledbSessionCPUUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbSessionCPUUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbSessionCPUUsage) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbSessionCPUUsage(settings MetricSettings) metricOracledbSessionCPUUsage {
	m := metricOracledbSessionCPUUsage{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbSessionEnqueueDeadlocks struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.session.enqueue_deadlocks metric with initial data.
func (m *metricOracledbSessionEnqueueDeadlocks) init() {
	m.data.SetName("oracledb.session.enqueue_deadlocks")
	m.data.SetDescription("Total number of deadlocks between table or row locks in different sessions.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricOracledbSessionEnqueueDeadlocks) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbSessionEnqueueDeadlocks) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbSessionEnqueueDeadlocks) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbSessionEnqueueDeadlocks(settings MetricSettings) metricOracledbSessionEnqueueDeadlocks {
	m := metricOracledbSessionEnqueueDeadlocks{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbSessionExchangeDeadlocks struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.session.exchange_deadlocks metric with initial data.
func (m *metricOracledbSessionExchangeDeadlocks) init() {
	m.data.SetName("oracledb.session.exchange_deadlocks")
	m.data.SetDescription("Number of times that a process detected a potential deadlock when exchanging two buffers and raised an internal, restartable error. Index scans are the only operations that perform exchanges.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricOracledbSessionExchangeDeadlocks) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbSessionExchangeDeadlocks) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbSessionExchangeDeadlocks) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbSessionExchangeDeadlocks(settings MetricSettings) metricOracledbSessionExchangeDeadlocks {
	m := metricOracledbSessionExchangeDeadlocks{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbSessionExecuteCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.session.execute_count metric with initial data.
func (m *metricOracledbSessionExecuteCount) init() {
	m.data.SetName("oracledb.session.execute_count")
	m.data.SetDescription("Total number of calls (user and recursive) that executed SQL statements")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricOracledbSessionExecuteCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbSessionExecuteCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbSessionExecuteCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbSessionExecuteCount(settings MetricSettings) metricOracledbSessionExecuteCount {
	m := metricOracledbSessionExecuteCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbSessionHardParses struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.session.hard_parses metric with initial data.
func (m *metricOracledbSessionHardParses) init() {
	m.data.SetName("oracledb.session.hard_parses")
	m.data.SetDescription("Number of hard parses")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricOracledbSessionHardParses) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbSessionHardParses) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbSessionHardParses) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbSessionHardParses(settings MetricSettings) metricOracledbSessionHardParses {
	m := metricOracledbSessionHardParses{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbSessionLogicalReads struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.session.logical_reads metric with initial data.
func (m *metricOracledbSessionLogicalReads) init() {
	m.data.SetName("oracledb.session.logical_reads")
	m.data.SetDescription("Number of logical reads")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricOracledbSessionLogicalReads) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbSessionLogicalReads) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbSessionLogicalReads) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbSessionLogicalReads(settings MetricSettings) metricOracledbSessionLogicalReads {
	m := metricOracledbSessionLogicalReads{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbSessionParseCountTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.session.parse_count_total metric with initial data.
func (m *metricOracledbSessionParseCountTotal) init() {
	m.data.SetName("oracledb.session.parse_count_total")
	m.data.SetDescription("Total number of parse calls (hard, soft, and describe). A soft parse is a check on an object already in the shared pool, to verify that the permissions on the underlying object have not changed.")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricOracledbSessionParseCountTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbSessionParseCountTotal) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbSessionParseCountTotal) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbSessionParseCountTotal(settings MetricSettings) metricOracledbSessionParseCountTotal {
	m := metricOracledbSessionParseCountTotal{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbSessionPgaMemory struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.session.pga_memory metric with initial data.
func (m *metricOracledbSessionPgaMemory) init() {
	m.data.SetName("oracledb.session.pga_memory")
	m.data.SetDescription("PGA size at the end of the interval")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricOracledbSessionPgaMemory) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbSessionPgaMemory) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbSessionPgaMemory) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbSessionPgaMemory(settings MetricSettings) metricOracledbSessionPgaMemory {
	m := metricOracledbSessionPgaMemory{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbSessionPhysicalReads struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.session.physical_reads metric with initial data.
func (m *metricOracledbSessionPhysicalReads) init() {
	m.data.SetName("oracledb.session.physical_reads")
	m.data.SetDescription("Number of physical reads")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricOracledbSessionPhysicalReads) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbSessionPhysicalReads) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbSessionPhysicalReads) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbSessionPhysicalReads(settings MetricSettings) metricOracledbSessionPhysicalReads {
	m := metricOracledbSessionPhysicalReads{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbSessionSoftParses struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.session.soft_parses metric with initial data.
func (m *metricOracledbSessionSoftParses) init() {
	m.data.SetName("oracledb.session.soft_parses")
	m.data.SetDescription("Number of soft parses")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricOracledbSessionSoftParses) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbSessionSoftParses) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbSessionSoftParses) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbSessionSoftParses(settings MetricSettings) metricOracledbSessionSoftParses {
	m := metricOracledbSessionSoftParses{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbSessionUserCommits struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.session.user_commits metric with initial data.
func (m *metricOracledbSessionUserCommits) init() {
	m.data.SetName("oracledb.session.user_commits")
	m.data.SetDescription("Number of user commits. When a user commits a transaction, the redo generated that reflects the changes made to database blocks must be written to disk. Commits often represent the closest thing to a user transaction rate.")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricOracledbSessionUserCommits) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbSessionUserCommits) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbSessionUserCommits) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbSessionUserCommits(settings MetricSettings) metricOracledbSessionUserCommits {
	m := metricOracledbSessionUserCommits{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbSessionUserRollbacks struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.session.user_rollbacks metric with initial data.
func (m *metricOracledbSessionUserRollbacks) init() {
	m.data.SetName("oracledb.session.user_rollbacks")
	m.data.SetDescription("Number of times users manually issue the ROLLBACK statement or an error occurs during a user's transactions")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricOracledbSessionUserRollbacks) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbSessionUserRollbacks) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbSessionUserRollbacks) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbSessionUserRollbacks(settings MetricSettings) metricOracledbSessionUserRollbacks {
	m := metricOracledbSessionUserRollbacks{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbSystemResourceLimits struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.system.resource_limits metric with initial data.
func (m *metricOracledbSystemResourceLimits) init() {
	m.data.SetName("oracledb.system.resource_limits")
	m.data.SetDescription("Designates the current utilization and max, initial and current value of a resource limit across processes, sessions, locks, and more.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricOracledbSystemResourceLimits) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbOracleResourceNameAttributeValue string, dbOracleResourceTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.oracle.resource.name", dbOracleResourceNameAttributeValue)
	dp.Attributes().PutStr("db.oracle.resource.type", dbOracleResourceTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbSystemResourceLimits) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbSystemResourceLimits) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbSystemResourceLimits(settings MetricSettings) metricOracledbSystemResourceLimits {
	m := metricOracledbSystemResourceLimits{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbSystemSessionCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.system.session_count metric with initial data.
func (m *metricOracledbSystemSessionCount) init() {
	m.data.SetName("oracledb.system.session_count")
	m.data.SetDescription("Count of sessions.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricOracledbSystemSessionCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbOracleSessionTypeAttributeValue string, dbOracleSessionStatusAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.oracle.session.type", dbOracleSessionTypeAttributeValue)
	dp.Attributes().PutStr("db.oracle.session.status", dbOracleSessionStatusAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbSystemSessionCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbSystemSessionCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbSystemSessionCount(settings MetricSettings) metricOracledbSystemSessionCount {
	m := metricOracledbSystemSessionCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbTablespaceMaxSize struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.tablespace.max_size metric with initial data.
func (m *metricOracledbTablespaceMaxSize) init() {
	m.data.SetName("oracledb.tablespace.max_size")
	m.data.SetDescription("Maximum size of tablespace in bytes.")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricOracledbTablespaceMaxSize) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbOracleTablespaceNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.oracle.tablespace.name", dbOracleTablespaceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbTablespaceMaxSize) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbTablespaceMaxSize) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbTablespaceMaxSize(settings MetricSettings) metricOracledbTablespaceMaxSize {
	m := metricOracledbTablespaceMaxSize{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbTablespaceSize struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.tablespace.size metric with initial data.
func (m *metricOracledbTablespaceSize) init() {
	m.data.SetName("oracledb.tablespace.size")
	m.data.SetDescription("Size of tablespace in bytes.")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricOracledbTablespaceSize) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbOracleTablespaceNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.oracle.tablespace.name", dbOracleTablespaceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbTablespaceSize) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbTablespaceSize) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbTablespaceSize(settings MetricSettings) metricOracledbTablespaceSize {
	m := metricOracledbTablespaceSize{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user settings.
type MetricsBuilder struct {
	startTime                              pcommon.Timestamp   // start time that will be applied to all recorded data points.
	metricsCapacity                        int                 // maximum observed number of metrics per resource.
	resourceCapacity                       int                 // maximum observed number of resource attributes.
	metricsBuffer                          pmetric.Metrics     // accumulates metrics data before emitting.
	buildInfo                              component.BuildInfo // contains version information
	metricOracledbSessionCPUUsage          metricOracledbSessionCPUUsage
	metricOracledbSessionEnqueueDeadlocks  metricOracledbSessionEnqueueDeadlocks
	metricOracledbSessionExchangeDeadlocks metricOracledbSessionExchangeDeadlocks
	metricOracledbSessionExecuteCount      metricOracledbSessionExecuteCount
	metricOracledbSessionHardParses        metricOracledbSessionHardParses
	metricOracledbSessionLogicalReads      metricOracledbSessionLogicalReads
	metricOracledbSessionParseCountTotal   metricOracledbSessionParseCountTotal
	metricOracledbSessionPgaMemory         metricOracledbSessionPgaMemory
	metricOracledbSessionPhysicalReads     metricOracledbSessionPhysicalReads
	metricOracledbSessionSoftParses        metricOracledbSessionSoftParses
	metricOracledbSessionUserCommits       metricOracledbSessionUserCommits
	metricOracledbSessionUserRollbacks     metricOracledbSessionUserRollbacks
	metricOracledbSystemResourceLimits     metricOracledbSystemResourceLimits
	metricOracledbSystemSessionCount       metricOracledbSystemSessionCount
	metricOracledbTablespaceMaxSize        metricOracledbTablespaceMaxSize
	metricOracledbTablespaceSize           metricOracledbTablespaceSize
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

func NewMetricsBuilder(settings MetricsSettings, buildInfo component.BuildInfo, options ...metricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		startTime:                              pcommon.NewTimestampFromTime(time.Now()),
		metricsBuffer:                          pmetric.NewMetrics(),
		buildInfo:                              buildInfo,
		metricOracledbSessionCPUUsage:          newMetricOracledbSessionCPUUsage(settings.OracledbSessionCPUUsage),
		metricOracledbSessionEnqueueDeadlocks:  newMetricOracledbSessionEnqueueDeadlocks(settings.OracledbSessionEnqueueDeadlocks),
		metricOracledbSessionExchangeDeadlocks: newMetricOracledbSessionExchangeDeadlocks(settings.OracledbSessionExchangeDeadlocks),
		metricOracledbSessionExecuteCount:      newMetricOracledbSessionExecuteCount(settings.OracledbSessionExecuteCount),
		metricOracledbSessionHardParses:        newMetricOracledbSessionHardParses(settings.OracledbSessionHardParses),
		metricOracledbSessionLogicalReads:      newMetricOracledbSessionLogicalReads(settings.OracledbSessionLogicalReads),
		metricOracledbSessionParseCountTotal:   newMetricOracledbSessionParseCountTotal(settings.OracledbSessionParseCountTotal),
		metricOracledbSessionPgaMemory:         newMetricOracledbSessionPgaMemory(settings.OracledbSessionPgaMemory),
		metricOracledbSessionPhysicalReads:     newMetricOracledbSessionPhysicalReads(settings.OracledbSessionPhysicalReads),
		metricOracledbSessionSoftParses:        newMetricOracledbSessionSoftParses(settings.OracledbSessionSoftParses),
		metricOracledbSessionUserCommits:       newMetricOracledbSessionUserCommits(settings.OracledbSessionUserCommits),
		metricOracledbSessionUserRollbacks:     newMetricOracledbSessionUserRollbacks(settings.OracledbSessionUserRollbacks),
		metricOracledbSystemResourceLimits:     newMetricOracledbSystemResourceLimits(settings.OracledbSystemResourceLimits),
		metricOracledbSystemSessionCount:       newMetricOracledbSystemSessionCount(settings.OracledbSystemSessionCount),
		metricOracledbTablespaceMaxSize:        newMetricOracledbTablespaceMaxSize(settings.OracledbTablespaceMaxSize),
		metricOracledbTablespaceSize:           newMetricOracledbTablespaceSize(settings.OracledbTablespaceSize),
	}
	for _, op := range options {
		op(mb)
	}
	return mb
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (mb *MetricsBuilder) updateCapacity(rm pmetric.ResourceMetrics) {
	if mb.metricsCapacity < rm.ScopeMetrics().At(0).Metrics().Len() {
		mb.metricsCapacity = rm.ScopeMetrics().At(0).Metrics().Len()
	}
	if mb.resourceCapacity < rm.Resource().Attributes().Len() {
		mb.resourceCapacity = rm.Resource().Attributes().Len()
	}
}

// ResourceMetricsOption applies changes to provided resource metrics.
type ResourceMetricsOption func(pmetric.ResourceMetrics)

// WithDbOracleInstanceName sets provided value as "db.oracle.instance.name" attribute for current resource.
func WithDbOracleInstanceName(val string) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		rm.Resource().Attributes().PutStr("db.oracle.instance.name", val)
	}
}

// WithStartTimeOverride overrides start time for all the resource metrics data points.
// This option should be only used if different start time has to be set on metrics coming from different resources.
func WithStartTimeOverride(start pcommon.Timestamp) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		var dps pmetric.NumberDataPointSlice
		metrics := rm.ScopeMetrics().At(0).Metrics()
		for i := 0; i < metrics.Len(); i++ {
			switch metrics.At(i).Type() {
			case pmetric.MetricTypeGauge:
				dps = metrics.At(i).Gauge().DataPoints()
			case pmetric.MetricTypeSum:
				dps = metrics.At(i).Sum().DataPoints()
			}
			for j := 0; j < dps.Len(); j++ {
				dps.At(j).SetStartTimestamp(start)
			}
		}
	}
}

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead.
// Resource attributes should be provided as ResourceMetricsOption arguments.
func (mb *MetricsBuilder) EmitForResource(rmo ...ResourceMetricsOption) {
	rm := pmetric.NewResourceMetrics()
	rm.Resource().Attributes().EnsureCapacity(mb.resourceCapacity)
	ils := rm.ScopeMetrics().AppendEmpty()
	ils.Scope().SetName("otelcol/oracledbreceiver")
	ils.Scope().SetVersion(mb.buildInfo.Version)
	ils.Metrics().EnsureCapacity(mb.metricsCapacity)
	mb.metricOracledbSessionCPUUsage.emit(ils.Metrics())
	mb.metricOracledbSessionEnqueueDeadlocks.emit(ils.Metrics())
	mb.metricOracledbSessionExchangeDeadlocks.emit(ils.Metrics())
	mb.metricOracledbSessionExecuteCount.emit(ils.Metrics())
	mb.metricOracledbSessionHardParses.emit(ils.Metrics())
	mb.metricOracledbSessionLogicalReads.emit(ils.Metrics())
	mb.metricOracledbSessionParseCountTotal.emit(ils.Metrics())
	mb.metricOracledbSessionPgaMemory.emit(ils.Metrics())
	mb.metricOracledbSessionPhysicalReads.emit(ils.Metrics())
	mb.metricOracledbSessionSoftParses.emit(ils.Metrics())
	mb.metricOracledbSessionUserCommits.emit(ils.Metrics())
	mb.metricOracledbSessionUserRollbacks.emit(ils.Metrics())
	mb.metricOracledbSystemResourceLimits.emit(ils.Metrics())
	mb.metricOracledbSystemSessionCount.emit(ils.Metrics())
	mb.metricOracledbTablespaceMaxSize.emit(ils.Metrics())
	mb.metricOracledbTablespaceSize.emit(ils.Metrics())
	for _, op := range rmo {
		op(rm)
	}
	if ils.Metrics().Len() > 0 {
		mb.updateCapacity(rm)
		rm.MoveTo(mb.metricsBuffer.ResourceMetrics().AppendEmpty())
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user settings, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit(rmo ...ResourceMetricsOption) pmetric.Metrics {
	mb.EmitForResource(rmo...)
	metrics := pmetric.NewMetrics()
	mb.metricsBuffer.MoveTo(metrics)
	return metrics
}

// RecordOracledbSessionCPUUsageDataPoint adds a data point to oracledb.session.cpu_usage metric.
func (mb *MetricsBuilder) RecordOracledbSessionCPUUsageDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricOracledbSessionCPUUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbSessionEnqueueDeadlocksDataPoint adds a data point to oracledb.session.enqueue_deadlocks metric.
func (mb *MetricsBuilder) RecordOracledbSessionEnqueueDeadlocksDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbSessionEnqueueDeadlocks.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbSessionExchangeDeadlocksDataPoint adds a data point to oracledb.session.exchange_deadlocks metric.
func (mb *MetricsBuilder) RecordOracledbSessionExchangeDeadlocksDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbSessionExchangeDeadlocks.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbSessionExecuteCountDataPoint adds a data point to oracledb.session.execute_count metric.
func (mb *MetricsBuilder) RecordOracledbSessionExecuteCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbSessionExecuteCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbSessionHardParsesDataPoint adds a data point to oracledb.session.hard_parses metric.
func (mb *MetricsBuilder) RecordOracledbSessionHardParsesDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbSessionHardParses.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbSessionLogicalReadsDataPoint adds a data point to oracledb.session.logical_reads metric.
func (mb *MetricsBuilder) RecordOracledbSessionLogicalReadsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbSessionLogicalReads.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbSessionParseCountTotalDataPoint adds a data point to oracledb.session.parse_count_total metric.
func (mb *MetricsBuilder) RecordOracledbSessionParseCountTotalDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbSessionParseCountTotal.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbSessionPgaMemoryDataPoint adds a data point to oracledb.session.pga_memory metric.
func (mb *MetricsBuilder) RecordOracledbSessionPgaMemoryDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbSessionPgaMemory.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbSessionPhysicalReadsDataPoint adds a data point to oracledb.session.physical_reads metric.
func (mb *MetricsBuilder) RecordOracledbSessionPhysicalReadsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbSessionPhysicalReads.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbSessionSoftParsesDataPoint adds a data point to oracledb.session.soft_parses metric.
func (mb *MetricsBuilder) RecordOracledbSessionSoftParsesDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbSessionSoftParses.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbSessionUserCommitsDataPoint adds a data point to oracledb.session.user_commits metric.
func (mb *MetricsBuilder) RecordOracledbSessionUserCommitsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbSessionUserCommits.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbSessionUserRollbacksDataPoint adds a data point to oracledb.session.user_rollbacks metric.
func (mb *MetricsBuilder) RecordOracledbSessionUserRollbacksDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbSessionUserRollbacks.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbSystemResourceLimitsDataPoint adds a data point to oracledb.system.resource_limits metric.
func (mb *MetricsBuilder) RecordOracledbSystemResourceLimitsDataPoint(ts pcommon.Timestamp, val int64, dbOracleResourceNameAttributeValue string, dbOracleResourceTypeAttributeValue string) {
	mb.metricOracledbSystemResourceLimits.recordDataPoint(mb.startTime, ts, val, dbOracleResourceNameAttributeValue, dbOracleResourceTypeAttributeValue)
}

// RecordOracledbSystemSessionCountDataPoint adds a data point to oracledb.system.session_count metric.
func (mb *MetricsBuilder) RecordOracledbSystemSessionCountDataPoint(ts pcommon.Timestamp, val int64, dbOracleSessionTypeAttributeValue string, dbOracleSessionStatusAttributeValue string) {
	mb.metricOracledbSystemSessionCount.recordDataPoint(mb.startTime, ts, val, dbOracleSessionTypeAttributeValue, dbOracleSessionStatusAttributeValue)
}

// RecordOracledbTablespaceMaxSizeDataPoint adds a data point to oracledb.tablespace.max_size metric.
func (mb *MetricsBuilder) RecordOracledbTablespaceMaxSizeDataPoint(ts pcommon.Timestamp, val int64, dbOracleTablespaceNameAttributeValue string) {
	mb.metricOracledbTablespaceMaxSize.recordDataPoint(mb.startTime, ts, val, dbOracleTablespaceNameAttributeValue)
}

// RecordOracledbTablespaceSizeDataPoint adds a data point to oracledb.tablespace.size metric.
func (mb *MetricsBuilder) RecordOracledbTablespaceSizeDataPoint(ts pcommon.Timestamp, val int64, dbOracleTablespaceNameAttributeValue string) {
	mb.metricOracledbTablespaceSize.recordDataPoint(mb.startTime, ts, val, dbOracleTablespaceNameAttributeValue)
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...metricBuilderOption) {
	mb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op(mb)
	}
}
