// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
)

// MetricSettings provides common settings for a particular metric.
type MetricSettings struct {
	Enabled bool `mapstructure:"enabled"`
}

// MetricsSettings provides settings for oracledbreceiver metrics.
type MetricsSettings struct {
	OracledbCPUUtilization                           MetricSettings `mapstructure:"oracledb.cpu_utilization"`
	OracledbEnqueueDeadlocks                         MetricSettings `mapstructure:"oracledb.enqueue_deadlocks"`
	OracledbExchangeDeadlocks                        MetricSettings `mapstructure:"oracledb.exchange_deadlocks"`
	OracledbExecuteCount                             MetricSettings `mapstructure:"oracledb.execute_count"`
	OracledbHardParses                               MetricSettings `mapstructure:"oracledb.hard_parses"`
	OracledbLogicalReads                             MetricSettings `mapstructure:"oracledb.logical_reads"`
	OracledbParseCountTotal                          MetricSettings `mapstructure:"oracledb.parse_count_total"`
	OracledbPgaMemory                                MetricSettings `mapstructure:"oracledb.pga_memory"`
	OracledbPhysicalReads                            MetricSettings `mapstructure:"oracledb.physical_reads"`
	OracledbResourceLimitEnqueueLocksMax             MetricSettings `mapstructure:"oracledb.resource_limit.enqueue_locks.max"`
	OracledbResourceLimitEnqueueLocksUtilization     MetricSettings `mapstructure:"oracledb.resource_limit.enqueue_locks.utilization"`
	OracledbResourceLimitEnqueueResourcesMax         MetricSettings `mapstructure:"oracledb.resource_limit.enqueue_resources.max"`
	OracledbResourceLimitEnqueueResourcesUtilization MetricSettings `mapstructure:"oracledb.resource_limit.enqueue_resources.utilization"`
	OracledbResourceLimitProcessMax                  MetricSettings `mapstructure:"oracledb.resource_limit.process.max"`
	OracledbResourceLimitProcessUtilization          MetricSettings `mapstructure:"oracledb.resource_limit.process.utilization"`
	OracledbResourceLimitSessionMax                  MetricSettings `mapstructure:"oracledb.resource_limit.session.max"`
	OracledbResourceLimitSessionUtilization          MetricSettings `mapstructure:"oracledb.resource_limit.session.utilization"`
	OracledbSessionCount                             MetricSettings `mapstructure:"oracledb.session.count"`
	OracledbTablespaceMaxSize                        MetricSettings `mapstructure:"oracledb.tablespace.max_size"`
	OracledbTablespaceSize                           MetricSettings `mapstructure:"oracledb.tablespace.size"`
	OracledbUserCommits                              MetricSettings `mapstructure:"oracledb.user_commits"`
	OracledbUserRollbacks                            MetricSettings `mapstructure:"oracledb.user_rollbacks"`
}

func DefaultMetricsSettings() MetricsSettings {
	return MetricsSettings{
		OracledbCPUUtilization: MetricSettings{
			Enabled: true,
		},
		OracledbEnqueueDeadlocks: MetricSettings{
			Enabled: true,
		},
		OracledbExchangeDeadlocks: MetricSettings{
			Enabled: true,
		},
		OracledbExecuteCount: MetricSettings{
			Enabled: true,
		},
		OracledbHardParses: MetricSettings{
			Enabled: true,
		},
		OracledbLogicalReads: MetricSettings{
			Enabled: true,
		},
		OracledbParseCountTotal: MetricSettings{
			Enabled: true,
		},
		OracledbPgaMemory: MetricSettings{
			Enabled: true,
		},
		OracledbPhysicalReads: MetricSettings{
			Enabled: true,
		},
		OracledbResourceLimitEnqueueLocksMax: MetricSettings{
			Enabled: true,
		},
		OracledbResourceLimitEnqueueLocksUtilization: MetricSettings{
			Enabled: true,
		},
		OracledbResourceLimitEnqueueResourcesMax: MetricSettings{
			Enabled: true,
		},
		OracledbResourceLimitEnqueueResourcesUtilization: MetricSettings{
			Enabled: true,
		},
		OracledbResourceLimitProcessMax: MetricSettings{
			Enabled: true,
		},
		OracledbResourceLimitProcessUtilization: MetricSettings{
			Enabled: true,
		},
		OracledbResourceLimitSessionMax: MetricSettings{
			Enabled: true,
		},
		OracledbResourceLimitSessionUtilization: MetricSettings{
			Enabled: true,
		},
		OracledbSessionCount: MetricSettings{
			Enabled: true,
		},
		OracledbTablespaceMaxSize: MetricSettings{
			Enabled: true,
		},
		OracledbTablespaceSize: MetricSettings{
			Enabled: true,
		},
		OracledbUserCommits: MetricSettings{
			Enabled: true,
		},
		OracledbUserRollbacks: MetricSettings{
			Enabled: true,
		},
	}
}

type metricOracledbCPUUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.cpu_utilization metric with initial data.
func (m *metricOracledbCPUUtilization) init() {
	m.data.SetName("oracledb.cpu_utilization")
	m.data.SetDescription("CPU utilization, in seconds")
	m.data.SetUnit("s")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricOracledbCPUUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbCPUUtilization) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbCPUUtilization) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbCPUUtilization(settings MetricSettings) metricOracledbCPUUtilization {
	m := metricOracledbCPUUtilization{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbEnqueueDeadlocks struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.enqueue_deadlocks metric with initial data.
func (m *metricOracledbEnqueueDeadlocks) init() {
	m.data.SetName("oracledb.enqueue_deadlocks")
	m.data.SetDescription("Total number of deadlocks between table or row locks in different sessions.")
	m.data.SetUnit("{deadlocks}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricOracledbEnqueueDeadlocks) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbEnqueueDeadlocks) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbEnqueueDeadlocks) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbEnqueueDeadlocks(settings MetricSettings) metricOracledbEnqueueDeadlocks {
	m := metricOracledbEnqueueDeadlocks{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbExchangeDeadlocks struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.exchange_deadlocks metric with initial data.
func (m *metricOracledbExchangeDeadlocks) init() {
	m.data.SetName("oracledb.exchange_deadlocks")
	m.data.SetDescription("Number of times that a process detected a potential deadlock when exchanging two buffers and raised an internal, restartable error. Index scans are the only operations that perform exchanges.")
	m.data.SetUnit("{deadlocks}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricOracledbExchangeDeadlocks) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbExchangeDeadlocks) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbExchangeDeadlocks) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbExchangeDeadlocks(settings MetricSettings) metricOracledbExchangeDeadlocks {
	m := metricOracledbExchangeDeadlocks{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbExecuteCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.execute_count metric with initial data.
func (m *metricOracledbExecuteCount) init() {
	m.data.SetName("oracledb.execute_count")
	m.data.SetDescription("Total number of calls (user and recursive) that executed SQL statements")
	m.data.SetUnit("{executions}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricOracledbExecuteCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbExecuteCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbExecuteCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbExecuteCount(settings MetricSettings) metricOracledbExecuteCount {
	m := metricOracledbExecuteCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbHardParses struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.hard_parses metric with initial data.
func (m *metricOracledbHardParses) init() {
	m.data.SetName("oracledb.hard_parses")
	m.data.SetDescription("Number of hard parses")
	m.data.SetUnit("{parses}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricOracledbHardParses) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbHardParses) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbHardParses) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbHardParses(settings MetricSettings) metricOracledbHardParses {
	m := metricOracledbHardParses{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbLogicalReads struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.logical_reads metric with initial data.
func (m *metricOracledbLogicalReads) init() {
	m.data.SetName("oracledb.logical_reads")
	m.data.SetDescription("Number of logical reads")
	m.data.SetUnit("{reads}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricOracledbLogicalReads) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbLogicalReads) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbLogicalReads) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbLogicalReads(settings MetricSettings) metricOracledbLogicalReads {
	m := metricOracledbLogicalReads{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbParseCountTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.parse_count_total metric with initial data.
func (m *metricOracledbParseCountTotal) init() {
	m.data.SetName("oracledb.parse_count_total")
	m.data.SetDescription("Total number of parse calls.")
	m.data.SetUnit("{parses}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricOracledbParseCountTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbParseCountTotal) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbParseCountTotal) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbParseCountTotal(settings MetricSettings) metricOracledbParseCountTotal {
	m := metricOracledbParseCountTotal{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbPgaMemory struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.pga_memory metric with initial data.
func (m *metricOracledbPgaMemory) init() {
	m.data.SetName("oracledb.pga_memory")
	m.data.SetDescription("Session PGA (Program Global Area) memory")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricOracledbPgaMemory) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbPgaMemory) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbPgaMemory) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbPgaMemory(settings MetricSettings) metricOracledbPgaMemory {
	m := metricOracledbPgaMemory{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbPhysicalReads struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.physical_reads metric with initial data.
func (m *metricOracledbPhysicalReads) init() {
	m.data.SetName("oracledb.physical_reads")
	m.data.SetDescription("Number of physical reads")
	m.data.SetUnit("{reads}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricOracledbPhysicalReads) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbPhysicalReads) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbPhysicalReads) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbPhysicalReads(settings MetricSettings) metricOracledbPhysicalReads {
	m := metricOracledbPhysicalReads{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbResourceLimitEnqueueLocksMax struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.resource_limit.enqueue_locks.max metric with initial data.
func (m *metricOracledbResourceLimitEnqueueLocksMax) init() {
	m.data.SetName("oracledb.resource_limit.enqueue_locks.max")
	m.data.SetDescription("Maximum limit of active enqueue locks.")
	m.data.SetUnit("{locks}")
	m.data.SetEmptyGauge()
}

func (m *metricOracledbResourceLimitEnqueueLocksMax) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbResourceLimitEnqueueLocksMax) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbResourceLimitEnqueueLocksMax) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbResourceLimitEnqueueLocksMax(settings MetricSettings) metricOracledbResourceLimitEnqueueLocksMax {
	m := metricOracledbResourceLimitEnqueueLocksMax{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbResourceLimitEnqueueLocksUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.resource_limit.enqueue_locks.utilization metric with initial data.
func (m *metricOracledbResourceLimitEnqueueLocksUtilization) init() {
	m.data.SetName("oracledb.resource_limit.enqueue_locks.utilization")
	m.data.SetDescription("Current count of active enqueue locks.")
	m.data.SetUnit("{locks}")
	m.data.SetEmptyGauge()
}

func (m *metricOracledbResourceLimitEnqueueLocksUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbResourceLimitEnqueueLocksUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbResourceLimitEnqueueLocksUtilization) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbResourceLimitEnqueueLocksUtilization(settings MetricSettings) metricOracledbResourceLimitEnqueueLocksUtilization {
	m := metricOracledbResourceLimitEnqueueLocksUtilization{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbResourceLimitEnqueueResourcesMax struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.resource_limit.enqueue_resources.max metric with initial data.
func (m *metricOracledbResourceLimitEnqueueResourcesMax) init() {
	m.data.SetName("oracledb.resource_limit.enqueue_resources.max")
	m.data.SetDescription("Maximum limit of active enqueue resources.")
	m.data.SetUnit("{resources}")
	m.data.SetEmptyGauge()
}

func (m *metricOracledbResourceLimitEnqueueResourcesMax) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbResourceLimitEnqueueResourcesMax) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbResourceLimitEnqueueResourcesMax) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbResourceLimitEnqueueResourcesMax(settings MetricSettings) metricOracledbResourceLimitEnqueueResourcesMax {
	m := metricOracledbResourceLimitEnqueueResourcesMax{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbResourceLimitEnqueueResourcesUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.resource_limit.enqueue_resources.utilization metric with initial data.
func (m *metricOracledbResourceLimitEnqueueResourcesUtilization) init() {
	m.data.SetName("oracledb.resource_limit.enqueue_resources.utilization")
	m.data.SetDescription("Current count of active enqueue resources.")
	m.data.SetUnit("{resources}")
	m.data.SetEmptyGauge()
}

func (m *metricOracledbResourceLimitEnqueueResourcesUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbResourceLimitEnqueueResourcesUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbResourceLimitEnqueueResourcesUtilization) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbResourceLimitEnqueueResourcesUtilization(settings MetricSettings) metricOracledbResourceLimitEnqueueResourcesUtilization {
	m := metricOracledbResourceLimitEnqueueResourcesUtilization{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbResourceLimitProcessMax struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.resource_limit.process.max metric with initial data.
func (m *metricOracledbResourceLimitProcessMax) init() {
	m.data.SetName("oracledb.resource_limit.process.max")
	m.data.SetDescription("Maximum limit of active processes.")
	m.data.SetUnit("{processes}")
	m.data.SetEmptyGauge()
}

func (m *metricOracledbResourceLimitProcessMax) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbResourceLimitProcessMax) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbResourceLimitProcessMax) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbResourceLimitProcessMax(settings MetricSettings) metricOracledbResourceLimitProcessMax {
	m := metricOracledbResourceLimitProcessMax{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbResourceLimitProcessUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.resource_limit.process.utilization metric with initial data.
func (m *metricOracledbResourceLimitProcessUtilization) init() {
	m.data.SetName("oracledb.resource_limit.process.utilization")
	m.data.SetDescription("Current count of active processes.")
	m.data.SetUnit("{processes}")
	m.data.SetEmptyGauge()
}

func (m *metricOracledbResourceLimitProcessUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbResourceLimitProcessUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbResourceLimitProcessUtilization) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbResourceLimitProcessUtilization(settings MetricSettings) metricOracledbResourceLimitProcessUtilization {
	m := metricOracledbResourceLimitProcessUtilization{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbResourceLimitSessionMax struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.resource_limit.session.max metric with initial data.
func (m *metricOracledbResourceLimitSessionMax) init() {
	m.data.SetName("oracledb.resource_limit.session.max")
	m.data.SetDescription("Maximum limit of active sessions.")
	m.data.SetUnit("{sessions}")
	m.data.SetEmptyGauge()
}

func (m *metricOracledbResourceLimitSessionMax) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbResourceLimitSessionMax) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbResourceLimitSessionMax) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbResourceLimitSessionMax(settings MetricSettings) metricOracledbResourceLimitSessionMax {
	m := metricOracledbResourceLimitSessionMax{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbResourceLimitSessionUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.resource_limit.session.utilization metric with initial data.
func (m *metricOracledbResourceLimitSessionUtilization) init() {
	m.data.SetName("oracledb.resource_limit.session.utilization")
	m.data.SetDescription("Current count of active sessions.")
	m.data.SetUnit("{sessions}")
	m.data.SetEmptyGauge()
}

func (m *metricOracledbResourceLimitSessionUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbResourceLimitSessionUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbResourceLimitSessionUtilization) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbResourceLimitSessionUtilization(settings MetricSettings) metricOracledbResourceLimitSessionUtilization {
	m := metricOracledbResourceLimitSessionUtilization{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbSessionCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.session.count metric with initial data.
func (m *metricOracledbSessionCount) init() {
	m.data.SetName("oracledb.session.count")
	m.data.SetDescription("Count of sessions.")
	m.data.SetUnit("{sessions}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricOracledbSessionCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbOracleSessionTypeAttributeValue string, dbOracleSessionStatusAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.oracle.session.type", dbOracleSessionTypeAttributeValue)
	dp.Attributes().PutStr("db.oracle.session.status", dbOracleSessionStatusAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbSessionCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbSessionCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbSessionCount(settings MetricSettings) metricOracledbSessionCount {
	m := metricOracledbSessionCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbTablespaceMaxSize struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.tablespace.max_size metric with initial data.
func (m *metricOracledbTablespaceMaxSize) init() {
	m.data.SetName("oracledb.tablespace.max_size")
	m.data.SetDescription("Maximum size of tablespace in bytes.")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricOracledbTablespaceMaxSize) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbOracleTablespaceNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.oracle.tablespace.name", dbOracleTablespaceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbTablespaceMaxSize) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbTablespaceMaxSize) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbTablespaceMaxSize(settings MetricSettings) metricOracledbTablespaceMaxSize {
	m := metricOracledbTablespaceMaxSize{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbTablespaceSize struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.tablespace.size metric with initial data.
func (m *metricOracledbTablespaceSize) init() {
	m.data.SetName("oracledb.tablespace.size")
	m.data.SetDescription("Size of tablespace in bytes.")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricOracledbTablespaceSize) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbOracleTablespaceNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.oracle.tablespace.name", dbOracleTablespaceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbTablespaceSize) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbTablespaceSize) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbTablespaceSize(settings MetricSettings) metricOracledbTablespaceSize {
	m := metricOracledbTablespaceSize{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbUserCommits struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.user_commits metric with initial data.
func (m *metricOracledbUserCommits) init() {
	m.data.SetName("oracledb.user_commits")
	m.data.SetDescription("Number of user commits. When a user commits a transaction, the redo generated that reflects the changes made to database blocks must be written to disk. Commits often represent the closest thing to a user transaction rate.")
	m.data.SetUnit("{commits}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricOracledbUserCommits) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbUserCommits) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbUserCommits) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbUserCommits(settings MetricSettings) metricOracledbUserCommits {
	m := metricOracledbUserCommits{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOracledbUserRollbacks struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills oracledb.user_rollbacks metric with initial data.
func (m *metricOracledbUserRollbacks) init() {
	m.data.SetName("oracledb.user_rollbacks")
	m.data.SetDescription("Number of times users manually issue the ROLLBACK statement or an error occurs during a user's transactions")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricOracledbUserRollbacks) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOracledbUserRollbacks) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOracledbUserRollbacks) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOracledbUserRollbacks(settings MetricSettings) metricOracledbUserRollbacks {
	m := metricOracledbUserRollbacks{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user settings.
type MetricsBuilder struct {
	startTime                                              pcommon.Timestamp   // start time that will be applied to all recorded data points.
	metricsCapacity                                        int                 // maximum observed number of metrics per resource.
	resourceCapacity                                       int                 // maximum observed number of resource attributes.
	metricsBuffer                                          pmetric.Metrics     // accumulates metrics data before emitting.
	buildInfo                                              component.BuildInfo // contains version information
	metricOracledbCPUUtilization                           metricOracledbCPUUtilization
	metricOracledbEnqueueDeadlocks                         metricOracledbEnqueueDeadlocks
	metricOracledbExchangeDeadlocks                        metricOracledbExchangeDeadlocks
	metricOracledbExecuteCount                             metricOracledbExecuteCount
	metricOracledbHardParses                               metricOracledbHardParses
	metricOracledbLogicalReads                             metricOracledbLogicalReads
	metricOracledbParseCountTotal                          metricOracledbParseCountTotal
	metricOracledbPgaMemory                                metricOracledbPgaMemory
	metricOracledbPhysicalReads                            metricOracledbPhysicalReads
	metricOracledbResourceLimitEnqueueLocksMax             metricOracledbResourceLimitEnqueueLocksMax
	metricOracledbResourceLimitEnqueueLocksUtilization     metricOracledbResourceLimitEnqueueLocksUtilization
	metricOracledbResourceLimitEnqueueResourcesMax         metricOracledbResourceLimitEnqueueResourcesMax
	metricOracledbResourceLimitEnqueueResourcesUtilization metricOracledbResourceLimitEnqueueResourcesUtilization
	metricOracledbResourceLimitProcessMax                  metricOracledbResourceLimitProcessMax
	metricOracledbResourceLimitProcessUtilization          metricOracledbResourceLimitProcessUtilization
	metricOracledbResourceLimitSessionMax                  metricOracledbResourceLimitSessionMax
	metricOracledbResourceLimitSessionUtilization          metricOracledbResourceLimitSessionUtilization
	metricOracledbSessionCount                             metricOracledbSessionCount
	metricOracledbTablespaceMaxSize                        metricOracledbTablespaceMaxSize
	metricOracledbTablespaceSize                           metricOracledbTablespaceSize
	metricOracledbUserCommits                              metricOracledbUserCommits
	metricOracledbUserRollbacks                            metricOracledbUserRollbacks
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

func NewMetricsBuilder(settings MetricsSettings, buildInfo component.BuildInfo, options ...metricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		startTime:                                              pcommon.NewTimestampFromTime(time.Now()),
		metricsBuffer:                                          pmetric.NewMetrics(),
		buildInfo:                                              buildInfo,
		metricOracledbCPUUtilization:                           newMetricOracledbCPUUtilization(settings.OracledbCPUUtilization),
		metricOracledbEnqueueDeadlocks:                         newMetricOracledbEnqueueDeadlocks(settings.OracledbEnqueueDeadlocks),
		metricOracledbExchangeDeadlocks:                        newMetricOracledbExchangeDeadlocks(settings.OracledbExchangeDeadlocks),
		metricOracledbExecuteCount:                             newMetricOracledbExecuteCount(settings.OracledbExecuteCount),
		metricOracledbHardParses:                               newMetricOracledbHardParses(settings.OracledbHardParses),
		metricOracledbLogicalReads:                             newMetricOracledbLogicalReads(settings.OracledbLogicalReads),
		metricOracledbParseCountTotal:                          newMetricOracledbParseCountTotal(settings.OracledbParseCountTotal),
		metricOracledbPgaMemory:                                newMetricOracledbPgaMemory(settings.OracledbPgaMemory),
		metricOracledbPhysicalReads:                            newMetricOracledbPhysicalReads(settings.OracledbPhysicalReads),
		metricOracledbResourceLimitEnqueueLocksMax:             newMetricOracledbResourceLimitEnqueueLocksMax(settings.OracledbResourceLimitEnqueueLocksMax),
		metricOracledbResourceLimitEnqueueLocksUtilization:     newMetricOracledbResourceLimitEnqueueLocksUtilization(settings.OracledbResourceLimitEnqueueLocksUtilization),
		metricOracledbResourceLimitEnqueueResourcesMax:         newMetricOracledbResourceLimitEnqueueResourcesMax(settings.OracledbResourceLimitEnqueueResourcesMax),
		metricOracledbResourceLimitEnqueueResourcesUtilization: newMetricOracledbResourceLimitEnqueueResourcesUtilization(settings.OracledbResourceLimitEnqueueResourcesUtilization),
		metricOracledbResourceLimitProcessMax:                  newMetricOracledbResourceLimitProcessMax(settings.OracledbResourceLimitProcessMax),
		metricOracledbResourceLimitProcessUtilization:          newMetricOracledbResourceLimitProcessUtilization(settings.OracledbResourceLimitProcessUtilization),
		metricOracledbResourceLimitSessionMax:                  newMetricOracledbResourceLimitSessionMax(settings.OracledbResourceLimitSessionMax),
		metricOracledbResourceLimitSessionUtilization:          newMetricOracledbResourceLimitSessionUtilization(settings.OracledbResourceLimitSessionUtilization),
		metricOracledbSessionCount:                             newMetricOracledbSessionCount(settings.OracledbSessionCount),
		metricOracledbTablespaceMaxSize:                        newMetricOracledbTablespaceMaxSize(settings.OracledbTablespaceMaxSize),
		metricOracledbTablespaceSize:                           newMetricOracledbTablespaceSize(settings.OracledbTablespaceSize),
		metricOracledbUserCommits:                              newMetricOracledbUserCommits(settings.OracledbUserCommits),
		metricOracledbUserRollbacks:                            newMetricOracledbUserRollbacks(settings.OracledbUserRollbacks),
	}
	for _, op := range options {
		op(mb)
	}
	return mb
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (mb *MetricsBuilder) updateCapacity(rm pmetric.ResourceMetrics) {
	if mb.metricsCapacity < rm.ScopeMetrics().At(0).Metrics().Len() {
		mb.metricsCapacity = rm.ScopeMetrics().At(0).Metrics().Len()
	}
	if mb.resourceCapacity < rm.Resource().Attributes().Len() {
		mb.resourceCapacity = rm.Resource().Attributes().Len()
	}
}

// ResourceMetricsOption applies changes to provided resource metrics.
type ResourceMetricsOption func(pmetric.ResourceMetrics)

// WithDbOracleInstanceName sets provided value as "db.oracle.instance.name" attribute for current resource.
func WithDbOracleInstanceName(val string) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		rm.Resource().Attributes().PutStr("db.oracle.instance.name", val)
	}
}

// WithStartTimeOverride overrides start time for all the resource metrics data points.
// This option should be only used if different start time has to be set on metrics coming from different resources.
func WithStartTimeOverride(start pcommon.Timestamp) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		var dps pmetric.NumberDataPointSlice
		metrics := rm.ScopeMetrics().At(0).Metrics()
		for i := 0; i < metrics.Len(); i++ {
			switch metrics.At(i).Type() {
			case pmetric.MetricTypeGauge:
				dps = metrics.At(i).Gauge().DataPoints()
			case pmetric.MetricTypeSum:
				dps = metrics.At(i).Sum().DataPoints()
			}
			for j := 0; j < dps.Len(); j++ {
				dps.At(j).SetStartTimestamp(start)
			}
		}
	}
}

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead.
// Resource attributes should be provided as ResourceMetricsOption arguments.
func (mb *MetricsBuilder) EmitForResource(rmo ...ResourceMetricsOption) {
	rm := pmetric.NewResourceMetrics()
	rm.Resource().Attributes().EnsureCapacity(mb.resourceCapacity)
	ils := rm.ScopeMetrics().AppendEmpty()
	ils.Scope().SetName("otelcol/oracledbreceiver")
	ils.Scope().SetVersion(mb.buildInfo.Version)
	ils.Metrics().EnsureCapacity(mb.metricsCapacity)
	mb.metricOracledbCPUUtilization.emit(ils.Metrics())
	mb.metricOracledbEnqueueDeadlocks.emit(ils.Metrics())
	mb.metricOracledbExchangeDeadlocks.emit(ils.Metrics())
	mb.metricOracledbExecuteCount.emit(ils.Metrics())
	mb.metricOracledbHardParses.emit(ils.Metrics())
	mb.metricOracledbLogicalReads.emit(ils.Metrics())
	mb.metricOracledbParseCountTotal.emit(ils.Metrics())
	mb.metricOracledbPgaMemory.emit(ils.Metrics())
	mb.metricOracledbPhysicalReads.emit(ils.Metrics())
	mb.metricOracledbResourceLimitEnqueueLocksMax.emit(ils.Metrics())
	mb.metricOracledbResourceLimitEnqueueLocksUtilization.emit(ils.Metrics())
	mb.metricOracledbResourceLimitEnqueueResourcesMax.emit(ils.Metrics())
	mb.metricOracledbResourceLimitEnqueueResourcesUtilization.emit(ils.Metrics())
	mb.metricOracledbResourceLimitProcessMax.emit(ils.Metrics())
	mb.metricOracledbResourceLimitProcessUtilization.emit(ils.Metrics())
	mb.metricOracledbResourceLimitSessionMax.emit(ils.Metrics())
	mb.metricOracledbResourceLimitSessionUtilization.emit(ils.Metrics())
	mb.metricOracledbSessionCount.emit(ils.Metrics())
	mb.metricOracledbTablespaceMaxSize.emit(ils.Metrics())
	mb.metricOracledbTablespaceSize.emit(ils.Metrics())
	mb.metricOracledbUserCommits.emit(ils.Metrics())
	mb.metricOracledbUserRollbacks.emit(ils.Metrics())
	for _, op := range rmo {
		op(rm)
	}
	if ils.Metrics().Len() > 0 {
		mb.updateCapacity(rm)
		rm.MoveTo(mb.metricsBuffer.ResourceMetrics().AppendEmpty())
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user settings, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit(rmo ...ResourceMetricsOption) pmetric.Metrics {
	mb.EmitForResource(rmo...)
	metrics := pmetric.NewMetrics()
	mb.metricsBuffer.MoveTo(metrics)
	return metrics
}

// RecordOracledbCPUUtilizationDataPoint adds a data point to oracledb.cpu_utilization metric.
func (mb *MetricsBuilder) RecordOracledbCPUUtilizationDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricOracledbCPUUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbEnqueueDeadlocksDataPoint adds a data point to oracledb.enqueue_deadlocks metric.
func (mb *MetricsBuilder) RecordOracledbEnqueueDeadlocksDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbEnqueueDeadlocks.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbExchangeDeadlocksDataPoint adds a data point to oracledb.exchange_deadlocks metric.
func (mb *MetricsBuilder) RecordOracledbExchangeDeadlocksDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbExchangeDeadlocks.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbExecuteCountDataPoint adds a data point to oracledb.execute_count metric.
func (mb *MetricsBuilder) RecordOracledbExecuteCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbExecuteCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbHardParsesDataPoint adds a data point to oracledb.hard_parses metric.
func (mb *MetricsBuilder) RecordOracledbHardParsesDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbHardParses.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbLogicalReadsDataPoint adds a data point to oracledb.logical_reads metric.
func (mb *MetricsBuilder) RecordOracledbLogicalReadsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbLogicalReads.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbParseCountTotalDataPoint adds a data point to oracledb.parse_count_total metric.
func (mb *MetricsBuilder) RecordOracledbParseCountTotalDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbParseCountTotal.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbPgaMemoryDataPoint adds a data point to oracledb.pga_memory metric.
func (mb *MetricsBuilder) RecordOracledbPgaMemoryDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbPgaMemory.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbPhysicalReadsDataPoint adds a data point to oracledb.physical_reads metric.
func (mb *MetricsBuilder) RecordOracledbPhysicalReadsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbPhysicalReads.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbResourceLimitEnqueueLocksMaxDataPoint adds a data point to oracledb.resource_limit.enqueue_locks.max metric.
func (mb *MetricsBuilder) RecordOracledbResourceLimitEnqueueLocksMaxDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbResourceLimitEnqueueLocksMax.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbResourceLimitEnqueueLocksUtilizationDataPoint adds a data point to oracledb.resource_limit.enqueue_locks.utilization metric.
func (mb *MetricsBuilder) RecordOracledbResourceLimitEnqueueLocksUtilizationDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbResourceLimitEnqueueLocksUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbResourceLimitEnqueueResourcesMaxDataPoint adds a data point to oracledb.resource_limit.enqueue_resources.max metric.
func (mb *MetricsBuilder) RecordOracledbResourceLimitEnqueueResourcesMaxDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbResourceLimitEnqueueResourcesMax.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbResourceLimitEnqueueResourcesUtilizationDataPoint adds a data point to oracledb.resource_limit.enqueue_resources.utilization metric.
func (mb *MetricsBuilder) RecordOracledbResourceLimitEnqueueResourcesUtilizationDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbResourceLimitEnqueueResourcesUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbResourceLimitProcessMaxDataPoint adds a data point to oracledb.resource_limit.process.max metric.
func (mb *MetricsBuilder) RecordOracledbResourceLimitProcessMaxDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbResourceLimitProcessMax.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbResourceLimitProcessUtilizationDataPoint adds a data point to oracledb.resource_limit.process.utilization metric.
func (mb *MetricsBuilder) RecordOracledbResourceLimitProcessUtilizationDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbResourceLimitProcessUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbResourceLimitSessionMaxDataPoint adds a data point to oracledb.resource_limit.session.max metric.
func (mb *MetricsBuilder) RecordOracledbResourceLimitSessionMaxDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbResourceLimitSessionMax.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbResourceLimitSessionUtilizationDataPoint adds a data point to oracledb.resource_limit.session.utilization metric.
func (mb *MetricsBuilder) RecordOracledbResourceLimitSessionUtilizationDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbResourceLimitSessionUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbSessionCountDataPoint adds a data point to oracledb.session.count metric.
func (mb *MetricsBuilder) RecordOracledbSessionCountDataPoint(ts pcommon.Timestamp, val int64, dbOracleSessionTypeAttributeValue string, dbOracleSessionStatusAttributeValue string) {
	mb.metricOracledbSessionCount.recordDataPoint(mb.startTime, ts, val, dbOracleSessionTypeAttributeValue, dbOracleSessionStatusAttributeValue)
}

// RecordOracledbTablespaceMaxSizeDataPoint adds a data point to oracledb.tablespace.max_size metric.
func (mb *MetricsBuilder) RecordOracledbTablespaceMaxSizeDataPoint(ts pcommon.Timestamp, val int64, dbOracleTablespaceNameAttributeValue string) {
	mb.metricOracledbTablespaceMaxSize.recordDataPoint(mb.startTime, ts, val, dbOracleTablespaceNameAttributeValue)
}

// RecordOracledbTablespaceSizeDataPoint adds a data point to oracledb.tablespace.size metric.
func (mb *MetricsBuilder) RecordOracledbTablespaceSizeDataPoint(ts pcommon.Timestamp, val int64, dbOracleTablespaceNameAttributeValue string) {
	mb.metricOracledbTablespaceSize.recordDataPoint(mb.startTime, ts, val, dbOracleTablespaceNameAttributeValue)
}

// RecordOracledbUserCommitsDataPoint adds a data point to oracledb.user_commits metric.
func (mb *MetricsBuilder) RecordOracledbUserCommitsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbUserCommits.recordDataPoint(mb.startTime, ts, val)
}

// RecordOracledbUserRollbacksDataPoint adds a data point to oracledb.user_rollbacks metric.
func (mb *MetricsBuilder) RecordOracledbUserRollbacksDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricOracledbUserRollbacks.recordDataPoint(mb.startTime, ts, val)
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...metricBuilderOption) {
	mb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op(mb)
	}
}
