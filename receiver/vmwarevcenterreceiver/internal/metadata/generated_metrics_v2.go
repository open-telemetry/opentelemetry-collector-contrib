// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/model/pdata"
)

// MetricSettings provides common settings for a particular metric.
type MetricSettings struct {
	Enabled bool `mapstructure:"enabled"`
}

// MetricsSettings provides settings for vmwarevcenterreceiver metrics.
type MetricsSettings struct {
	VcenterClusterCPUAvailable      MetricSettings `mapstructure:"vcenter.cluster.cpu.available"`
	VcenterClusterCPUEffective      MetricSettings `mapstructure:"vcenter.cluster.cpu.effective"`
	VcenterClusterCPUUsed           MetricSettings `mapstructure:"vcenter.cluster.cpu.used"`
	VcenterClusterMemoryAvailable   MetricSettings `mapstructure:"vcenter.cluster.memory.available"`
	VcenterClusterMemoryEffective   MetricSettings `mapstructure:"vcenter.cluster.memory.effective"`
	VcenterClusterMemoryUsed        MetricSettings `mapstructure:"vcenter.cluster.memory.used"`
	VcenterClusterVsanCongestions   MetricSettings `mapstructure:"vcenter.cluster.vsan.congestions"`
	VcenterClusterVsanLatencyAvg    MetricSettings `mapstructure:"vcenter.cluster.vsan.latency.avg"`
	VcenterClusterVsanOperations    MetricSettings `mapstructure:"vcenter.cluster.vsan.operations"`
	VcenterClusterVsanOutstandingIo MetricSettings `mapstructure:"vcenter.cluster.vsan.outstanding_io"`
	VcenterClusterVsanThroughput    MetricSettings `mapstructure:"vcenter.cluster.vsan.throughput"`
	VcenterDatacenterHostCount      MetricSettings `mapstructure:"vcenter.datacenter.host.count"`
	VcenterDatacenterVMCount        MetricSettings `mapstructure:"vcenter.datacenter.vm.count"`
	VcenterDatastoreDiskUsage       MetricSettings `mapstructure:"vcenter.datastore.disk.usage"`
	VcenterDatastoreDiskUtilization MetricSettings `mapstructure:"vcenter.datastore.disk.utilization"`
	VcenterHostCPUUsage             MetricSettings `mapstructure:"vcenter.host.cpu.usage"`
	VcenterHostCPUUtilization       MetricSettings `mapstructure:"vcenter.host.cpu.utilization"`
	VcenterHostDiskLatencyAvg       MetricSettings `mapstructure:"vcenter.host.disk.latency.avg"`
	VcenterHostDiskThroughput       MetricSettings `mapstructure:"vcenter.host.disk.throughput"`
	VcenterHostMemoryUsage          MetricSettings `mapstructure:"vcenter.host.memory.usage"`
	VcenterHostMemoryUtilization    MetricSettings `mapstructure:"vcenter.host.memory.utilization"`
	VcenterHostNetworkPackets       MetricSettings `mapstructure:"vcenter.host.network.packets"`
	VcenterHostNetworkThroughput    MetricSettings `mapstructure:"vcenter.host.network.throughput"`
	VcenterHostVsanCacheHitRate     MetricSettings `mapstructure:"vcenter.host.vsan.cache.hit_rate"`
	VcenterHostVsanCacheReads       MetricSettings `mapstructure:"vcenter.host.vsan.cache.reads"`
	VcenterHostVsanCongestions      MetricSettings `mapstructure:"vcenter.host.vsan.congestions"`
	VcenterHostVsanLatencyAvg       MetricSettings `mapstructure:"vcenter.host.vsan.latency.avg"`
	VcenterHostVsanOperations       MetricSettings `mapstructure:"vcenter.host.vsan.operations"`
	VcenterHostVsanOutstandingIo    MetricSettings `mapstructure:"vcenter.host.vsan.outstanding_io"`
	VcenterHostVsanThroughput       MetricSettings `mapstructure:"vcenter.host.vsan.throughput"`
	VcenterVMCPUUtilization         MetricSettings `mapstructure:"vcenter.vm.cpu.utilization"`
	VcenterVMDiskLatency            MetricSettings `mapstructure:"vcenter.vm.disk.latency"`
	VcenterVMDiskThroughput         MetricSettings `mapstructure:"vcenter.vm.disk.throughput"`
	VcenterVMDiskUsage              MetricSettings `mapstructure:"vcenter.vm.disk.usage"`
	VcenterVMMemoryBallooned        MetricSettings `mapstructure:"vcenter.vm.memory.ballooned"`
	VcenterVMMemoryUsage            MetricSettings `mapstructure:"vcenter.vm.memory.usage"`
	VcenterVMNetworkPackets         MetricSettings `mapstructure:"vcenter.vm.network.packets"`
	VcenterVMNetworkThroughput      MetricSettings `mapstructure:"vcenter.vm.network.throughput"`
	VcenterVMVsanCongestions        MetricSettings `mapstructure:"vcenter.vm.vsan.congestions"`
	VcenterVMVsanLatencyAvg         MetricSettings `mapstructure:"vcenter.vm.vsan.latency.avg"`
	VcenterVMVsanOperations         MetricSettings `mapstructure:"vcenter.vm.vsan.operations"`
	VcenterVMVsanOutstandingIo      MetricSettings `mapstructure:"vcenter.vm.vsan.outstanding_io"`
	VcenterVMVsanThroughput         MetricSettings `mapstructure:"vcenter.vm.vsan.throughput"`
}

func DefaultMetricsSettings() MetricsSettings {
	return MetricsSettings{
		VcenterClusterCPUAvailable: MetricSettings{
			Enabled: true,
		},
		VcenterClusterCPUEffective: MetricSettings{
			Enabled: true,
		},
		VcenterClusterCPUUsed: MetricSettings{
			Enabled: true,
		},
		VcenterClusterMemoryAvailable: MetricSettings{
			Enabled: true,
		},
		VcenterClusterMemoryEffective: MetricSettings{
			Enabled: true,
		},
		VcenterClusterMemoryUsed: MetricSettings{
			Enabled: true,
		},
		VcenterClusterVsanCongestions: MetricSettings{
			Enabled: true,
		},
		VcenterClusterVsanLatencyAvg: MetricSettings{
			Enabled: true,
		},
		VcenterClusterVsanOperations: MetricSettings{
			Enabled: true,
		},
		VcenterClusterVsanOutstandingIo: MetricSettings{
			Enabled: true,
		},
		VcenterClusterVsanThroughput: MetricSettings{
			Enabled: true,
		},
		VcenterDatacenterHostCount: MetricSettings{
			Enabled: true,
		},
		VcenterDatacenterVMCount: MetricSettings{
			Enabled: true,
		},
		VcenterDatastoreDiskUsage: MetricSettings{
			Enabled: true,
		},
		VcenterDatastoreDiskUtilization: MetricSettings{
			Enabled: true,
		},
		VcenterHostCPUUsage: MetricSettings{
			Enabled: true,
		},
		VcenterHostCPUUtilization: MetricSettings{
			Enabled: true,
		},
		VcenterHostDiskLatencyAvg: MetricSettings{
			Enabled: true,
		},
		VcenterHostDiskThroughput: MetricSettings{
			Enabled: true,
		},
		VcenterHostMemoryUsage: MetricSettings{
			Enabled: true,
		},
		VcenterHostMemoryUtilization: MetricSettings{
			Enabled: true,
		},
		VcenterHostNetworkPackets: MetricSettings{
			Enabled: true,
		},
		VcenterHostNetworkThroughput: MetricSettings{
			Enabled: true,
		},
		VcenterHostVsanCacheHitRate: MetricSettings{
			Enabled: true,
		},
		VcenterHostVsanCacheReads: MetricSettings{
			Enabled: true,
		},
		VcenterHostVsanCongestions: MetricSettings{
			Enabled: true,
		},
		VcenterHostVsanLatencyAvg: MetricSettings{
			Enabled: true,
		},
		VcenterHostVsanOperations: MetricSettings{
			Enabled: true,
		},
		VcenterHostVsanOutstandingIo: MetricSettings{
			Enabled: true,
		},
		VcenterHostVsanThroughput: MetricSettings{
			Enabled: true,
		},
		VcenterVMCPUUtilization: MetricSettings{
			Enabled: true,
		},
		VcenterVMDiskLatency: MetricSettings{
			Enabled: true,
		},
		VcenterVMDiskThroughput: MetricSettings{
			Enabled: true,
		},
		VcenterVMDiskUsage: MetricSettings{
			Enabled: true,
		},
		VcenterVMMemoryBallooned: MetricSettings{
			Enabled: true,
		},
		VcenterVMMemoryUsage: MetricSettings{
			Enabled: true,
		},
		VcenterVMNetworkPackets: MetricSettings{
			Enabled: true,
		},
		VcenterVMNetworkThroughput: MetricSettings{
			Enabled: true,
		},
		VcenterVMVsanCongestions: MetricSettings{
			Enabled: true,
		},
		VcenterVMVsanLatencyAvg: MetricSettings{
			Enabled: true,
		},
		VcenterVMVsanOperations: MetricSettings{
			Enabled: true,
		},
		VcenterVMVsanOutstandingIo: MetricSettings{
			Enabled: true,
		},
		VcenterVMVsanThroughput: MetricSettings{
			Enabled: true,
		},
	}
}

type metricVcenterClusterCPUAvailable struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.cluster.cpu.available metric with initial data.
func (m *metricVcenterClusterCPUAvailable) init() {
	m.data.SetName("vcenter.cluster.cpu.available")
	m.data.SetDescription("The amount of CPU available to the cluster")
	m.data.SetUnit("{MHz}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterClusterCPUAvailable) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, clusterAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Cluster, pdata.NewAttributeValueString(clusterAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterClusterCPUAvailable) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterClusterCPUAvailable) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterClusterCPUAvailable(settings MetricSettings) metricVcenterClusterCPUAvailable {
	m := metricVcenterClusterCPUAvailable{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterClusterCPUEffective struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.cluster.cpu.effective metric with initial data.
func (m *metricVcenterClusterCPUEffective) init() {
	m.data.SetName("vcenter.cluster.cpu.effective")
	m.data.SetDescription("The effective CPU available to the cluster. This value excludes memory from hosts in maintenance mode or are unresponsive.")
	m.data.SetUnit("{MHz}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterClusterCPUEffective) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, clusterAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Cluster, pdata.NewAttributeValueString(clusterAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterClusterCPUEffective) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterClusterCPUEffective) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterClusterCPUEffective(settings MetricSettings) metricVcenterClusterCPUEffective {
	m := metricVcenterClusterCPUEffective{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterClusterCPUUsed struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.cluster.cpu.used metric with initial data.
func (m *metricVcenterClusterCPUUsed) init() {
	m.data.SetName("vcenter.cluster.cpu.used")
	m.data.SetDescription("The amount of CPU used by the cluster")
	m.data.SetUnit("{MHz}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterClusterCPUUsed) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, clusterAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Cluster, pdata.NewAttributeValueString(clusterAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterClusterCPUUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterClusterCPUUsed) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterClusterCPUUsed(settings MetricSettings) metricVcenterClusterCPUUsed {
	m := metricVcenterClusterCPUUsed{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterClusterMemoryAvailable struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.cluster.memory.available metric with initial data.
func (m *metricVcenterClusterMemoryAvailable) init() {
	m.data.SetName("vcenter.cluster.memory.available")
	m.data.SetDescription("The available memory of the cluster.")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterClusterMemoryAvailable) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, clusterAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Cluster, pdata.NewAttributeValueString(clusterAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterClusterMemoryAvailable) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterClusterMemoryAvailable) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterClusterMemoryAvailable(settings MetricSettings) metricVcenterClusterMemoryAvailable {
	m := metricVcenterClusterMemoryAvailable{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterClusterMemoryEffective struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.cluster.memory.effective metric with initial data.
func (m *metricVcenterClusterMemoryEffective) init() {
	m.data.SetName("vcenter.cluster.memory.effective")
	m.data.SetDescription("The available memory of the cluster.")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterClusterMemoryEffective) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, clusterAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Cluster, pdata.NewAttributeValueString(clusterAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterClusterMemoryEffective) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterClusterMemoryEffective) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterClusterMemoryEffective(settings MetricSettings) metricVcenterClusterMemoryEffective {
	m := metricVcenterClusterMemoryEffective{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterClusterMemoryUsed struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.cluster.memory.used metric with initial data.
func (m *metricVcenterClusterMemoryUsed) init() {
	m.data.SetName("vcenter.cluster.memory.used")
	m.data.SetDescription("The memory that is currently used by the cluster")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterClusterMemoryUsed) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, clusterAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Cluster, pdata.NewAttributeValueString(clusterAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterClusterMemoryUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterClusterMemoryUsed) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterClusterMemoryUsed(settings MetricSettings) metricVcenterClusterMemoryUsed {
	m := metricVcenterClusterMemoryUsed{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterClusterVsanCongestions struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.cluster.vsan.congestions metric with initial data.
func (m *metricVcenterClusterVsanCongestions) init() {
	m.data.SetName("vcenter.cluster.vsan.congestions")
	m.data.SetDescription("Congestions consumed by all vSAN clients in the cluster, such as virtual machines, stats objects, etc.")
	m.data.SetUnit("{congestions/sec}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterClusterVsanCongestions) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, clusterAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Cluster, pdata.NewAttributeValueString(clusterAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterClusterVsanCongestions) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterClusterVsanCongestions) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterClusterVsanCongestions(settings MetricSettings) metricVcenterClusterVsanCongestions {
	m := metricVcenterClusterVsanCongestions{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterClusterVsanLatencyAvg struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.cluster.vsan.latency.avg metric with initial data.
func (m *metricVcenterClusterVsanLatencyAvg) init() {
	m.data.SetName("vcenter.cluster.vsan.latency.avg")
	m.data.SetDescription("Average latency of IOs generated by all vSAN clients in the cluster.")
	m.data.SetUnit("Âµs")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterClusterVsanLatencyAvg) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, vsanLatencyTypeAttributeValue string, clusterAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.VsanLatencyType, pdata.NewAttributeValueString(vsanLatencyTypeAttributeValue))
	dp.Attributes().Insert(A.Cluster, pdata.NewAttributeValueString(clusterAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterClusterVsanLatencyAvg) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterClusterVsanLatencyAvg) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterClusterVsanLatencyAvg(settings MetricSettings) metricVcenterClusterVsanLatencyAvg {
	m := metricVcenterClusterVsanLatencyAvg{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterClusterVsanOperations struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.cluster.vsan.operations metric with initial data.
func (m *metricVcenterClusterVsanOperations) init() {
	m.data.SetName("vcenter.cluster.vsan.operations")
	m.data.SetDescription("IOPS consumed by all vSAN clients in the cluster")
	m.data.SetUnit("{operations/sec}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterClusterVsanOperations) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, vsanOperationTypeAttributeValue string, clusterAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.VsanOperationType, pdata.NewAttributeValueString(vsanOperationTypeAttributeValue))
	dp.Attributes().Insert(A.Cluster, pdata.NewAttributeValueString(clusterAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterClusterVsanOperations) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterClusterVsanOperations) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterClusterVsanOperations(settings MetricSettings) metricVcenterClusterVsanOperations {
	m := metricVcenterClusterVsanOperations{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterClusterVsanOutstandingIo struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.cluster.vsan.outstanding_io metric with initial data.
func (m *metricVcenterClusterVsanOutstandingIo) init() {
	m.data.SetName("vcenter.cluster.vsan.outstanding_io")
	m.data.SetDescription("Outstanding IO from all vSAN clients in the cluster")
	m.data.SetUnit("{operations}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterClusterVsanOutstandingIo) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, clusterAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Cluster, pdata.NewAttributeValueString(clusterAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterClusterVsanOutstandingIo) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterClusterVsanOutstandingIo) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterClusterVsanOutstandingIo(settings MetricSettings) metricVcenterClusterVsanOutstandingIo {
	m := metricVcenterClusterVsanOutstandingIo{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterClusterVsanThroughput struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.cluster.vsan.throughput metric with initial data.
func (m *metricVcenterClusterVsanThroughput) init() {
	m.data.SetName("vcenter.cluster.vsan.throughput")
	m.data.SetDescription("Throughput consumed by all vSAN clients in the cluster.")
	m.data.SetUnit("By/sec")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterClusterVsanThroughput) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, vsanThroughputDirectionAttributeValue string, clusterAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.VsanThroughputDirection, pdata.NewAttributeValueString(vsanThroughputDirectionAttributeValue))
	dp.Attributes().Insert(A.Cluster, pdata.NewAttributeValueString(clusterAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterClusterVsanThroughput) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterClusterVsanThroughput) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterClusterVsanThroughput(settings MetricSettings) metricVcenterClusterVsanThroughput {
	m := metricVcenterClusterVsanThroughput{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterDatacenterHostCount struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.datacenter.host.count metric with initial data.
func (m *metricVcenterDatacenterHostCount) init() {
	m.data.SetName("vcenter.datacenter.host.count")
	m.data.SetDescription("the number of hosts in the datacenter")
	m.data.SetUnit("{hosts}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricVcenterDatacenterHostCount) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterDatacenterHostCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterDatacenterHostCount) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterDatacenterHostCount(settings MetricSettings) metricVcenterDatacenterHostCount {
	m := metricVcenterDatacenterHostCount{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterDatacenterVMCount struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.datacenter.vm.count metric with initial data.
func (m *metricVcenterDatacenterVMCount) init() {
	m.data.SetName("vcenter.datacenter.vm.count")
	m.data.SetDescription("the number of virtual machines in the datacenter")
	m.data.SetUnit("{virtual_machines}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricVcenterDatacenterVMCount) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterDatacenterVMCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterDatacenterVMCount) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterDatacenterVMCount(settings MetricSettings) metricVcenterDatacenterVMCount {
	m := metricVcenterDatacenterVMCount{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterDatastoreDiskUsage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.datastore.disk.usage metric with initial data.
func (m *metricVcenterDatastoreDiskUsage) init() {
	m.data.SetName("vcenter.datastore.disk.usage")
	m.data.SetDescription("The amount of space in the datastore.")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricVcenterDatastoreDiskUsage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterDatastoreDiskUsage) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterDatastoreDiskUsage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterDatastoreDiskUsage(settings MetricSettings) metricVcenterDatastoreDiskUsage {
	m := metricVcenterDatastoreDiskUsage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterDatastoreDiskUtilization struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.datastore.disk.utilization metric with initial data.
func (m *metricVcenterDatastoreDiskUtilization) init() {
	m.data.SetName("vcenter.datastore.disk.utilization")
	m.data.SetDescription("The utilization of the datastore")
	m.data.SetUnit("%")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricVcenterDatastoreDiskUtilization) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterDatastoreDiskUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterDatastoreDiskUtilization) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterDatastoreDiskUtilization(settings MetricSettings) metricVcenterDatastoreDiskUtilization {
	m := metricVcenterDatastoreDiskUtilization{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterHostCPUUsage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.host.cpu.usage metric with initial data.
func (m *metricVcenterHostCPUUsage) init() {
	m.data.SetName("vcenter.host.cpu.usage")
	m.data.SetDescription("The amount of CPU in Hz used by the host")
	m.data.SetUnit("MHz")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterHostCPUUsage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, hostnameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Hostname, pdata.NewAttributeValueString(hostnameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterHostCPUUsage) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterHostCPUUsage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterHostCPUUsage(settings MetricSettings) metricVcenterHostCPUUsage {
	m := metricVcenterHostCPUUsage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterHostCPUUtilization struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.host.cpu.utilization metric with initial data.
func (m *metricVcenterHostCPUUtilization) init() {
	m.data.SetName("vcenter.host.cpu.utilization")
	m.data.SetDescription("The CPU utilization of the host system")
	m.data.SetUnit("%")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterHostCPUUtilization) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, hostnameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.Hostname, pdata.NewAttributeValueString(hostnameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterHostCPUUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterHostCPUUtilization) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterHostCPUUtilization(settings MetricSettings) metricVcenterHostCPUUtilization {
	m := metricVcenterHostCPUUtilization{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterHostDiskLatencyAvg struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.host.disk.latency.avg metric with initial data.
func (m *metricVcenterHostDiskLatencyAvg) init() {
	m.data.SetName("vcenter.host.disk.latency.avg")
	m.data.SetDescription("The latency of operations to the host system's disk")
	m.data.SetUnit("ms")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterHostDiskLatencyAvg) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, hostnameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Hostname, pdata.NewAttributeValueString(hostnameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterHostDiskLatencyAvg) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterHostDiskLatencyAvg) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterHostDiskLatencyAvg(settings MetricSettings) metricVcenterHostDiskLatencyAvg {
	m := metricVcenterHostDiskLatencyAvg{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterHostDiskThroughput struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.host.disk.throughput metric with initial data.
func (m *metricVcenterHostDiskThroughput) init() {
	m.data.SetName("vcenter.host.disk.throughput")
	m.data.SetDescription("The throughput to the host system's disk")
	m.data.SetUnit("By/s")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterHostDiskThroughput) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, hostnameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Hostname, pdata.NewAttributeValueString(hostnameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterHostDiskThroughput) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterHostDiskThroughput) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterHostDiskThroughput(settings MetricSettings) metricVcenterHostDiskThroughput {
	m := metricVcenterHostDiskThroughput{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterHostMemoryUsage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.host.memory.usage metric with initial data.
func (m *metricVcenterHostMemoryUsage) init() {
	m.data.SetName("vcenter.host.memory.usage")
	m.data.SetDescription("The amount of memory the host system is using")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterHostMemoryUsage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, hostnameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Hostname, pdata.NewAttributeValueString(hostnameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterHostMemoryUsage) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterHostMemoryUsage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterHostMemoryUsage(settings MetricSettings) metricVcenterHostMemoryUsage {
	m := metricVcenterHostMemoryUsage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterHostMemoryUtilization struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.host.memory.utilization metric with initial data.
func (m *metricVcenterHostMemoryUtilization) init() {
	m.data.SetName("vcenter.host.memory.utilization")
	m.data.SetDescription("The percentage of the host system's memory capacity that is being utilized")
	m.data.SetUnit("%")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterHostMemoryUtilization) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, hostnameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.Hostname, pdata.NewAttributeValueString(hostnameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterHostMemoryUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterHostMemoryUtilization) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterHostMemoryUtilization(settings MetricSettings) metricVcenterHostMemoryUtilization {
	m := metricVcenterHostMemoryUtilization{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterHostNetworkPackets struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.host.network.packets metric with initial data.
func (m *metricVcenterHostNetworkPackets) init() {
	m.data.SetName("vcenter.host.network.packets")
	m.data.SetDescription("The number of packets sent over an interval")
	m.data.SetUnit("{packets/sec}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterHostNetworkPackets) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, hostnameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Hostname, pdata.NewAttributeValueString(hostnameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterHostNetworkPackets) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterHostNetworkPackets) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterHostNetworkPackets(settings MetricSettings) metricVcenterHostNetworkPackets {
	m := metricVcenterHostNetworkPackets{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterHostNetworkThroughput struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.host.network.throughput metric with initial data.
func (m *metricVcenterHostNetworkThroughput) init() {
	m.data.SetName("vcenter.host.network.throughput")
	m.data.SetDescription("The amount of data that was sent or recieved over the network by the host")
	m.data.SetUnit("{By/s}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterHostNetworkThroughput) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, hostnameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Hostname, pdata.NewAttributeValueString(hostnameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterHostNetworkThroughput) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterHostNetworkThroughput) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterHostNetworkThroughput(settings MetricSettings) metricVcenterHostNetworkThroughput {
	m := metricVcenterHostNetworkThroughput{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterHostVsanCacheHitRate struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.host.vsan.cache.hit_rate metric with initial data.
func (m *metricVcenterHostVsanCacheHitRate) init() {
	m.data.SetName("vcenter.host.vsan.cache.hit_rate")
	m.data.SetDescription("Percentage of read IOs which could be satisfied by the local client cache")
	m.data.SetUnit("%")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterHostVsanCacheHitRate) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, hostnameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.Hostname, pdata.NewAttributeValueString(hostnameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterHostVsanCacheHitRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterHostVsanCacheHitRate) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterHostVsanCacheHitRate(settings MetricSettings) metricVcenterHostVsanCacheHitRate {
	m := metricVcenterHostVsanCacheHitRate{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterHostVsanCacheReads struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.host.vsan.cache.reads metric with initial data.
func (m *metricVcenterHostVsanCacheReads) init() {
	m.data.SetName("vcenter.host.vsan.cache.reads")
	m.data.SetDescription("Average latency of IOs generated by all vSAN clients on the host")
	m.data.SetUnit("{operations/sec}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterHostVsanCacheReads) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, hostnameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Hostname, pdata.NewAttributeValueString(hostnameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterHostVsanCacheReads) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterHostVsanCacheReads) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterHostVsanCacheReads(settings MetricSettings) metricVcenterHostVsanCacheReads {
	m := metricVcenterHostVsanCacheReads{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterHostVsanCongestions struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.host.vsan.congestions metric with initial data.
func (m *metricVcenterHostVsanCongestions) init() {
	m.data.SetName("vcenter.host.vsan.congestions")
	m.data.SetDescription("Congestions of IOs generated by all vSAN clients on the host")
	m.data.SetUnit("{congestions/sec}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterHostVsanCongestions) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, hostnameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Hostname, pdata.NewAttributeValueString(hostnameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterHostVsanCongestions) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterHostVsanCongestions) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterHostVsanCongestions(settings MetricSettings) metricVcenterHostVsanCongestions {
	m := metricVcenterHostVsanCongestions{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterHostVsanLatencyAvg struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.host.vsan.latency.avg metric with initial data.
func (m *metricVcenterHostVsanLatencyAvg) init() {
	m.data.SetName("vcenter.host.vsan.latency.avg")
	m.data.SetDescription("Average latency of IOs generated by all vSAN clients on the host.")
	m.data.SetUnit("Âµs")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterHostVsanLatencyAvg) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, hostnameAttributeValue string, vsanLatencyTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Hostname, pdata.NewAttributeValueString(hostnameAttributeValue))
	dp.Attributes().Insert(A.VsanLatencyType, pdata.NewAttributeValueString(vsanLatencyTypeAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterHostVsanLatencyAvg) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterHostVsanLatencyAvg) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterHostVsanLatencyAvg(settings MetricSettings) metricVcenterHostVsanLatencyAvg {
	m := metricVcenterHostVsanLatencyAvg{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterHostVsanOperations struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.host.vsan.operations metric with initial data.
func (m *metricVcenterHostVsanOperations) init() {
	m.data.SetName("vcenter.host.vsan.operations")
	m.data.SetDescription("IOPs consumed by all vSAN clients on the host.")
	m.data.SetUnit("{operations/sec}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterHostVsanOperations) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, hostnameAttributeValue string, vsanOperationTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Hostname, pdata.NewAttributeValueString(hostnameAttributeValue))
	dp.Attributes().Insert(A.VsanOperationType, pdata.NewAttributeValueString(vsanOperationTypeAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterHostVsanOperations) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterHostVsanOperations) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterHostVsanOperations(settings MetricSettings) metricVcenterHostVsanOperations {
	m := metricVcenterHostVsanOperations{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterHostVsanOutstandingIo struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.host.vsan.outstanding_io metric with initial data.
func (m *metricVcenterHostVsanOutstandingIo) init() {
	m.data.SetName("vcenter.host.vsan.outstanding_io")
	m.data.SetDescription("Outstanding IO from all vSAN clients in the host, such as virtual machines, stats object, etc.")
	m.data.SetUnit("{operations/sec}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterHostVsanOutstandingIo) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, hostnameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Hostname, pdata.NewAttributeValueString(hostnameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterHostVsanOutstandingIo) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterHostVsanOutstandingIo) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterHostVsanOutstandingIo(settings MetricSettings) metricVcenterHostVsanOutstandingIo {
	m := metricVcenterHostVsanOutstandingIo{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterHostVsanThroughput struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.host.vsan.throughput metric with initial data.
func (m *metricVcenterHostVsanThroughput) init() {
	m.data.SetName("vcenter.host.vsan.throughput")
	m.data.SetDescription("Throughput consumed by all vSAN clients on the host.")
	m.data.SetUnit("By/s")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterHostVsanThroughput) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, hostnameAttributeValue string, vsanThroughputDirectionAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Hostname, pdata.NewAttributeValueString(hostnameAttributeValue))
	dp.Attributes().Insert(A.VsanThroughputDirection, pdata.NewAttributeValueString(vsanThroughputDirectionAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterHostVsanThroughput) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterHostVsanThroughput) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterHostVsanThroughput(settings MetricSettings) metricVcenterHostVsanThroughput {
	m := metricVcenterHostVsanThroughput{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterVMCPUUtilization struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.vm.cpu.utilization metric with initial data.
func (m *metricVcenterVMCPUUtilization) init() {
	m.data.SetName("vcenter.vm.cpu.utilization")
	m.data.SetDescription("The CPU utilization of the virtual machine")
	m.data.SetUnit("%")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterVMCPUUtilization) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64, instanceNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
	dp.Attributes().Insert(A.InstanceName, pdata.NewAttributeValueString(instanceNameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterVMCPUUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterVMCPUUtilization) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterVMCPUUtilization(settings MetricSettings) metricVcenterVMCPUUtilization {
	m := metricVcenterVMCPUUtilization{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterVMDiskLatency struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.vm.disk.latency metric with initial data.
func (m *metricVcenterVMDiskLatency) init() {
	m.data.SetName("vcenter.vm.disk.latency")
	m.data.SetDescription("The latency of operations to the virtual machine's disk")
	m.data.SetUnit("Âµs")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterVMDiskLatency) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, instanceNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.InstanceName, pdata.NewAttributeValueString(instanceNameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterVMDiskLatency) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterVMDiskLatency) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterVMDiskLatency(settings MetricSettings) metricVcenterVMDiskLatency {
	m := metricVcenterVMDiskLatency{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterVMDiskThroughput struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.vm.disk.throughput metric with initial data.
func (m *metricVcenterVMDiskThroughput) init() {
	m.data.SetName("vcenter.vm.disk.throughput")
	m.data.SetDescription("The throughput of the virtual machine's disk")
	m.data.SetUnit("By/sec")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterVMDiskThroughput) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, instanceNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.InstanceName, pdata.NewAttributeValueString(instanceNameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterVMDiskThroughput) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterVMDiskThroughput) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterVMDiskThroughput(settings MetricSettings) metricVcenterVMDiskThroughput {
	m := metricVcenterVMDiskThroughput{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterVMDiskUsage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.vm.disk.usage metric with initial data.
func (m *metricVcenterVMDiskUsage) init() {
	m.data.SetName("vcenter.vm.disk.usage")
	m.data.SetDescription("The amount of storage space the virtual machine is using")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterVMDiskUsage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, instanceNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.InstanceName, pdata.NewAttributeValueString(instanceNameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterVMDiskUsage) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterVMDiskUsage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterVMDiskUsage(settings MetricSettings) metricVcenterVMDiskUsage {
	m := metricVcenterVMDiskUsage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterVMMemoryBallooned struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.vm.memory.ballooned metric with initial data.
func (m *metricVcenterVMMemoryBallooned) init() {
	m.data.SetName("vcenter.vm.memory.ballooned")
	m.data.SetDescription("The amount of memory that is ballooned due to virtualization.")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterVMMemoryBallooned) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, instanceNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.InstanceName, pdata.NewAttributeValueString(instanceNameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterVMMemoryBallooned) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterVMMemoryBallooned) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterVMMemoryBallooned(settings MetricSettings) metricVcenterVMMemoryBallooned {
	m := metricVcenterVMMemoryBallooned{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterVMMemoryUsage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.vm.memory.usage metric with initial data.
func (m *metricVcenterVMMemoryUsage) init() {
	m.data.SetName("vcenter.vm.memory.usage")
	m.data.SetDescription("The amount of memory that is used by the virtual machine")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterVMMemoryUsage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, instanceNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.InstanceName, pdata.NewAttributeValueString(instanceNameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterVMMemoryUsage) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterVMMemoryUsage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterVMMemoryUsage(settings MetricSettings) metricVcenterVMMemoryUsage {
	m := metricVcenterVMMemoryUsage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterVMNetworkPackets struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.vm.network.packets metric with initial data.
func (m *metricVcenterVMNetworkPackets) init() {
	m.data.SetName("vcenter.vm.network.packets")
	m.data.SetDescription("The amount of packets that was received or transmitted over the instance's network")
	m.data.SetUnit("{packets/sec}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterVMNetworkPackets) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, instanceNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.InstanceName, pdata.NewAttributeValueString(instanceNameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterVMNetworkPackets) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterVMNetworkPackets) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterVMNetworkPackets(settings MetricSettings) metricVcenterVMNetworkPackets {
	m := metricVcenterVMNetworkPackets{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterVMNetworkThroughput struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.vm.network.throughput metric with initial data.
func (m *metricVcenterVMNetworkThroughput) init() {
	m.data.SetName("vcenter.vm.network.throughput")
	m.data.SetDescription("The amount of data that was received or sent over the network of the virtual machine")
	m.data.SetUnit("By/sec")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterVMNetworkThroughput) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, instanceNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.InstanceName, pdata.NewAttributeValueString(instanceNameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterVMNetworkThroughput) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterVMNetworkThroughput) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterVMNetworkThroughput(settings MetricSettings) metricVcenterVMNetworkThroughput {
	m := metricVcenterVMNetworkThroughput{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterVMVsanCongestions struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.vm.vsan.congestions metric with initial data.
func (m *metricVcenterVMVsanCongestions) init() {
	m.data.SetName("vcenter.vm.vsan.congestions")
	m.data.SetDescription("todo")
	m.data.SetUnit("{congestions}")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterVMVsanCongestions) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, instanceNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.InstanceName, pdata.NewAttributeValueString(instanceNameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterVMVsanCongestions) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterVMVsanCongestions) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterVMVsanCongestions(settings MetricSettings) metricVcenterVMVsanCongestions {
	m := metricVcenterVMVsanCongestions{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterVMVsanLatencyAvg struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.vm.vsan.latency.avg metric with initial data.
func (m *metricVcenterVMVsanLatencyAvg) init() {
	m.data.SetName("vcenter.vm.vsan.latency.avg")
	m.data.SetDescription("The latency while accessing VSAN storage")
	m.data.SetUnit("us")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterVMVsanLatencyAvg) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, instanceNameAttributeValue string, vsanLatencyTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.InstanceName, pdata.NewAttributeValueString(instanceNameAttributeValue))
	dp.Attributes().Insert(A.VsanLatencyType, pdata.NewAttributeValueString(vsanLatencyTypeAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterVMVsanLatencyAvg) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterVMVsanLatencyAvg) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterVMVsanLatencyAvg(settings MetricSettings) metricVcenterVMVsanLatencyAvg {
	m := metricVcenterVMVsanLatencyAvg{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterVMVsanOperations struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.vm.vsan.operations metric with initial data.
func (m *metricVcenterVMVsanOperations) init() {
	m.data.SetName("vcenter.vm.vsan.operations")
	m.data.SetDescription("Virtual Machine vSAN IOPs")
	m.data.SetUnit("{operations/sec}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterVMVsanOperations) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, instanceNameAttributeValue string, vsanOperationTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.InstanceName, pdata.NewAttributeValueString(instanceNameAttributeValue))
	dp.Attributes().Insert(A.VsanOperationType, pdata.NewAttributeValueString(vsanOperationTypeAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterVMVsanOperations) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterVMVsanOperations) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterVMVsanOperations(settings MetricSettings) metricVcenterVMVsanOperations {
	m := metricVcenterVMVsanOperations{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterVMVsanOutstandingIo struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.vm.vsan.outstanding_io metric with initial data.
func (m *metricVcenterVMVsanOutstandingIo) init() {
	m.data.SetName("vcenter.vm.vsan.outstanding_io")
	m.data.SetDescription("The amount of outstanding VSAN I/O operations")
	m.data.SetUnit("")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterVMVsanOutstandingIo) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, instanceNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.InstanceName, pdata.NewAttributeValueString(instanceNameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterVMVsanOutstandingIo) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterVMVsanOutstandingIo) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterVMVsanOutstandingIo(settings MetricSettings) metricVcenterVMVsanOutstandingIo {
	m := metricVcenterVMVsanOutstandingIo{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVcenterVMVsanThroughput struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills vcenter.vm.vsan.throughput metric with initial data.
func (m *metricVcenterVMVsanThroughput) init() {
	m.data.SetName("vcenter.vm.vsan.throughput")
	m.data.SetDescription("The VSAN throughput of a virtual machine")
	m.data.SetUnit("By/s")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVcenterVMVsanThroughput) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, instanceNameAttributeValue string, vsanThroughputDirectionAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.InstanceName, pdata.NewAttributeValueString(instanceNameAttributeValue))
	dp.Attributes().Insert(A.VsanThroughputDirection, pdata.NewAttributeValueString(vsanThroughputDirectionAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVcenterVMVsanThroughput) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVcenterVMVsanThroughput) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVcenterVMVsanThroughput(settings MetricSettings) metricVcenterVMVsanThroughput {
	m := metricVcenterVMVsanThroughput{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user settings.
type MetricsBuilder struct {
	startTime                             pdata.Timestamp
	metricVcenterClusterCPUAvailable      metricVcenterClusterCPUAvailable
	metricVcenterClusterCPUEffective      metricVcenterClusterCPUEffective
	metricVcenterClusterCPUUsed           metricVcenterClusterCPUUsed
	metricVcenterClusterMemoryAvailable   metricVcenterClusterMemoryAvailable
	metricVcenterClusterMemoryEffective   metricVcenterClusterMemoryEffective
	metricVcenterClusterMemoryUsed        metricVcenterClusterMemoryUsed
	metricVcenterClusterVsanCongestions   metricVcenterClusterVsanCongestions
	metricVcenterClusterVsanLatencyAvg    metricVcenterClusterVsanLatencyAvg
	metricVcenterClusterVsanOperations    metricVcenterClusterVsanOperations
	metricVcenterClusterVsanOutstandingIo metricVcenterClusterVsanOutstandingIo
	metricVcenterClusterVsanThroughput    metricVcenterClusterVsanThroughput
	metricVcenterDatacenterHostCount      metricVcenterDatacenterHostCount
	metricVcenterDatacenterVMCount        metricVcenterDatacenterVMCount
	metricVcenterDatastoreDiskUsage       metricVcenterDatastoreDiskUsage
	metricVcenterDatastoreDiskUtilization metricVcenterDatastoreDiskUtilization
	metricVcenterHostCPUUsage             metricVcenterHostCPUUsage
	metricVcenterHostCPUUtilization       metricVcenterHostCPUUtilization
	metricVcenterHostDiskLatencyAvg       metricVcenterHostDiskLatencyAvg
	metricVcenterHostDiskThroughput       metricVcenterHostDiskThroughput
	metricVcenterHostMemoryUsage          metricVcenterHostMemoryUsage
	metricVcenterHostMemoryUtilization    metricVcenterHostMemoryUtilization
	metricVcenterHostNetworkPackets       metricVcenterHostNetworkPackets
	metricVcenterHostNetworkThroughput    metricVcenterHostNetworkThroughput
	metricVcenterHostVsanCacheHitRate     metricVcenterHostVsanCacheHitRate
	metricVcenterHostVsanCacheReads       metricVcenterHostVsanCacheReads
	metricVcenterHostVsanCongestions      metricVcenterHostVsanCongestions
	metricVcenterHostVsanLatencyAvg       metricVcenterHostVsanLatencyAvg
	metricVcenterHostVsanOperations       metricVcenterHostVsanOperations
	metricVcenterHostVsanOutstandingIo    metricVcenterHostVsanOutstandingIo
	metricVcenterHostVsanThroughput       metricVcenterHostVsanThroughput
	metricVcenterVMCPUUtilization         metricVcenterVMCPUUtilization
	metricVcenterVMDiskLatency            metricVcenterVMDiskLatency
	metricVcenterVMDiskThroughput         metricVcenterVMDiskThroughput
	metricVcenterVMDiskUsage              metricVcenterVMDiskUsage
	metricVcenterVMMemoryBallooned        metricVcenterVMMemoryBallooned
	metricVcenterVMMemoryUsage            metricVcenterVMMemoryUsage
	metricVcenterVMNetworkPackets         metricVcenterVMNetworkPackets
	metricVcenterVMNetworkThroughput      metricVcenterVMNetworkThroughput
	metricVcenterVMVsanCongestions        metricVcenterVMVsanCongestions
	metricVcenterVMVsanLatencyAvg         metricVcenterVMVsanLatencyAvg
	metricVcenterVMVsanOperations         metricVcenterVMVsanOperations
	metricVcenterVMVsanOutstandingIo      metricVcenterVMVsanOutstandingIo
	metricVcenterVMVsanThroughput         metricVcenterVMVsanThroughput
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pdata.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

func NewMetricsBuilder(settings MetricsSettings, options ...metricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		startTime:                             pdata.NewTimestampFromTime(time.Now()),
		metricVcenterClusterCPUAvailable:      newMetricVcenterClusterCPUAvailable(settings.VcenterClusterCPUAvailable),
		metricVcenterClusterCPUEffective:      newMetricVcenterClusterCPUEffective(settings.VcenterClusterCPUEffective),
		metricVcenterClusterCPUUsed:           newMetricVcenterClusterCPUUsed(settings.VcenterClusterCPUUsed),
		metricVcenterClusterMemoryAvailable:   newMetricVcenterClusterMemoryAvailable(settings.VcenterClusterMemoryAvailable),
		metricVcenterClusterMemoryEffective:   newMetricVcenterClusterMemoryEffective(settings.VcenterClusterMemoryEffective),
		metricVcenterClusterMemoryUsed:        newMetricVcenterClusterMemoryUsed(settings.VcenterClusterMemoryUsed),
		metricVcenterClusterVsanCongestions:   newMetricVcenterClusterVsanCongestions(settings.VcenterClusterVsanCongestions),
		metricVcenterClusterVsanLatencyAvg:    newMetricVcenterClusterVsanLatencyAvg(settings.VcenterClusterVsanLatencyAvg),
		metricVcenterClusterVsanOperations:    newMetricVcenterClusterVsanOperations(settings.VcenterClusterVsanOperations),
		metricVcenterClusterVsanOutstandingIo: newMetricVcenterClusterVsanOutstandingIo(settings.VcenterClusterVsanOutstandingIo),
		metricVcenterClusterVsanThroughput:    newMetricVcenterClusterVsanThroughput(settings.VcenterClusterVsanThroughput),
		metricVcenterDatacenterHostCount:      newMetricVcenterDatacenterHostCount(settings.VcenterDatacenterHostCount),
		metricVcenterDatacenterVMCount:        newMetricVcenterDatacenterVMCount(settings.VcenterDatacenterVMCount),
		metricVcenterDatastoreDiskUsage:       newMetricVcenterDatastoreDiskUsage(settings.VcenterDatastoreDiskUsage),
		metricVcenterDatastoreDiskUtilization: newMetricVcenterDatastoreDiskUtilization(settings.VcenterDatastoreDiskUtilization),
		metricVcenterHostCPUUsage:             newMetricVcenterHostCPUUsage(settings.VcenterHostCPUUsage),
		metricVcenterHostCPUUtilization:       newMetricVcenterHostCPUUtilization(settings.VcenterHostCPUUtilization),
		metricVcenterHostDiskLatencyAvg:       newMetricVcenterHostDiskLatencyAvg(settings.VcenterHostDiskLatencyAvg),
		metricVcenterHostDiskThroughput:       newMetricVcenterHostDiskThroughput(settings.VcenterHostDiskThroughput),
		metricVcenterHostMemoryUsage:          newMetricVcenterHostMemoryUsage(settings.VcenterHostMemoryUsage),
		metricVcenterHostMemoryUtilization:    newMetricVcenterHostMemoryUtilization(settings.VcenterHostMemoryUtilization),
		metricVcenterHostNetworkPackets:       newMetricVcenterHostNetworkPackets(settings.VcenterHostNetworkPackets),
		metricVcenterHostNetworkThroughput:    newMetricVcenterHostNetworkThroughput(settings.VcenterHostNetworkThroughput),
		metricVcenterHostVsanCacheHitRate:     newMetricVcenterHostVsanCacheHitRate(settings.VcenterHostVsanCacheHitRate),
		metricVcenterHostVsanCacheReads:       newMetricVcenterHostVsanCacheReads(settings.VcenterHostVsanCacheReads),
		metricVcenterHostVsanCongestions:      newMetricVcenterHostVsanCongestions(settings.VcenterHostVsanCongestions),
		metricVcenterHostVsanLatencyAvg:       newMetricVcenterHostVsanLatencyAvg(settings.VcenterHostVsanLatencyAvg),
		metricVcenterHostVsanOperations:       newMetricVcenterHostVsanOperations(settings.VcenterHostVsanOperations),
		metricVcenterHostVsanOutstandingIo:    newMetricVcenterHostVsanOutstandingIo(settings.VcenterHostVsanOutstandingIo),
		metricVcenterHostVsanThroughput:       newMetricVcenterHostVsanThroughput(settings.VcenterHostVsanThroughput),
		metricVcenterVMCPUUtilization:         newMetricVcenterVMCPUUtilization(settings.VcenterVMCPUUtilization),
		metricVcenterVMDiskLatency:            newMetricVcenterVMDiskLatency(settings.VcenterVMDiskLatency),
		metricVcenterVMDiskThroughput:         newMetricVcenterVMDiskThroughput(settings.VcenterVMDiskThroughput),
		metricVcenterVMDiskUsage:              newMetricVcenterVMDiskUsage(settings.VcenterVMDiskUsage),
		metricVcenterVMMemoryBallooned:        newMetricVcenterVMMemoryBallooned(settings.VcenterVMMemoryBallooned),
		metricVcenterVMMemoryUsage:            newMetricVcenterVMMemoryUsage(settings.VcenterVMMemoryUsage),
		metricVcenterVMNetworkPackets:         newMetricVcenterVMNetworkPackets(settings.VcenterVMNetworkPackets),
		metricVcenterVMNetworkThroughput:      newMetricVcenterVMNetworkThroughput(settings.VcenterVMNetworkThroughput),
		metricVcenterVMVsanCongestions:        newMetricVcenterVMVsanCongestions(settings.VcenterVMVsanCongestions),
		metricVcenterVMVsanLatencyAvg:         newMetricVcenterVMVsanLatencyAvg(settings.VcenterVMVsanLatencyAvg),
		metricVcenterVMVsanOperations:         newMetricVcenterVMVsanOperations(settings.VcenterVMVsanOperations),
		metricVcenterVMVsanOutstandingIo:      newMetricVcenterVMVsanOutstandingIo(settings.VcenterVMVsanOutstandingIo),
		metricVcenterVMVsanThroughput:         newMetricVcenterVMVsanThroughput(settings.VcenterVMVsanThroughput),
	}
	for _, op := range options {
		op(mb)
	}
	return mb
}

// Emit appends generated metrics to a pdata.MetricsSlice and updates the internal state to be ready for recording
// another set of data points. This function will be doing all transformations required to produce metric representation
// defined in metadata and user settings, e.g. delta/cumulative translation.
func (mb *MetricsBuilder) Emit(metrics pdata.MetricSlice) {
	mb.metricVcenterClusterCPUAvailable.emit(metrics)
	mb.metricVcenterClusterCPUEffective.emit(metrics)
	mb.metricVcenterClusterCPUUsed.emit(metrics)
	mb.metricVcenterClusterMemoryAvailable.emit(metrics)
	mb.metricVcenterClusterMemoryEffective.emit(metrics)
	mb.metricVcenterClusterMemoryUsed.emit(metrics)
	mb.metricVcenterClusterVsanCongestions.emit(metrics)
	mb.metricVcenterClusterVsanLatencyAvg.emit(metrics)
	mb.metricVcenterClusterVsanOperations.emit(metrics)
	mb.metricVcenterClusterVsanOutstandingIo.emit(metrics)
	mb.metricVcenterClusterVsanThroughput.emit(metrics)
	mb.metricVcenterDatacenterHostCount.emit(metrics)
	mb.metricVcenterDatacenterVMCount.emit(metrics)
	mb.metricVcenterDatastoreDiskUsage.emit(metrics)
	mb.metricVcenterDatastoreDiskUtilization.emit(metrics)
	mb.metricVcenterHostCPUUsage.emit(metrics)
	mb.metricVcenterHostCPUUtilization.emit(metrics)
	mb.metricVcenterHostDiskLatencyAvg.emit(metrics)
	mb.metricVcenterHostDiskThroughput.emit(metrics)
	mb.metricVcenterHostMemoryUsage.emit(metrics)
	mb.metricVcenterHostMemoryUtilization.emit(metrics)
	mb.metricVcenterHostNetworkPackets.emit(metrics)
	mb.metricVcenterHostNetworkThroughput.emit(metrics)
	mb.metricVcenterHostVsanCacheHitRate.emit(metrics)
	mb.metricVcenterHostVsanCacheReads.emit(metrics)
	mb.metricVcenterHostVsanCongestions.emit(metrics)
	mb.metricVcenterHostVsanLatencyAvg.emit(metrics)
	mb.metricVcenterHostVsanOperations.emit(metrics)
	mb.metricVcenterHostVsanOutstandingIo.emit(metrics)
	mb.metricVcenterHostVsanThroughput.emit(metrics)
	mb.metricVcenterVMCPUUtilization.emit(metrics)
	mb.metricVcenterVMDiskLatency.emit(metrics)
	mb.metricVcenterVMDiskThroughput.emit(metrics)
	mb.metricVcenterVMDiskUsage.emit(metrics)
	mb.metricVcenterVMMemoryBallooned.emit(metrics)
	mb.metricVcenterVMMemoryUsage.emit(metrics)
	mb.metricVcenterVMNetworkPackets.emit(metrics)
	mb.metricVcenterVMNetworkThroughput.emit(metrics)
	mb.metricVcenterVMVsanCongestions.emit(metrics)
	mb.metricVcenterVMVsanLatencyAvg.emit(metrics)
	mb.metricVcenterVMVsanOperations.emit(metrics)
	mb.metricVcenterVMVsanOutstandingIo.emit(metrics)
	mb.metricVcenterVMVsanThroughput.emit(metrics)
}

// RecordVcenterClusterCPUAvailableDataPoint adds a data point to vcenter.cluster.cpu.available metric.
func (mb *MetricsBuilder) RecordVcenterClusterCPUAvailableDataPoint(ts pdata.Timestamp, val int64, clusterAttributeValue string) {
	mb.metricVcenterClusterCPUAvailable.recordDataPoint(mb.startTime, ts, val, clusterAttributeValue)
}

// RecordVcenterClusterCPUEffectiveDataPoint adds a data point to vcenter.cluster.cpu.effective metric.
func (mb *MetricsBuilder) RecordVcenterClusterCPUEffectiveDataPoint(ts pdata.Timestamp, val int64, clusterAttributeValue string) {
	mb.metricVcenterClusterCPUEffective.recordDataPoint(mb.startTime, ts, val, clusterAttributeValue)
}

// RecordVcenterClusterCPUUsedDataPoint adds a data point to vcenter.cluster.cpu.used metric.
func (mb *MetricsBuilder) RecordVcenterClusterCPUUsedDataPoint(ts pdata.Timestamp, val int64, clusterAttributeValue string) {
	mb.metricVcenterClusterCPUUsed.recordDataPoint(mb.startTime, ts, val, clusterAttributeValue)
}

// RecordVcenterClusterMemoryAvailableDataPoint adds a data point to vcenter.cluster.memory.available metric.
func (mb *MetricsBuilder) RecordVcenterClusterMemoryAvailableDataPoint(ts pdata.Timestamp, val int64, clusterAttributeValue string) {
	mb.metricVcenterClusterMemoryAvailable.recordDataPoint(mb.startTime, ts, val, clusterAttributeValue)
}

// RecordVcenterClusterMemoryEffectiveDataPoint adds a data point to vcenter.cluster.memory.effective metric.
func (mb *MetricsBuilder) RecordVcenterClusterMemoryEffectiveDataPoint(ts pdata.Timestamp, val int64, clusterAttributeValue string) {
	mb.metricVcenterClusterMemoryEffective.recordDataPoint(mb.startTime, ts, val, clusterAttributeValue)
}

// RecordVcenterClusterMemoryUsedDataPoint adds a data point to vcenter.cluster.memory.used metric.
func (mb *MetricsBuilder) RecordVcenterClusterMemoryUsedDataPoint(ts pdata.Timestamp, val int64, clusterAttributeValue string) {
	mb.metricVcenterClusterMemoryUsed.recordDataPoint(mb.startTime, ts, val, clusterAttributeValue)
}

// RecordVcenterClusterVsanCongestionsDataPoint adds a data point to vcenter.cluster.vsan.congestions metric.
func (mb *MetricsBuilder) RecordVcenterClusterVsanCongestionsDataPoint(ts pdata.Timestamp, val int64, clusterAttributeValue string) {
	mb.metricVcenterClusterVsanCongestions.recordDataPoint(mb.startTime, ts, val, clusterAttributeValue)
}

// RecordVcenterClusterVsanLatencyAvgDataPoint adds a data point to vcenter.cluster.vsan.latency.avg metric.
func (mb *MetricsBuilder) RecordVcenterClusterVsanLatencyAvgDataPoint(ts pdata.Timestamp, val int64, vsanLatencyTypeAttributeValue string, clusterAttributeValue string) {
	mb.metricVcenterClusterVsanLatencyAvg.recordDataPoint(mb.startTime, ts, val, vsanLatencyTypeAttributeValue, clusterAttributeValue)
}

// RecordVcenterClusterVsanOperationsDataPoint adds a data point to vcenter.cluster.vsan.operations metric.
func (mb *MetricsBuilder) RecordVcenterClusterVsanOperationsDataPoint(ts pdata.Timestamp, val int64, vsanOperationTypeAttributeValue string, clusterAttributeValue string) {
	mb.metricVcenterClusterVsanOperations.recordDataPoint(mb.startTime, ts, val, vsanOperationTypeAttributeValue, clusterAttributeValue)
}

// RecordVcenterClusterVsanOutstandingIoDataPoint adds a data point to vcenter.cluster.vsan.outstanding_io metric.
func (mb *MetricsBuilder) RecordVcenterClusterVsanOutstandingIoDataPoint(ts pdata.Timestamp, val int64, clusterAttributeValue string) {
	mb.metricVcenterClusterVsanOutstandingIo.recordDataPoint(mb.startTime, ts, val, clusterAttributeValue)
}

// RecordVcenterClusterVsanThroughputDataPoint adds a data point to vcenter.cluster.vsan.throughput metric.
func (mb *MetricsBuilder) RecordVcenterClusterVsanThroughputDataPoint(ts pdata.Timestamp, val int64, vsanThroughputDirectionAttributeValue string, clusterAttributeValue string) {
	mb.metricVcenterClusterVsanThroughput.recordDataPoint(mb.startTime, ts, val, vsanThroughputDirectionAttributeValue, clusterAttributeValue)
}

// RecordVcenterDatacenterHostCountDataPoint adds a data point to vcenter.datacenter.host.count metric.
func (mb *MetricsBuilder) RecordVcenterDatacenterHostCountDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVcenterDatacenterHostCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordVcenterDatacenterVMCountDataPoint adds a data point to vcenter.datacenter.vm.count metric.
func (mb *MetricsBuilder) RecordVcenterDatacenterVMCountDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVcenterDatacenterVMCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordVcenterDatastoreDiskUsageDataPoint adds a data point to vcenter.datastore.disk.usage metric.
func (mb *MetricsBuilder) RecordVcenterDatastoreDiskUsageDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVcenterDatastoreDiskUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordVcenterDatastoreDiskUtilizationDataPoint adds a data point to vcenter.datastore.disk.utilization metric.
func (mb *MetricsBuilder) RecordVcenterDatastoreDiskUtilizationDataPoint(ts pdata.Timestamp, val float64) {
	mb.metricVcenterDatastoreDiskUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordVcenterHostCPUUsageDataPoint adds a data point to vcenter.host.cpu.usage metric.
func (mb *MetricsBuilder) RecordVcenterHostCPUUsageDataPoint(ts pdata.Timestamp, val int64, hostnameAttributeValue string) {
	mb.metricVcenterHostCPUUsage.recordDataPoint(mb.startTime, ts, val, hostnameAttributeValue)
}

// RecordVcenterHostCPUUtilizationDataPoint adds a data point to vcenter.host.cpu.utilization metric.
func (mb *MetricsBuilder) RecordVcenterHostCPUUtilizationDataPoint(ts pdata.Timestamp, val float64, hostnameAttributeValue string) {
	mb.metricVcenterHostCPUUtilization.recordDataPoint(mb.startTime, ts, val, hostnameAttributeValue)
}

// RecordVcenterHostDiskLatencyAvgDataPoint adds a data point to vcenter.host.disk.latency.avg metric.
func (mb *MetricsBuilder) RecordVcenterHostDiskLatencyAvgDataPoint(ts pdata.Timestamp, val int64, hostnameAttributeValue string) {
	mb.metricVcenterHostDiskLatencyAvg.recordDataPoint(mb.startTime, ts, val, hostnameAttributeValue)
}

// RecordVcenterHostDiskThroughputDataPoint adds a data point to vcenter.host.disk.throughput metric.
func (mb *MetricsBuilder) RecordVcenterHostDiskThroughputDataPoint(ts pdata.Timestamp, val int64, hostnameAttributeValue string) {
	mb.metricVcenterHostDiskThroughput.recordDataPoint(mb.startTime, ts, val, hostnameAttributeValue)
}

// RecordVcenterHostMemoryUsageDataPoint adds a data point to vcenter.host.memory.usage metric.
func (mb *MetricsBuilder) RecordVcenterHostMemoryUsageDataPoint(ts pdata.Timestamp, val int64, hostnameAttributeValue string) {
	mb.metricVcenterHostMemoryUsage.recordDataPoint(mb.startTime, ts, val, hostnameAttributeValue)
}

// RecordVcenterHostMemoryUtilizationDataPoint adds a data point to vcenter.host.memory.utilization metric.
func (mb *MetricsBuilder) RecordVcenterHostMemoryUtilizationDataPoint(ts pdata.Timestamp, val float64, hostnameAttributeValue string) {
	mb.metricVcenterHostMemoryUtilization.recordDataPoint(mb.startTime, ts, val, hostnameAttributeValue)
}

// RecordVcenterHostNetworkPacketsDataPoint adds a data point to vcenter.host.network.packets metric.
func (mb *MetricsBuilder) RecordVcenterHostNetworkPacketsDataPoint(ts pdata.Timestamp, val int64, hostnameAttributeValue string) {
	mb.metricVcenterHostNetworkPackets.recordDataPoint(mb.startTime, ts, val, hostnameAttributeValue)
}

// RecordVcenterHostNetworkThroughputDataPoint adds a data point to vcenter.host.network.throughput metric.
func (mb *MetricsBuilder) RecordVcenterHostNetworkThroughputDataPoint(ts pdata.Timestamp, val int64, hostnameAttributeValue string) {
	mb.metricVcenterHostNetworkThroughput.recordDataPoint(mb.startTime, ts, val, hostnameAttributeValue)
}

// RecordVcenterHostVsanCacheHitRateDataPoint adds a data point to vcenter.host.vsan.cache.hit_rate metric.
func (mb *MetricsBuilder) RecordVcenterHostVsanCacheHitRateDataPoint(ts pdata.Timestamp, val float64, hostnameAttributeValue string) {
	mb.metricVcenterHostVsanCacheHitRate.recordDataPoint(mb.startTime, ts, val, hostnameAttributeValue)
}

// RecordVcenterHostVsanCacheReadsDataPoint adds a data point to vcenter.host.vsan.cache.reads metric.
func (mb *MetricsBuilder) RecordVcenterHostVsanCacheReadsDataPoint(ts pdata.Timestamp, val int64, hostnameAttributeValue string) {
	mb.metricVcenterHostVsanCacheReads.recordDataPoint(mb.startTime, ts, val, hostnameAttributeValue)
}

// RecordVcenterHostVsanCongestionsDataPoint adds a data point to vcenter.host.vsan.congestions metric.
func (mb *MetricsBuilder) RecordVcenterHostVsanCongestionsDataPoint(ts pdata.Timestamp, val int64, hostnameAttributeValue string) {
	mb.metricVcenterHostVsanCongestions.recordDataPoint(mb.startTime, ts, val, hostnameAttributeValue)
}

// RecordVcenterHostVsanLatencyAvgDataPoint adds a data point to vcenter.host.vsan.latency.avg metric.
func (mb *MetricsBuilder) RecordVcenterHostVsanLatencyAvgDataPoint(ts pdata.Timestamp, val int64, hostnameAttributeValue string, vsanLatencyTypeAttributeValue string) {
	mb.metricVcenterHostVsanLatencyAvg.recordDataPoint(mb.startTime, ts, val, hostnameAttributeValue, vsanLatencyTypeAttributeValue)
}

// RecordVcenterHostVsanOperationsDataPoint adds a data point to vcenter.host.vsan.operations metric.
func (mb *MetricsBuilder) RecordVcenterHostVsanOperationsDataPoint(ts pdata.Timestamp, val int64, hostnameAttributeValue string, vsanOperationTypeAttributeValue string) {
	mb.metricVcenterHostVsanOperations.recordDataPoint(mb.startTime, ts, val, hostnameAttributeValue, vsanOperationTypeAttributeValue)
}

// RecordVcenterHostVsanOutstandingIoDataPoint adds a data point to vcenter.host.vsan.outstanding_io metric.
func (mb *MetricsBuilder) RecordVcenterHostVsanOutstandingIoDataPoint(ts pdata.Timestamp, val int64, hostnameAttributeValue string) {
	mb.metricVcenterHostVsanOutstandingIo.recordDataPoint(mb.startTime, ts, val, hostnameAttributeValue)
}

// RecordVcenterHostVsanThroughputDataPoint adds a data point to vcenter.host.vsan.throughput metric.
func (mb *MetricsBuilder) RecordVcenterHostVsanThroughputDataPoint(ts pdata.Timestamp, val int64, hostnameAttributeValue string, vsanThroughputDirectionAttributeValue string) {
	mb.metricVcenterHostVsanThroughput.recordDataPoint(mb.startTime, ts, val, hostnameAttributeValue, vsanThroughputDirectionAttributeValue)
}

// RecordVcenterVMCPUUtilizationDataPoint adds a data point to vcenter.vm.cpu.utilization metric.
func (mb *MetricsBuilder) RecordVcenterVMCPUUtilizationDataPoint(ts pdata.Timestamp, val float64, instanceNameAttributeValue string) {
	mb.metricVcenterVMCPUUtilization.recordDataPoint(mb.startTime, ts, val, instanceNameAttributeValue)
}

// RecordVcenterVMDiskLatencyDataPoint adds a data point to vcenter.vm.disk.latency metric.
func (mb *MetricsBuilder) RecordVcenterVMDiskLatencyDataPoint(ts pdata.Timestamp, val int64, instanceNameAttributeValue string) {
	mb.metricVcenterVMDiskLatency.recordDataPoint(mb.startTime, ts, val, instanceNameAttributeValue)
}

// RecordVcenterVMDiskThroughputDataPoint adds a data point to vcenter.vm.disk.throughput metric.
func (mb *MetricsBuilder) RecordVcenterVMDiskThroughputDataPoint(ts pdata.Timestamp, val int64, instanceNameAttributeValue string) {
	mb.metricVcenterVMDiskThroughput.recordDataPoint(mb.startTime, ts, val, instanceNameAttributeValue)
}

// RecordVcenterVMDiskUsageDataPoint adds a data point to vcenter.vm.disk.usage metric.
func (mb *MetricsBuilder) RecordVcenterVMDiskUsageDataPoint(ts pdata.Timestamp, val int64, instanceNameAttributeValue string) {
	mb.metricVcenterVMDiskUsage.recordDataPoint(mb.startTime, ts, val, instanceNameAttributeValue)
}

// RecordVcenterVMMemoryBalloonedDataPoint adds a data point to vcenter.vm.memory.ballooned metric.
func (mb *MetricsBuilder) RecordVcenterVMMemoryBalloonedDataPoint(ts pdata.Timestamp, val int64, instanceNameAttributeValue string) {
	mb.metricVcenterVMMemoryBallooned.recordDataPoint(mb.startTime, ts, val, instanceNameAttributeValue)
}

// RecordVcenterVMMemoryUsageDataPoint adds a data point to vcenter.vm.memory.usage metric.
func (mb *MetricsBuilder) RecordVcenterVMMemoryUsageDataPoint(ts pdata.Timestamp, val int64, instanceNameAttributeValue string) {
	mb.metricVcenterVMMemoryUsage.recordDataPoint(mb.startTime, ts, val, instanceNameAttributeValue)
}

// RecordVcenterVMNetworkPacketsDataPoint adds a data point to vcenter.vm.network.packets metric.
func (mb *MetricsBuilder) RecordVcenterVMNetworkPacketsDataPoint(ts pdata.Timestamp, val int64, instanceNameAttributeValue string) {
	mb.metricVcenterVMNetworkPackets.recordDataPoint(mb.startTime, ts, val, instanceNameAttributeValue)
}

// RecordVcenterVMNetworkThroughputDataPoint adds a data point to vcenter.vm.network.throughput metric.
func (mb *MetricsBuilder) RecordVcenterVMNetworkThroughputDataPoint(ts pdata.Timestamp, val int64, instanceNameAttributeValue string) {
	mb.metricVcenterVMNetworkThroughput.recordDataPoint(mb.startTime, ts, val, instanceNameAttributeValue)
}

// RecordVcenterVMVsanCongestionsDataPoint adds a data point to vcenter.vm.vsan.congestions metric.
func (mb *MetricsBuilder) RecordVcenterVMVsanCongestionsDataPoint(ts pdata.Timestamp, val int64, instanceNameAttributeValue string) {
	mb.metricVcenterVMVsanCongestions.recordDataPoint(mb.startTime, ts, val, instanceNameAttributeValue)
}

// RecordVcenterVMVsanLatencyAvgDataPoint adds a data point to vcenter.vm.vsan.latency.avg metric.
func (mb *MetricsBuilder) RecordVcenterVMVsanLatencyAvgDataPoint(ts pdata.Timestamp, val int64, instanceNameAttributeValue string, vsanLatencyTypeAttributeValue string) {
	mb.metricVcenterVMVsanLatencyAvg.recordDataPoint(mb.startTime, ts, val, instanceNameAttributeValue, vsanLatencyTypeAttributeValue)
}

// RecordVcenterVMVsanOperationsDataPoint adds a data point to vcenter.vm.vsan.operations metric.
func (mb *MetricsBuilder) RecordVcenterVMVsanOperationsDataPoint(ts pdata.Timestamp, val int64, instanceNameAttributeValue string, vsanOperationTypeAttributeValue string) {
	mb.metricVcenterVMVsanOperations.recordDataPoint(mb.startTime, ts, val, instanceNameAttributeValue, vsanOperationTypeAttributeValue)
}

// RecordVcenterVMVsanOutstandingIoDataPoint adds a data point to vcenter.vm.vsan.outstanding_io metric.
func (mb *MetricsBuilder) RecordVcenterVMVsanOutstandingIoDataPoint(ts pdata.Timestamp, val int64, instanceNameAttributeValue string) {
	mb.metricVcenterVMVsanOutstandingIo.recordDataPoint(mb.startTime, ts, val, instanceNameAttributeValue)
}

// RecordVcenterVMVsanThroughputDataPoint adds a data point to vcenter.vm.vsan.throughput metric.
func (mb *MetricsBuilder) RecordVcenterVMVsanThroughputDataPoint(ts pdata.Timestamp, val int64, instanceNameAttributeValue string, vsanThroughputDirectionAttributeValue string) {
	mb.metricVcenterVMVsanThroughput.recordDataPoint(mb.startTime, ts, val, instanceNameAttributeValue, vsanThroughputDirectionAttributeValue)
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...metricBuilderOption) {
	mb.startTime = pdata.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op(mb)
	}
}

// NewMetricData creates new pdata.Metrics and sets the InstrumentationLibrary
// name on the ResourceMetrics.
func (mb *MetricsBuilder) NewMetricData() pdata.Metrics {
	md := pdata.NewMetrics()
	rm := md.ResourceMetrics().AppendEmpty()
	ilm := rm.InstrumentationLibraryMetrics().AppendEmpty()
	ilm.InstrumentationLibrary().SetName("otelcol/vmwarevcenterreceiver")
	return md
}

// Attributes contains the possible metric attributes that can be used.
var Attributes = struct {
	// Cluster (The name of the vCenter Cluster)
	Cluster string
	// Datastore (The name of the Datastore)
	Datastore string
	// Hostname (The name of the ESXi Host System)
	Hostname string
	// InstanceName (The name of the Virtual Machine)
	InstanceName string
	// VsanLatencyType (The type of vSAN latency.)
	VsanLatencyType string
	// VsanOperationType (The type of vSAN operation.)
	VsanOperationType string
	// VsanThroughputDirection (The type of vSAN throughput.)
	VsanThroughputDirection string
}{
	"cluster",
	"datastore",
	"hostname",
	"instance_name",
	"type",
	"type",
	"direction",
}

// A is an alias for Attributes.
var A = Attributes

// AttributeVsanLatencyType are the possible values that the attribute "vsan_latency_type" can have.
var AttributeVsanLatencyType = struct {
	Read  string
	Write string
}{
	"read",
	"write",
}

// AttributeVsanOperationType are the possible values that the attribute "vsan_operation_type" can have.
var AttributeVsanOperationType = struct {
	Read  string
	Write string
	Unmap string
}{
	"read",
	"write",
	"unmap",
}

// AttributeVsanThroughputDirection are the possible values that the attribute "vsan_throughput_direction" can have.
var AttributeVsanThroughputDirection = struct {
	Read  string
	Write string
}{
	"read",
	"write",
}
