// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/filter"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
	"go.opentelemetry.io/collector/receiver"
)

var MetricsInfo = metricsInfo{
	NewrelicoracledbAsmDiskgroupFreeMb: metricInfo{
		Name: "newrelicoracledb.asm.diskgroup.free_mb",
	},
	NewrelicoracledbAsmDiskgroupOfflineDisks: metricInfo{
		Name: "newrelicoracledb.asm.diskgroup.offline_disks",
	},
	NewrelicoracledbAsmDiskgroupTotalMb: metricInfo{
		Name: "newrelicoracledb.asm.diskgroup.total_mb",
	},
	NewrelicoracledbConnectionActiveSessions: metricInfo{
		Name: "newrelicoracledb.connection.active_sessions",
	},
	NewrelicoracledbConnectionBlockingSessions: metricInfo{
		Name: "newrelicoracledb.connection.blocking_sessions",
	},
	NewrelicoracledbConnectionBytesReceived: metricInfo{
		Name: "newrelicoracledb.connection.bytes_received",
	},
	NewrelicoracledbConnectionBytesSent: metricInfo{
		Name: "newrelicoracledb.connection.bytes_sent",
	},
	NewrelicoracledbConnectionCircuits: metricInfo{
		Name: "newrelicoracledb.connection.circuits",
	},
	NewrelicoracledbConnectionDispatchers: metricInfo{
		Name: "newrelicoracledb.connection.dispatchers",
	},
	NewrelicoracledbConnectionExecuteCount: metricInfo{
		Name: "newrelicoracledb.connection.execute_count",
	},
	NewrelicoracledbConnectionInactiveSessions: metricInfo{
		Name: "newrelicoracledb.connection.inactive_sessions",
	},
	NewrelicoracledbConnectionLogonsCumulative: metricInfo{
		Name: "newrelicoracledb.connection.logons_cumulative",
	},
	NewrelicoracledbConnectionLogonsCurrent: metricInfo{
		Name: "newrelicoracledb.connection.logons_current",
	},
	NewrelicoracledbConnectionParseCountHard: metricInfo{
		Name: "newrelicoracledb.connection.parse_count_hard",
	},
	NewrelicoracledbConnectionParseCountTotal: metricInfo{
		Name: "newrelicoracledb.connection.parse_count_total",
	},
	NewrelicoracledbConnectionResourceCurrentUtilization: metricInfo{
		Name: "newrelicoracledb.connection.resource_current_utilization",
	},
	NewrelicoracledbConnectionResourceLimit: metricInfo{
		Name: "newrelicoracledb.connection.resource_limit",
	},
	NewrelicoracledbConnectionResourceMaxUtilization: metricInfo{
		Name: "newrelicoracledb.connection.resource_max_utilization",
	},
	NewrelicoracledbConnectionSessionCPUUsage: metricInfo{
		Name: "newrelicoracledb.connection.session_cpu_usage",
	},
	NewrelicoracledbConnectionSessionIdleTime: metricInfo{
		Name: "newrelicoracledb.connection.session_idle_time",
	},
	NewrelicoracledbConnectionSessionLogicalReads: metricInfo{
		Name: "newrelicoracledb.connection.session_logical_reads",
	},
	NewrelicoracledbConnectionSessionPgaMemory: metricInfo{
		Name: "newrelicoracledb.connection.session_pga_memory",
	},
	NewrelicoracledbConnectionSessionsByStatus: metricInfo{
		Name: "newrelicoracledb.connection.sessions_by_status",
	},
	NewrelicoracledbConnectionSessionsByType: metricInfo{
		Name: "newrelicoracledb.connection.sessions_by_type",
	},
	NewrelicoracledbConnectionSharedServers: metricInfo{
		Name: "newrelicoracledb.connection.shared_servers",
	},
	NewrelicoracledbConnectionSqlnetRoundtrips: metricInfo{
		Name: "newrelicoracledb.connection.sqlnet_roundtrips",
	},
	NewrelicoracledbConnectionTotalSessions: metricInfo{
		Name: "newrelicoracledb.connection.total_sessions",
	},
	NewrelicoracledbConnectionUserCommits: metricInfo{
		Name: "newrelicoracledb.connection.user_commits",
	},
	NewrelicoracledbConnectionUserRollbacks: metricInfo{
		Name: "newrelicoracledb.connection.user_rollbacks",
	},
	NewrelicoracledbConnectionWaitEventAvgWaitTime: metricInfo{
		Name: "newrelicoracledb.connection.wait_event_avg_wait_time",
	},
	NewrelicoracledbConnectionWaitEventTimeWaited: metricInfo{
		Name: "newrelicoracledb.connection.wait_event_time_waited",
	},
	NewrelicoracledbConnectionWaitEventTotalWaits: metricInfo{
		Name: "newrelicoracledb.connection.wait_event_total_waits",
	},
	NewrelicoracledbConnectionWaitEvents: metricInfo{
		Name: "newrelicoracledb.connection.wait_events",
	},
	NewrelicoracledbContainerRestricted: metricInfo{
		Name: "newrelicoracledb.container.restricted",
	},
	NewrelicoracledbContainerStatus: metricInfo{
		Name: "newrelicoracledb.container.status",
	},
	NewrelicoracledbDatafileAutoextensible: metricInfo{
		Name: "newrelicoracledb.datafile.autoextensible",
	},
	NewrelicoracledbDatafileSizeBytes: metricInfo{
		Name: "newrelicoracledb.datafile.size_bytes",
	},
	NewrelicoracledbDatafileUsedBytes: metricInfo{
		Name: "newrelicoracledb.datafile.used_bytes",
	},
	NewrelicoracledbDbID: metricInfo{
		Name: "newrelicoracledb.db_id",
	},
	NewrelicoracledbDiskBlocksRead: metricInfo{
		Name: "newrelicoracledb.disk.blocks_read",
	},
	NewrelicoracledbDiskBlocksWritten: metricInfo{
		Name: "newrelicoracledb.disk.blocks_written",
	},
	NewrelicoracledbDiskReadTimeMilliseconds: metricInfo{
		Name: "newrelicoracledb.disk.read_time_milliseconds",
	},
	NewrelicoracledbDiskReads: metricInfo{
		Name: "newrelicoracledb.disk.reads",
	},
	NewrelicoracledbDiskWriteTimeMilliseconds: metricInfo{
		Name: "newrelicoracledb.disk.write_time_milliseconds",
	},
	NewrelicoracledbDiskWrites: metricInfo{
		Name: "newrelicoracledb.disk.writes",
	},
	NewrelicoracledbGlobalName: metricInfo{
		Name: "newrelicoracledb.global_name",
	},
	NewrelicoracledbLockedAccounts: metricInfo{
		Name: "newrelicoracledb.locked_accounts",
	},
	NewrelicoracledbLongRunningQueries: metricInfo{
		Name: "newrelicoracledb.long_running_queries",
	},
	NewrelicoracledbMemoryPgaAllocatedBytes: metricInfo{
		Name: "newrelicoracledb.memory.pga_allocated_bytes",
	},
	NewrelicoracledbMemoryPgaFreeableBytes: metricInfo{
		Name: "newrelicoracledb.memory.pga_freeable_bytes",
	},
	NewrelicoracledbMemoryPgaInUseBytes: metricInfo{
		Name: "newrelicoracledb.memory.pga_in_use_bytes",
	},
	NewrelicoracledbMemoryPgaMaxSizeBytes: metricInfo{
		Name: "newrelicoracledb.memory.pga_max_size_bytes",
	},
	NewrelicoracledbMemorySgaSharedPoolLibraryCacheSharableBytes: metricInfo{
		Name: "newrelicoracledb.memory.sga_shared_pool_library_cache_sharable_bytes",
	},
	NewrelicoracledbMemorySgaSharedPoolLibraryCacheUserBytes: metricInfo{
		Name: "newrelicoracledb.memory.sga_shared_pool_library_cache_user_bytes",
	},
	NewrelicoracledbMemorySgaUgaTotalBytes: metricInfo{
		Name: "newrelicoracledb.memory.sga_uga_total_bytes",
	},
	NewrelicoracledbPdbActiveParallelSessions: metricInfo{
		Name: "newrelicoracledb.pdb.active_parallel_sessions",
	},
	NewrelicoracledbPdbActiveSerialSessions: metricInfo{
		Name: "newrelicoracledb.pdb.active_serial_sessions",
	},
	NewrelicoracledbPdbAverageActiveSessions: metricInfo{
		Name: "newrelicoracledb.pdb.average_active_sessions",
	},
	NewrelicoracledbPdbBackgroundCPUUsagePerSecond: metricInfo{
		Name: "newrelicoracledb.pdb.background_cpu_usage_per_second",
	},
	NewrelicoracledbPdbBackgroundTimePerSecond: metricInfo{
		Name: "newrelicoracledb.pdb.background_time_per_second",
	},
	NewrelicoracledbPdbBlockChangesPerSecond: metricInfo{
		Name: "newrelicoracledb.pdb.block_changes_per_second",
	},
	NewrelicoracledbPdbBlockChangesPerTransaction: metricInfo{
		Name: "newrelicoracledb.pdb.block_changes_per_transaction",
	},
	NewrelicoracledbPdbCPUTimeRatio: metricInfo{
		Name: "newrelicoracledb.pdb.cpu_time_ratio",
	},
	NewrelicoracledbPdbCPUUsagePerSecond: metricInfo{
		Name: "newrelicoracledb.pdb.cpu_usage_per_second",
	},
	NewrelicoracledbPdbCPUUsagePerTransaction: metricInfo{
		Name: "newrelicoracledb.pdb.cpu_usage_per_transaction",
	},
	NewrelicoracledbPdbCurrentLogons: metricInfo{
		Name: "newrelicoracledb.pdb.current_logons",
	},
	NewrelicoracledbPdbCurrentOpenCursors: metricInfo{
		Name: "newrelicoracledb.pdb.current_open_cursors",
	},
	NewrelicoracledbPdbDbPhysicalReadBytesPerSecond: metricInfo{
		Name: "newrelicoracledb.pdb.db_physical_read_bytes_per_second",
	},
	NewrelicoracledbPdbDbPhysicalReadsPerSecond: metricInfo{
		Name: "newrelicoracledb.pdb.db_physical_reads_per_second",
	},
	NewrelicoracledbPdbDbPhysicalWriteBytesPerSecond: metricInfo{
		Name: "newrelicoracledb.pdb.db_physical_write_bytes_per_second",
	},
	NewrelicoracledbPdbDbPhysicalWritesPerSecond: metricInfo{
		Name: "newrelicoracledb.pdb.db_physical_writes_per_second",
	},
	NewrelicoracledbPdbExecuteWithoutParseRatio: metricInfo{
		Name: "newrelicoracledb.pdb.execute_without_parse_ratio",
	},
	NewrelicoracledbPdbExecutionsPerSecond: metricInfo{
		Name: "newrelicoracledb.pdb.executions_per_second",
	},
	NewrelicoracledbPdbExecutionsPerTransaction: metricInfo{
		Name: "newrelicoracledb.pdb.executions_per_transaction",
	},
	NewrelicoracledbPdbHardParseCountPerSecond: metricInfo{
		Name: "newrelicoracledb.pdb.hard_parse_count_per_second",
	},
	NewrelicoracledbPdbHardParseCountPerTransaction: metricInfo{
		Name: "newrelicoracledb.pdb.hard_parse_count_per_transaction",
	},
	NewrelicoracledbPdbLogicalReadsPerSecond: metricInfo{
		Name: "newrelicoracledb.pdb.logical_reads_per_second",
	},
	NewrelicoracledbPdbLogicalReadsPerTransaction: metricInfo{
		Name: "newrelicoracledb.pdb.logical_reads_per_transaction",
	},
	NewrelicoracledbPdbLogonsPerSecond: metricInfo{
		Name: "newrelicoracledb.pdb.logons_per_second",
	},
	NewrelicoracledbPdbLogonsPerTransaction: metricInfo{
		Name: "newrelicoracledb.pdb.logons_per_transaction",
	},
	NewrelicoracledbPdbNetworkTrafficBytePerSecond: metricInfo{
		Name: "newrelicoracledb.pdb.network_traffic_byte_per_second",
	},
	NewrelicoracledbPdbOpenCursorsPerSecond: metricInfo{
		Name: "newrelicoracledb.pdb.open_cursors_per_second",
	},
	NewrelicoracledbPdbOpenCursorsPerTransaction: metricInfo{
		Name: "newrelicoracledb.pdb.open_cursors_per_transaction",
	},
	NewrelicoracledbPdbOpenMode: metricInfo{
		Name: "newrelicoracledb.pdb.open_mode",
	},
	NewrelicoracledbPdbParseFailureCountPerSecond: metricInfo{
		Name: "newrelicoracledb.pdb.parse_failure_count_per_second",
	},
	NewrelicoracledbPdbPhysicalReadBytesPerSecond: metricInfo{
		Name: "newrelicoracledb.pdb.physical_read_bytes_per_second",
	},
	NewrelicoracledbPdbPhysicalReadsPerTransaction: metricInfo{
		Name: "newrelicoracledb.pdb.physical_reads_per_transaction",
	},
	NewrelicoracledbPdbPhysicalWriteBytesPerSecond: metricInfo{
		Name: "newrelicoracledb.pdb.physical_write_bytes_per_second",
	},
	NewrelicoracledbPdbPhysicalWritesPerTransaction: metricInfo{
		Name: "newrelicoracledb.pdb.physical_writes_per_transaction",
	},
	NewrelicoracledbPdbRedoGeneratedBytesPerSecond: metricInfo{
		Name: "newrelicoracledb.pdb.redo_generated_bytes_per_second",
	},
	NewrelicoracledbPdbRedoGeneratedBytesPerTransaction: metricInfo{
		Name: "newrelicoracledb.pdb.redo_generated_bytes_per_transaction",
	},
	NewrelicoracledbPdbResponseTimePerTransaction: metricInfo{
		Name: "newrelicoracledb.pdb.response_time_per_transaction",
	},
	NewrelicoracledbPdbSessionCount: metricInfo{
		Name: "newrelicoracledb.pdb.session_count",
	},
	NewrelicoracledbPdbSoftParseRatio: metricInfo{
		Name: "newrelicoracledb.pdb.soft_parse_ratio",
	},
	NewrelicoracledbPdbSQLServiceResponseTime: metricInfo{
		Name: "newrelicoracledb.pdb.sql_service_response_time",
	},
	NewrelicoracledbPdbStatus: metricInfo{
		Name: "newrelicoracledb.pdb.status",
	},
	NewrelicoracledbPdbTotalParseCountPerSecond: metricInfo{
		Name: "newrelicoracledb.pdb.total_parse_count_per_second",
	},
	NewrelicoracledbPdbTotalParseCountPerTransaction: metricInfo{
		Name: "newrelicoracledb.pdb.total_parse_count_per_transaction",
	},
	NewrelicoracledbPdbTotalSizeBytes: metricInfo{
		Name: "newrelicoracledb.pdb.total_size_bytes",
	},
	NewrelicoracledbPdbTransactionsPerSecond: metricInfo{
		Name: "newrelicoracledb.pdb.transactions_per_second",
	},
	NewrelicoracledbPdbUserCallsPerSecond: metricInfo{
		Name: "newrelicoracledb.pdb.user_calls_per_second",
	},
	NewrelicoracledbPdbUserCallsPerTransaction: metricInfo{
		Name: "newrelicoracledb.pdb.user_calls_per_transaction",
	},
	NewrelicoracledbPdbUserCommitsPerSecond: metricInfo{
		Name: "newrelicoracledb.pdb.user_commits_per_second",
	},
	NewrelicoracledbPdbUserCommitsPercentage: metricInfo{
		Name: "newrelicoracledb.pdb.user_commits_percentage",
	},
	NewrelicoracledbPdbUserRollbacksPerSecond: metricInfo{
		Name: "newrelicoracledb.pdb.user_rollbacks_per_second",
	},
	NewrelicoracledbPdbUserRollbacksPercentage: metricInfo{
		Name: "newrelicoracledb.pdb.user_rollbacks_percentage",
	},
	NewrelicoracledbPdbWaitTimeRatio: metricInfo{
		Name: "newrelicoracledb.pdb.wait_time_ratio",
	},
	NewrelicoracledbRacInstanceActiveState: metricInfo{
		Name: "newrelicoracledb.rac.instance.active_state",
	},
	NewrelicoracledbRacInstanceArchiverStarted: metricInfo{
		Name: "newrelicoracledb.rac.instance.archiver_started",
	},
	NewrelicoracledbRacInstanceDatabaseStatus: metricInfo{
		Name: "newrelicoracledb.rac.instance.database_status",
	},
	NewrelicoracledbRacInstanceLoginsAllowed: metricInfo{
		Name: "newrelicoracledb.rac.instance.logins_allowed",
	},
	NewrelicoracledbRacInstanceStatus: metricInfo{
		Name: "newrelicoracledb.rac.instance.status",
	},
	NewrelicoracledbRacInstanceUptimeSeconds: metricInfo{
		Name: "newrelicoracledb.rac.instance.uptime_seconds",
	},
	NewrelicoracledbRacInstanceVersionInfo: metricInfo{
		Name: "newrelicoracledb.rac.instance.version_info",
	},
	NewrelicoracledbRacServiceClbConfig: metricInfo{
		Name: "newrelicoracledb.rac.service.clb_config",
	},
	NewrelicoracledbRacServiceCreationAgeDays: metricInfo{
		Name: "newrelicoracledb.rac.service.creation_age_days",
	},
	NewrelicoracledbRacServiceFailoverConfig: metricInfo{
		Name: "newrelicoracledb.rac.service.failover_config",
	},
	NewrelicoracledbRacServiceFailoverDelaySeconds: metricInfo{
		Name: "newrelicoracledb.rac.service.failover_delay_seconds",
	},
	NewrelicoracledbRacServiceFailoverRetries: metricInfo{
		Name: "newrelicoracledb.rac.service.failover_retries",
	},
	NewrelicoracledbRacServiceInstanceID: metricInfo{
		Name: "newrelicoracledb.rac.service.instance_id",
	},
	NewrelicoracledbRacServiceNetworkConfig: metricInfo{
		Name: "newrelicoracledb.rac.service.network_config",
	},
	NewrelicoracledbRacTotalWaits: metricInfo{
		Name: "newrelicoracledb.rac.total_waits",
	},
	NewrelicoracledbRacWaitTime: metricInfo{
		Name: "newrelicoracledb.rac.wait_time",
	},
	NewrelicoracledbRedoLogParallelWriteWaits: metricInfo{
		Name: "newrelicoracledb.redo_log_parallel_write_waits",
	},
	NewrelicoracledbRedoLogSwitchArchivingNeededWaits: metricInfo{
		Name: "newrelicoracledb.redo_log_switch_archiving_needed_waits",
	},
	NewrelicoracledbRedoLogSwitchCheckpointIncompleteWaits: metricInfo{
		Name: "newrelicoracledb.redo_log_switch_checkpoint_incomplete_waits",
	},
	NewrelicoracledbRedoLogSwitchCompletionWaits: metricInfo{
		Name: "newrelicoracledb.redo_log_switch_completion_waits",
	},
	NewrelicoracledbRollbackSegmentsGets: metricInfo{
		Name: "newrelicoracledb.rollback_segments_gets",
	},
	NewrelicoracledbRollbackSegmentsWaitRatio: metricInfo{
		Name: "newrelicoracledb.rollback_segments_wait_ratio",
	},
	NewrelicoracledbRollbackSegmentsWaits: metricInfo{
		Name: "newrelicoracledb.rollback_segments_waits",
	},
	NewrelicoracledbServiceCount: metricInfo{
		Name: "newrelicoracledb.service.count",
	},
	NewrelicoracledbServiceStatus: metricInfo{
		Name: "newrelicoracledb.service.status",
	},
	NewrelicoracledbSessionsCount: metricInfo{
		Name: "newrelicoracledb.sessions.count",
	},
	NewrelicoracledbSgaBufferBusyWaits: metricInfo{
		Name: "newrelicoracledb.sga_buffer_busy_waits",
	},
	NewrelicoracledbSgaFixedSizeBytes: metricInfo{
		Name: "newrelicoracledb.sga_fixed_size_bytes",
	},
	NewrelicoracledbSgaFreeBufferInspectedWaits: metricInfo{
		Name: "newrelicoracledb.sga_free_buffer_inspected_waits",
	},
	NewrelicoracledbSgaFreeBufferWaits: metricInfo{
		Name: "newrelicoracledb.sga_free_buffer_waits",
	},
	NewrelicoracledbSgaHitRatio: metricInfo{
		Name: "newrelicoracledb.sga_hit_ratio",
	},
	NewrelicoracledbSgaLogAllocationRetriesRatio: metricInfo{
		Name: "newrelicoracledb.sga_log_allocation_retries_ratio",
	},
	NewrelicoracledbSgaLogBufferRedoAllocationRetries: metricInfo{
		Name: "newrelicoracledb.sga_log_buffer_redo_allocation_retries",
	},
	NewrelicoracledbSgaLogBufferRedoEntries: metricInfo{
		Name: "newrelicoracledb.sga_log_buffer_redo_entries",
	},
	NewrelicoracledbSgaLogBufferSpaceWaits: metricInfo{
		Name: "newrelicoracledb.sga_log_buffer_space_waits",
	},
	NewrelicoracledbSgaRedoBuffersBytes: metricInfo{
		Name: "newrelicoracledb.sga_redo_buffers_bytes",
	},
	NewrelicoracledbSgaSharedPoolDictCacheMissRatio: metricInfo{
		Name: "newrelicoracledb.sga_shared_pool_dict_cache_miss_ratio",
	},
	NewrelicoracledbSgaSharedPoolLibraryCacheHitRatio: metricInfo{
		Name: "newrelicoracledb.sga_shared_pool_library_cache_hit_ratio",
	},
	NewrelicoracledbSgaSharedPoolLibraryCacheReloadRatio: metricInfo{
		Name: "newrelicoracledb.sga_shared_pool_library_cache_reload_ratio",
	},
	NewrelicoracledbSortsDisk: metricInfo{
		Name: "newrelicoracledb.sorts_disk",
	},
	NewrelicoracledbSortsMemory: metricInfo{
		Name: "newrelicoracledb.sorts_memory",
	},
	NewrelicoracledbSystemActiveParallelSessions: metricInfo{
		Name: "newrelicoracledb.system.active_parallel_sessions",
	},
	NewrelicoracledbSystemActiveSerialSessions: metricInfo{
		Name: "newrelicoracledb.system.active_serial_sessions",
	},
	NewrelicoracledbSystemAverageActiveSessions: metricInfo{
		Name: "newrelicoracledb.system.average_active_sessions",
	},
	NewrelicoracledbSystemBackgroundCheckpointsPerSecond: metricInfo{
		Name: "newrelicoracledb.system.background_checkpoints_per_second",
	},
	NewrelicoracledbSystemBackgroundCPUUsagePerSecond: metricInfo{
		Name: "newrelicoracledb.system.background_cpu_usage_per_second",
	},
	NewrelicoracledbSystemBackgroundTimePerSecond: metricInfo{
		Name: "newrelicoracledb.system.background_time_per_second",
	},
	NewrelicoracledbSystemBranchNodeSplitsPerSecond: metricInfo{
		Name: "newrelicoracledb.system.branch_node_splits_per_second",
	},
	NewrelicoracledbSystemBranchNodeSplitsPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.branch_node_splits_per_transaction",
	},
	NewrelicoracledbSystemBufferCacheHitRatio: metricInfo{
		Name: "newrelicoracledb.system.buffer_cache_hit_ratio",
	},
	NewrelicoracledbSystemCapturedUserCalls: metricInfo{
		Name: "newrelicoracledb.system.captured_user_calls",
	},
	NewrelicoracledbSystemConsistentReadChangesPerSecond: metricInfo{
		Name: "newrelicoracledb.system.consistent_read_changes_per_second",
	},
	NewrelicoracledbSystemConsistentReadChangesPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.consistent_read_changes_per_transaction",
	},
	NewrelicoracledbSystemConsistentReadGetsPerSecond: metricInfo{
		Name: "newrelicoracledb.system.consistent_read_gets_per_second",
	},
	NewrelicoracledbSystemConsistentReadGetsPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.consistent_read_gets_per_transaction",
	},
	NewrelicoracledbSystemCPUUsagePerSecond: metricInfo{
		Name: "newrelicoracledb.system.cpu_usage_per_second",
	},
	NewrelicoracledbSystemCPUUsagePerTransaction: metricInfo{
		Name: "newrelicoracledb.system.cpu_usage_per_transaction",
	},
	NewrelicoracledbSystemCrBlocksCreatedPerSecond: metricInfo{
		Name: "newrelicoracledb.system.cr_blocks_created_per_second",
	},
	NewrelicoracledbSystemCrBlocksCreatedPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.cr_blocks_created_per_transaction",
	},
	NewrelicoracledbSystemCrUndoRecordsAppliedPerSecond: metricInfo{
		Name: "newrelicoracledb.system.cr_undo_records_applied_per_second",
	},
	NewrelicoracledbSystemCrUndoRecordsAppliedPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.cr_undo_records_applied_per_transaction",
	},
	NewrelicoracledbSystemCurrentLogonsCount: metricInfo{
		Name: "newrelicoracledb.system.current_logons_count",
	},
	NewrelicoracledbSystemCurrentOpenCursorsCount: metricInfo{
		Name: "newrelicoracledb.system.current_open_cursors_count",
	},
	NewrelicoracledbSystemCurrentOsLoad: metricInfo{
		Name: "newrelicoracledb.system.current_os_load",
	},
	NewrelicoracledbSystemCursorCacheHitRatio: metricInfo{
		Name: "newrelicoracledb.system.cursor_cache_hit_ratio",
	},
	NewrelicoracledbSystemDatabaseCPUTimeRatio: metricInfo{
		Name: "newrelicoracledb.system.database_cpu_time_ratio",
	},
	NewrelicoracledbSystemDatabaseTimePerSecond: metricInfo{
		Name: "newrelicoracledb.system.database_time_per_second",
	},
	NewrelicoracledbSystemDatabaseWaitTimeRatio: metricInfo{
		Name: "newrelicoracledb.system.database_wait_time_ratio",
	},
	NewrelicoracledbSystemDbBlockChangesPerSecond: metricInfo{
		Name: "newrelicoracledb.system.db_block_changes_per_second",
	},
	NewrelicoracledbSystemDbBlockChangesPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.db_block_changes_per_transaction",
	},
	NewrelicoracledbSystemDbBlockChangesPerUserCall: metricInfo{
		Name: "newrelicoracledb.system.db_block_changes_per_user_call",
	},
	NewrelicoracledbSystemDbBlockGetsPerSecond: metricInfo{
		Name: "newrelicoracledb.system.db_block_gets_per_second",
	},
	NewrelicoracledbSystemDbBlockGetsPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.db_block_gets_per_transaction",
	},
	NewrelicoracledbSystemDbBlockGetsPerUserCall: metricInfo{
		Name: "newrelicoracledb.system.db_block_gets_per_user_call",
	},
	NewrelicoracledbSystemDbwrCheckpointsPerSecond: metricInfo{
		Name: "newrelicoracledb.system.dbwr_checkpoints_per_second",
	},
	NewrelicoracledbSystemDiskSortPerSecond: metricInfo{
		Name: "newrelicoracledb.system.disk_sort_per_second",
	},
	NewrelicoracledbSystemDiskSortPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.disk_sort_per_transaction",
	},
	NewrelicoracledbSystemEnqueueDeadlocksPerSecond: metricInfo{
		Name: "newrelicoracledb.system.enqueue_deadlocks_per_second",
	},
	NewrelicoracledbSystemEnqueueDeadlocksPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.enqueue_deadlocks_per_transaction",
	},
	NewrelicoracledbSystemEnqueueRequestsPerSecond: metricInfo{
		Name: "newrelicoracledb.system.enqueue_requests_per_second",
	},
	NewrelicoracledbSystemEnqueueRequestsPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.enqueue_requests_per_transaction",
	},
	NewrelicoracledbSystemEnqueueTimeoutsPerSecond: metricInfo{
		Name: "newrelicoracledb.system.enqueue_timeouts_per_second",
	},
	NewrelicoracledbSystemEnqueueTimeoutsPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.enqueue_timeouts_per_transaction",
	},
	NewrelicoracledbSystemEnqueueWaitsPerSecond: metricInfo{
		Name: "newrelicoracledb.system.enqueue_waits_per_second",
	},
	NewrelicoracledbSystemEnqueueWaitsPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.enqueue_waits_per_transaction",
	},
	NewrelicoracledbSystemExecuteWithoutParseRatio: metricInfo{
		Name: "newrelicoracledb.system.execute_without_parse_ratio",
	},
	NewrelicoracledbSystemExecutionsPerSecond: metricInfo{
		Name: "newrelicoracledb.system.executions_per_second",
	},
	NewrelicoracledbSystemExecutionsPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.executions_per_transaction",
	},
	NewrelicoracledbSystemExecutionsPerUserCall: metricInfo{
		Name: "newrelicoracledb.system.executions_per_user_call",
	},
	NewrelicoracledbSystemFullIndexScansPerSecond: metricInfo{
		Name: "newrelicoracledb.system.full_index_scans_per_second",
	},
	NewrelicoracledbSystemFullIndexScansPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.full_index_scans_per_transaction",
	},
	NewrelicoracledbSystemGcCrBlockReceivedPerSecond: metricInfo{
		Name: "newrelicoracledb.system.gc_cr_block_received_per_second",
	},
	NewrelicoracledbSystemGcCrBlockReceivedPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.gc_cr_block_received_per_transaction",
	},
	NewrelicoracledbSystemGcCurrentBlockReceivedPerSecond: metricInfo{
		Name: "newrelicoracledb.system.gc_current_block_received_per_second",
	},
	NewrelicoracledbSystemGcCurrentBlockReceivedPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.gc_current_block_received_per_transaction",
	},
	NewrelicoracledbSystemGlobalCacheAverageCrGetTime: metricInfo{
		Name: "newrelicoracledb.system.global_cache_average_cr_get_time",
	},
	NewrelicoracledbSystemGlobalCacheAverageCurrentGetTime: metricInfo{
		Name: "newrelicoracledb.system.global_cache_average_current_get_time",
	},
	NewrelicoracledbSystemGlobalCacheBlocksCorrupted: metricInfo{
		Name: "newrelicoracledb.system.global_cache_blocks_corrupted",
	},
	NewrelicoracledbSystemGlobalCacheBlocksLost: metricInfo{
		Name: "newrelicoracledb.system.global_cache_blocks_lost",
	},
	NewrelicoracledbSystemHardParseCountPerSecond: metricInfo{
		Name: "newrelicoracledb.system.hard_parse_count_per_second",
	},
	NewrelicoracledbSystemHardParseCountPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.hard_parse_count_per_transaction",
	},
	NewrelicoracledbSystemHostCPUUsagePerSecond: metricInfo{
		Name: "newrelicoracledb.system.host_cpu_usage_per_second",
	},
	NewrelicoracledbSystemHostCPUUtilization: metricInfo{
		Name: "newrelicoracledb.system.host_cpu_utilization",
	},
	NewrelicoracledbSystemIoMegabytesPerSecond: metricInfo{
		Name: "newrelicoracledb.system.io_megabytes_per_second",
	},
	NewrelicoracledbSystemIoRequestsPerSecond: metricInfo{
		Name: "newrelicoracledb.system.io_requests_per_second",
	},
	NewrelicoracledbSystemLeafNodeSplitsPerSecond: metricInfo{
		Name: "newrelicoracledb.system.leaf_node_splits_per_second",
	},
	NewrelicoracledbSystemLeafNodeSplitsPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.leaf_node_splits_per_transaction",
	},
	NewrelicoracledbSystemLibraryCacheHitRatio: metricInfo{
		Name: "newrelicoracledb.system.library_cache_hit_ratio",
	},
	NewrelicoracledbSystemLibraryCacheMissRatio: metricInfo{
		Name: "newrelicoracledb.system.library_cache_miss_ratio",
	},
	NewrelicoracledbSystemLogicalReadsPerSecond: metricInfo{
		Name: "newrelicoracledb.system.logical_reads_per_second",
	},
	NewrelicoracledbSystemLogicalReadsPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.logical_reads_per_transaction",
	},
	NewrelicoracledbSystemLogicalReadsPerUserCall: metricInfo{
		Name: "newrelicoracledb.system.logical_reads_per_user_call",
	},
	NewrelicoracledbSystemLogonsPerSecond: metricInfo{
		Name: "newrelicoracledb.system.logons_per_second",
	},
	NewrelicoracledbSystemLogonsPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.logons_per_transaction",
	},
	NewrelicoracledbSystemLongTableScansPerSecond: metricInfo{
		Name: "newrelicoracledb.system.long_table_scans_per_second",
	},
	NewrelicoracledbSystemLongTableScansPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.long_table_scans_per_transaction",
	},
	NewrelicoracledbSystemMemorySortsRatio: metricInfo{
		Name: "newrelicoracledb.system.memory_sorts_ratio",
	},
	NewrelicoracledbSystemNetworkTrafficVolumePerSecond: metricInfo{
		Name: "newrelicoracledb.system.network_traffic_volume_per_second",
	},
	NewrelicoracledbSystemOpenCursorsPerSecond: metricInfo{
		Name: "newrelicoracledb.system.open_cursors_per_second",
	},
	NewrelicoracledbSystemOpenCursorsPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.open_cursors_per_transaction",
	},
	NewrelicoracledbSystemParseFailureCountPerSecond: metricInfo{
		Name: "newrelicoracledb.system.parse_failure_count_per_second",
	},
	NewrelicoracledbSystemParseFailureCountPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.parse_failure_count_per_transaction",
	},
	NewrelicoracledbSystemPgaCacheHitPercentage: metricInfo{
		Name: "newrelicoracledb.system.pga_cache_hit_percentage",
	},
	NewrelicoracledbSystemPhysicalLobsReadsPerSecond: metricInfo{
		Name: "newrelicoracledb.system.physical_lobs_reads_per_second",
	},
	NewrelicoracledbSystemPhysicalLobsReadsPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.physical_lobs_reads_per_transaction",
	},
	NewrelicoracledbSystemPhysicalLobsWritesPerSecond: metricInfo{
		Name: "newrelicoracledb.system.physical_lobs_writes_per_second",
	},
	NewrelicoracledbSystemPhysicalLobsWritesPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.physical_lobs_writes_per_transaction",
	},
	NewrelicoracledbSystemPhysicalReadBytesPerSecond: metricInfo{
		Name: "newrelicoracledb.system.physical_read_bytes_per_second",
	},
	NewrelicoracledbSystemPhysicalReadIoRequestsPerSecond: metricInfo{
		Name: "newrelicoracledb.system.physical_read_io_requests_per_second",
	},
	NewrelicoracledbSystemPhysicalReadTotalBytesPerSecond: metricInfo{
		Name: "newrelicoracledb.system.physical_read_total_bytes_per_second",
	},
	NewrelicoracledbSystemPhysicalReadTotalIoRequestsPerSecond: metricInfo{
		Name: "newrelicoracledb.system.physical_read_total_io_requests_per_second",
	},
	NewrelicoracledbSystemPhysicalReadsDirectPerSecond: metricInfo{
		Name: "newrelicoracledb.system.physical_reads_direct_per_second",
	},
	NewrelicoracledbSystemPhysicalReadsDirectPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.physical_reads_direct_per_transaction",
	},
	NewrelicoracledbSystemPhysicalReadsPerSecond: metricInfo{
		Name: "newrelicoracledb.system.physical_reads_per_second",
	},
	NewrelicoracledbSystemPhysicalReadsPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.physical_reads_per_transaction",
	},
	NewrelicoracledbSystemPhysicalWriteBytesPerSecond: metricInfo{
		Name: "newrelicoracledb.system.physical_write_bytes_per_second",
	},
	NewrelicoracledbSystemPhysicalWriteIoRequestsPerSecond: metricInfo{
		Name: "newrelicoracledb.system.physical_write_io_requests_per_second",
	},
	NewrelicoracledbSystemPhysicalWriteTotalBytesPerSecond: metricInfo{
		Name: "newrelicoracledb.system.physical_write_total_bytes_per_second",
	},
	NewrelicoracledbSystemPhysicalWriteTotalIoRequestsPerSecond: metricInfo{
		Name: "newrelicoracledb.system.physical_write_total_io_requests_per_second",
	},
	NewrelicoracledbSystemPhysicalWritesDirectPerSecond: metricInfo{
		Name: "newrelicoracledb.system.physical_writes_direct_per_second",
	},
	NewrelicoracledbSystemPhysicalWritesDirectPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.physical_writes_direct_per_transaction",
	},
	NewrelicoracledbSystemPhysicalWritesPerSecond: metricInfo{
		Name: "newrelicoracledb.system.physical_writes_per_second",
	},
	NewrelicoracledbSystemPhysicalWritesPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.physical_writes_per_transaction",
	},
	NewrelicoracledbSystemProcessLimitPercentage: metricInfo{
		Name: "newrelicoracledb.system.process_limit_percentage",
	},
	NewrelicoracledbSystemRecursiveCallsPerSecond: metricInfo{
		Name: "newrelicoracledb.system.recursive_calls_per_second",
	},
	NewrelicoracledbSystemRecursiveCallsPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.recursive_calls_per_transaction",
	},
	NewrelicoracledbSystemRedoAllocationHitRatio: metricInfo{
		Name: "newrelicoracledb.system.redo_allocation_hit_ratio",
	},
	NewrelicoracledbSystemRedoGeneratedBytesPerSecond: metricInfo{
		Name: "newrelicoracledb.system.redo_generated_bytes_per_second",
	},
	NewrelicoracledbSystemRedoGeneratedBytesPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.redo_generated_bytes_per_transaction",
	},
	NewrelicoracledbSystemRedoWritesPerSecond: metricInfo{
		Name: "newrelicoracledb.system.redo_writes_per_second",
	},
	NewrelicoracledbSystemRedoWritesPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.redo_writes_per_transaction",
	},
	NewrelicoracledbSystemResponseTimePerTransaction: metricInfo{
		Name: "newrelicoracledb.system.response_time_per_transaction",
	},
	NewrelicoracledbSystemRowCacheHitRatio: metricInfo{
		Name: "newrelicoracledb.system.row_cache_hit_ratio",
	},
	NewrelicoracledbSystemRowCacheMissRatio: metricInfo{
		Name: "newrelicoracledb.system.row_cache_miss_ratio",
	},
	NewrelicoracledbSystemRowsPerSort: metricInfo{
		Name: "newrelicoracledb.system.rows_per_sort",
	},
	NewrelicoracledbSystemSessionCount: metricInfo{
		Name: "newrelicoracledb.system.session_count",
	},
	NewrelicoracledbSystemSessionLimitPercentage: metricInfo{
		Name: "newrelicoracledb.system.session_limit_percentage",
	},
	NewrelicoracledbSystemSharedPoolFreePercentage: metricInfo{
		Name: "newrelicoracledb.system.shared_pool_free_percentage",
	},
	NewrelicoracledbSystemSoftParseRatio: metricInfo{
		Name: "newrelicoracledb.system.soft_parse_ratio",
	},
	NewrelicoracledbSystemSQLServiceResponseTime: metricInfo{
		Name: "newrelicoracledb.system.sql_service_response_time",
	},
	NewrelicoracledbSystemStreamsPoolUsagePercentage: metricInfo{
		Name: "newrelicoracledb.system.streams_pool_usage_percentage",
	},
	NewrelicoracledbSystemTempSpaceUsed: metricInfo{
		Name: "newrelicoracledb.system.temp_space_used",
	},
	NewrelicoracledbSystemTotalIndexScansPerSecond: metricInfo{
		Name: "newrelicoracledb.system.total_index_scans_per_second",
	},
	NewrelicoracledbSystemTotalIndexScansPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.total_index_scans_per_transaction",
	},
	NewrelicoracledbSystemTotalParseCountPerSecond: metricInfo{
		Name: "newrelicoracledb.system.total_parse_count_per_second",
	},
	NewrelicoracledbSystemTotalParseCountPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.total_parse_count_per_transaction",
	},
	NewrelicoracledbSystemTotalSortsPerUserCall: metricInfo{
		Name: "newrelicoracledb.system.total_sorts_per_user_call",
	},
	NewrelicoracledbSystemTotalTableScansPerSecond: metricInfo{
		Name: "newrelicoracledb.system.total_table_scans_per_second",
	},
	NewrelicoracledbSystemTotalTableScansPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.total_table_scans_per_transaction",
	},
	NewrelicoracledbSystemTotalTableScansPerUserCall: metricInfo{
		Name: "newrelicoracledb.system.total_table_scans_per_user_call",
	},
	NewrelicoracledbSystemTransactionsPerLogon: metricInfo{
		Name: "newrelicoracledb.system.transactions_per_logon",
	},
	NewrelicoracledbSystemTransactionsPerSecond: metricInfo{
		Name: "newrelicoracledb.system.transactions_per_second",
	},
	NewrelicoracledbSystemUserCallsPerSecond: metricInfo{
		Name: "newrelicoracledb.system.user_calls_per_second",
	},
	NewrelicoracledbSystemUserCallsPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.user_calls_per_transaction",
	},
	NewrelicoracledbSystemUserCallsRatio: metricInfo{
		Name: "newrelicoracledb.system.user_calls_ratio",
	},
	NewrelicoracledbSystemUserCommitsPerSecond: metricInfo{
		Name: "newrelicoracledb.system.user_commits_per_second",
	},
	NewrelicoracledbSystemUserCommitsPercentage: metricInfo{
		Name: "newrelicoracledb.system.user_commits_percentage",
	},
	NewrelicoracledbSystemUserLimitPercentage: metricInfo{
		Name: "newrelicoracledb.system.user_limit_percentage",
	},
	NewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerSecond: metricInfo{
		Name: "newrelicoracledb.system.user_rollback_undo_records_applied_per_second",
	},
	NewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerTransaction: metricInfo{
		Name: "newrelicoracledb.system.user_rollback_undo_records_applied_per_transaction",
	},
	NewrelicoracledbSystemUserRollbacksPerSecond: metricInfo{
		Name: "newrelicoracledb.system.user_rollbacks_per_second",
	},
	NewrelicoracledbSystemUserRollbacksPercentage: metricInfo{
		Name: "newrelicoracledb.system.user_rollbacks_percentage",
	},
	NewrelicoracledbTablespaceDbID: metricInfo{
		Name: "newrelicoracledb.tablespace.db_id",
	},
	NewrelicoracledbTablespaceGlobalName: metricInfo{
		Name: "newrelicoracledb.tablespace.global_name",
	},
	NewrelicoracledbTablespaceIsOffline: metricInfo{
		Name: "newrelicoracledb.tablespace.is_offline",
	},
	NewrelicoracledbTablespaceOfflineCdbDatafiles: metricInfo{
		Name: "newrelicoracledb.tablespace.offline_cdb_datafiles",
	},
	NewrelicoracledbTablespaceOfflinePdbDatafiles: metricInfo{
		Name: "newrelicoracledb.tablespace.offline_pdb_datafiles",
	},
	NewrelicoracledbTablespacePdbNonWriteMode: metricInfo{
		Name: "newrelicoracledb.tablespace.pdb_non_write_mode",
	},
	NewrelicoracledbTablespaceSpaceConsumedBytes: metricInfo{
		Name: "newrelicoracledb.tablespace.space_consumed_bytes",
	},
	NewrelicoracledbTablespaceSpaceReservedBytes: metricInfo{
		Name: "newrelicoracledb.tablespace.space_reserved_bytes",
	},
	NewrelicoracledbTablespaceSpaceUsedPercentage: metricInfo{
		Name: "newrelicoracledb.tablespace.space_used_percentage",
	},
	NewrelicoracledbTablespaceTotalBytes: metricInfo{
		Name: "newrelicoracledb.tablespace.total_bytes",
	},
	NewrelicoracledbTablespaceUsedBytes: metricInfo{
		Name: "newrelicoracledb.tablespace.used_bytes",
	},
	NewrelicoracledbTablespaceUsedPercent: metricInfo{
		Name: "newrelicoracledb.tablespace.used_percent",
	},
}

type metricsInfo struct {
	NewrelicoracledbAsmDiskgroupFreeMb                                 metricInfo
	NewrelicoracledbAsmDiskgroupOfflineDisks                           metricInfo
	NewrelicoracledbAsmDiskgroupTotalMb                                metricInfo
	NewrelicoracledbConnectionActiveSessions                           metricInfo
	NewrelicoracledbConnectionBlockingSessions                         metricInfo
	NewrelicoracledbConnectionBytesReceived                            metricInfo
	NewrelicoracledbConnectionBytesSent                                metricInfo
	NewrelicoracledbConnectionCircuits                                 metricInfo
	NewrelicoracledbConnectionDispatchers                              metricInfo
	NewrelicoracledbConnectionExecuteCount                             metricInfo
	NewrelicoracledbConnectionInactiveSessions                         metricInfo
	NewrelicoracledbConnectionLogonsCumulative                         metricInfo
	NewrelicoracledbConnectionLogonsCurrent                            metricInfo
	NewrelicoracledbConnectionParseCountHard                           metricInfo
	NewrelicoracledbConnectionParseCountTotal                          metricInfo
	NewrelicoracledbConnectionResourceCurrentUtilization               metricInfo
	NewrelicoracledbConnectionResourceLimit                            metricInfo
	NewrelicoracledbConnectionResourceMaxUtilization                   metricInfo
	NewrelicoracledbConnectionSessionCPUUsage                          metricInfo
	NewrelicoracledbConnectionSessionIdleTime                          metricInfo
	NewrelicoracledbConnectionSessionLogicalReads                      metricInfo
	NewrelicoracledbConnectionSessionPgaMemory                         metricInfo
	NewrelicoracledbConnectionSessionsByStatus                         metricInfo
	NewrelicoracledbConnectionSessionsByType                           metricInfo
	NewrelicoracledbConnectionSharedServers                            metricInfo
	NewrelicoracledbConnectionSqlnetRoundtrips                         metricInfo
	NewrelicoracledbConnectionTotalSessions                            metricInfo
	NewrelicoracledbConnectionUserCommits                              metricInfo
	NewrelicoracledbConnectionUserRollbacks                            metricInfo
	NewrelicoracledbConnectionWaitEventAvgWaitTime                     metricInfo
	NewrelicoracledbConnectionWaitEventTimeWaited                      metricInfo
	NewrelicoracledbConnectionWaitEventTotalWaits                      metricInfo
	NewrelicoracledbConnectionWaitEvents                               metricInfo
	NewrelicoracledbContainerRestricted                                metricInfo
	NewrelicoracledbContainerStatus                                    metricInfo
	NewrelicoracledbDatafileAutoextensible                             metricInfo
	NewrelicoracledbDatafileSizeBytes                                  metricInfo
	NewrelicoracledbDatafileUsedBytes                                  metricInfo
	NewrelicoracledbDbID                                               metricInfo
	NewrelicoracledbDiskBlocksRead                                     metricInfo
	NewrelicoracledbDiskBlocksWritten                                  metricInfo
	NewrelicoracledbDiskReadTimeMilliseconds                           metricInfo
	NewrelicoracledbDiskReads                                          metricInfo
	NewrelicoracledbDiskWriteTimeMilliseconds                          metricInfo
	NewrelicoracledbDiskWrites                                         metricInfo
	NewrelicoracledbGlobalName                                         metricInfo
	NewrelicoracledbLockedAccounts                                     metricInfo
	NewrelicoracledbLongRunningQueries                                 metricInfo
	NewrelicoracledbMemoryPgaAllocatedBytes                            metricInfo
	NewrelicoracledbMemoryPgaFreeableBytes                             metricInfo
	NewrelicoracledbMemoryPgaInUseBytes                                metricInfo
	NewrelicoracledbMemoryPgaMaxSizeBytes                              metricInfo
	NewrelicoracledbMemorySgaSharedPoolLibraryCacheSharableBytes       metricInfo
	NewrelicoracledbMemorySgaSharedPoolLibraryCacheUserBytes           metricInfo
	NewrelicoracledbMemorySgaUgaTotalBytes                             metricInfo
	NewrelicoracledbPdbActiveParallelSessions                          metricInfo
	NewrelicoracledbPdbActiveSerialSessions                            metricInfo
	NewrelicoracledbPdbAverageActiveSessions                           metricInfo
	NewrelicoracledbPdbBackgroundCPUUsagePerSecond                     metricInfo
	NewrelicoracledbPdbBackgroundTimePerSecond                         metricInfo
	NewrelicoracledbPdbBlockChangesPerSecond                           metricInfo
	NewrelicoracledbPdbBlockChangesPerTransaction                      metricInfo
	NewrelicoracledbPdbCPUTimeRatio                                    metricInfo
	NewrelicoracledbPdbCPUUsagePerSecond                               metricInfo
	NewrelicoracledbPdbCPUUsagePerTransaction                          metricInfo
	NewrelicoracledbPdbCurrentLogons                                   metricInfo
	NewrelicoracledbPdbCurrentOpenCursors                              metricInfo
	NewrelicoracledbPdbDbPhysicalReadBytesPerSecond                    metricInfo
	NewrelicoracledbPdbDbPhysicalReadsPerSecond                        metricInfo
	NewrelicoracledbPdbDbPhysicalWriteBytesPerSecond                   metricInfo
	NewrelicoracledbPdbDbPhysicalWritesPerSecond                       metricInfo
	NewrelicoracledbPdbExecuteWithoutParseRatio                        metricInfo
	NewrelicoracledbPdbExecutionsPerSecond                             metricInfo
	NewrelicoracledbPdbExecutionsPerTransaction                        metricInfo
	NewrelicoracledbPdbHardParseCountPerSecond                         metricInfo
	NewrelicoracledbPdbHardParseCountPerTransaction                    metricInfo
	NewrelicoracledbPdbLogicalReadsPerSecond                           metricInfo
	NewrelicoracledbPdbLogicalReadsPerTransaction                      metricInfo
	NewrelicoracledbPdbLogonsPerSecond                                 metricInfo
	NewrelicoracledbPdbLogonsPerTransaction                            metricInfo
	NewrelicoracledbPdbNetworkTrafficBytePerSecond                     metricInfo
	NewrelicoracledbPdbOpenCursorsPerSecond                            metricInfo
	NewrelicoracledbPdbOpenCursorsPerTransaction                       metricInfo
	NewrelicoracledbPdbOpenMode                                        metricInfo
	NewrelicoracledbPdbParseFailureCountPerSecond                      metricInfo
	NewrelicoracledbPdbPhysicalReadBytesPerSecond                      metricInfo
	NewrelicoracledbPdbPhysicalReadsPerTransaction                     metricInfo
	NewrelicoracledbPdbPhysicalWriteBytesPerSecond                     metricInfo
	NewrelicoracledbPdbPhysicalWritesPerTransaction                    metricInfo
	NewrelicoracledbPdbRedoGeneratedBytesPerSecond                     metricInfo
	NewrelicoracledbPdbRedoGeneratedBytesPerTransaction                metricInfo
	NewrelicoracledbPdbResponseTimePerTransaction                      metricInfo
	NewrelicoracledbPdbSessionCount                                    metricInfo
	NewrelicoracledbPdbSoftParseRatio                                  metricInfo
	NewrelicoracledbPdbSQLServiceResponseTime                          metricInfo
	NewrelicoracledbPdbStatus                                          metricInfo
	NewrelicoracledbPdbTotalParseCountPerSecond                        metricInfo
	NewrelicoracledbPdbTotalParseCountPerTransaction                   metricInfo
	NewrelicoracledbPdbTotalSizeBytes                                  metricInfo
	NewrelicoracledbPdbTransactionsPerSecond                           metricInfo
	NewrelicoracledbPdbUserCallsPerSecond                              metricInfo
	NewrelicoracledbPdbUserCallsPerTransaction                         metricInfo
	NewrelicoracledbPdbUserCommitsPerSecond                            metricInfo
	NewrelicoracledbPdbUserCommitsPercentage                           metricInfo
	NewrelicoracledbPdbUserRollbacksPerSecond                          metricInfo
	NewrelicoracledbPdbUserRollbacksPercentage                         metricInfo
	NewrelicoracledbPdbWaitTimeRatio                                   metricInfo
	NewrelicoracledbRacInstanceActiveState                             metricInfo
	NewrelicoracledbRacInstanceArchiverStarted                         metricInfo
	NewrelicoracledbRacInstanceDatabaseStatus                          metricInfo
	NewrelicoracledbRacInstanceLoginsAllowed                           metricInfo
	NewrelicoracledbRacInstanceStatus                                  metricInfo
	NewrelicoracledbRacInstanceUptimeSeconds                           metricInfo
	NewrelicoracledbRacInstanceVersionInfo                             metricInfo
	NewrelicoracledbRacServiceClbConfig                                metricInfo
	NewrelicoracledbRacServiceCreationAgeDays                          metricInfo
	NewrelicoracledbRacServiceFailoverConfig                           metricInfo
	NewrelicoracledbRacServiceFailoverDelaySeconds                     metricInfo
	NewrelicoracledbRacServiceFailoverRetries                          metricInfo
	NewrelicoracledbRacServiceInstanceID                               metricInfo
	NewrelicoracledbRacServiceNetworkConfig                            metricInfo
	NewrelicoracledbRacTotalWaits                                      metricInfo
	NewrelicoracledbRacWaitTime                                        metricInfo
	NewrelicoracledbRedoLogParallelWriteWaits                          metricInfo
	NewrelicoracledbRedoLogSwitchArchivingNeededWaits                  metricInfo
	NewrelicoracledbRedoLogSwitchCheckpointIncompleteWaits             metricInfo
	NewrelicoracledbRedoLogSwitchCompletionWaits                       metricInfo
	NewrelicoracledbRollbackSegmentsGets                               metricInfo
	NewrelicoracledbRollbackSegmentsWaitRatio                          metricInfo
	NewrelicoracledbRollbackSegmentsWaits                              metricInfo
	NewrelicoracledbServiceCount                                       metricInfo
	NewrelicoracledbServiceStatus                                      metricInfo
	NewrelicoracledbSessionsCount                                      metricInfo
	NewrelicoracledbSgaBufferBusyWaits                                 metricInfo
	NewrelicoracledbSgaFixedSizeBytes                                  metricInfo
	NewrelicoracledbSgaFreeBufferInspectedWaits                        metricInfo
	NewrelicoracledbSgaFreeBufferWaits                                 metricInfo
	NewrelicoracledbSgaHitRatio                                        metricInfo
	NewrelicoracledbSgaLogAllocationRetriesRatio                       metricInfo
	NewrelicoracledbSgaLogBufferRedoAllocationRetries                  metricInfo
	NewrelicoracledbSgaLogBufferRedoEntries                            metricInfo
	NewrelicoracledbSgaLogBufferSpaceWaits                             metricInfo
	NewrelicoracledbSgaRedoBuffersBytes                                metricInfo
	NewrelicoracledbSgaSharedPoolDictCacheMissRatio                    metricInfo
	NewrelicoracledbSgaSharedPoolLibraryCacheHitRatio                  metricInfo
	NewrelicoracledbSgaSharedPoolLibraryCacheReloadRatio               metricInfo
	NewrelicoracledbSortsDisk                                          metricInfo
	NewrelicoracledbSortsMemory                                        metricInfo
	NewrelicoracledbSystemActiveParallelSessions                       metricInfo
	NewrelicoracledbSystemActiveSerialSessions                         metricInfo
	NewrelicoracledbSystemAverageActiveSessions                        metricInfo
	NewrelicoracledbSystemBackgroundCheckpointsPerSecond               metricInfo
	NewrelicoracledbSystemBackgroundCPUUsagePerSecond                  metricInfo
	NewrelicoracledbSystemBackgroundTimePerSecond                      metricInfo
	NewrelicoracledbSystemBranchNodeSplitsPerSecond                    metricInfo
	NewrelicoracledbSystemBranchNodeSplitsPerTransaction               metricInfo
	NewrelicoracledbSystemBufferCacheHitRatio                          metricInfo
	NewrelicoracledbSystemCapturedUserCalls                            metricInfo
	NewrelicoracledbSystemConsistentReadChangesPerSecond               metricInfo
	NewrelicoracledbSystemConsistentReadChangesPerTransaction          metricInfo
	NewrelicoracledbSystemConsistentReadGetsPerSecond                  metricInfo
	NewrelicoracledbSystemConsistentReadGetsPerTransaction             metricInfo
	NewrelicoracledbSystemCPUUsagePerSecond                            metricInfo
	NewrelicoracledbSystemCPUUsagePerTransaction                       metricInfo
	NewrelicoracledbSystemCrBlocksCreatedPerSecond                     metricInfo
	NewrelicoracledbSystemCrBlocksCreatedPerTransaction                metricInfo
	NewrelicoracledbSystemCrUndoRecordsAppliedPerSecond                metricInfo
	NewrelicoracledbSystemCrUndoRecordsAppliedPerTransaction           metricInfo
	NewrelicoracledbSystemCurrentLogonsCount                           metricInfo
	NewrelicoracledbSystemCurrentOpenCursorsCount                      metricInfo
	NewrelicoracledbSystemCurrentOsLoad                                metricInfo
	NewrelicoracledbSystemCursorCacheHitRatio                          metricInfo
	NewrelicoracledbSystemDatabaseCPUTimeRatio                         metricInfo
	NewrelicoracledbSystemDatabaseTimePerSecond                        metricInfo
	NewrelicoracledbSystemDatabaseWaitTimeRatio                        metricInfo
	NewrelicoracledbSystemDbBlockChangesPerSecond                      metricInfo
	NewrelicoracledbSystemDbBlockChangesPerTransaction                 metricInfo
	NewrelicoracledbSystemDbBlockChangesPerUserCall                    metricInfo
	NewrelicoracledbSystemDbBlockGetsPerSecond                         metricInfo
	NewrelicoracledbSystemDbBlockGetsPerTransaction                    metricInfo
	NewrelicoracledbSystemDbBlockGetsPerUserCall                       metricInfo
	NewrelicoracledbSystemDbwrCheckpointsPerSecond                     metricInfo
	NewrelicoracledbSystemDiskSortPerSecond                            metricInfo
	NewrelicoracledbSystemDiskSortPerTransaction                       metricInfo
	NewrelicoracledbSystemEnqueueDeadlocksPerSecond                    metricInfo
	NewrelicoracledbSystemEnqueueDeadlocksPerTransaction               metricInfo
	NewrelicoracledbSystemEnqueueRequestsPerSecond                     metricInfo
	NewrelicoracledbSystemEnqueueRequestsPerTransaction                metricInfo
	NewrelicoracledbSystemEnqueueTimeoutsPerSecond                     metricInfo
	NewrelicoracledbSystemEnqueueTimeoutsPerTransaction                metricInfo
	NewrelicoracledbSystemEnqueueWaitsPerSecond                        metricInfo
	NewrelicoracledbSystemEnqueueWaitsPerTransaction                   metricInfo
	NewrelicoracledbSystemExecuteWithoutParseRatio                     metricInfo
	NewrelicoracledbSystemExecutionsPerSecond                          metricInfo
	NewrelicoracledbSystemExecutionsPerTransaction                     metricInfo
	NewrelicoracledbSystemExecutionsPerUserCall                        metricInfo
	NewrelicoracledbSystemFullIndexScansPerSecond                      metricInfo
	NewrelicoracledbSystemFullIndexScansPerTransaction                 metricInfo
	NewrelicoracledbSystemGcCrBlockReceivedPerSecond                   metricInfo
	NewrelicoracledbSystemGcCrBlockReceivedPerTransaction              metricInfo
	NewrelicoracledbSystemGcCurrentBlockReceivedPerSecond              metricInfo
	NewrelicoracledbSystemGcCurrentBlockReceivedPerTransaction         metricInfo
	NewrelicoracledbSystemGlobalCacheAverageCrGetTime                  metricInfo
	NewrelicoracledbSystemGlobalCacheAverageCurrentGetTime             metricInfo
	NewrelicoracledbSystemGlobalCacheBlocksCorrupted                   metricInfo
	NewrelicoracledbSystemGlobalCacheBlocksLost                        metricInfo
	NewrelicoracledbSystemHardParseCountPerSecond                      metricInfo
	NewrelicoracledbSystemHardParseCountPerTransaction                 metricInfo
	NewrelicoracledbSystemHostCPUUsagePerSecond                        metricInfo
	NewrelicoracledbSystemHostCPUUtilization                           metricInfo
	NewrelicoracledbSystemIoMegabytesPerSecond                         metricInfo
	NewrelicoracledbSystemIoRequestsPerSecond                          metricInfo
	NewrelicoracledbSystemLeafNodeSplitsPerSecond                      metricInfo
	NewrelicoracledbSystemLeafNodeSplitsPerTransaction                 metricInfo
	NewrelicoracledbSystemLibraryCacheHitRatio                         metricInfo
	NewrelicoracledbSystemLibraryCacheMissRatio                        metricInfo
	NewrelicoracledbSystemLogicalReadsPerSecond                        metricInfo
	NewrelicoracledbSystemLogicalReadsPerTransaction                   metricInfo
	NewrelicoracledbSystemLogicalReadsPerUserCall                      metricInfo
	NewrelicoracledbSystemLogonsPerSecond                              metricInfo
	NewrelicoracledbSystemLogonsPerTransaction                         metricInfo
	NewrelicoracledbSystemLongTableScansPerSecond                      metricInfo
	NewrelicoracledbSystemLongTableScansPerTransaction                 metricInfo
	NewrelicoracledbSystemMemorySortsRatio                             metricInfo
	NewrelicoracledbSystemNetworkTrafficVolumePerSecond                metricInfo
	NewrelicoracledbSystemOpenCursorsPerSecond                         metricInfo
	NewrelicoracledbSystemOpenCursorsPerTransaction                    metricInfo
	NewrelicoracledbSystemParseFailureCountPerSecond                   metricInfo
	NewrelicoracledbSystemParseFailureCountPerTransaction              metricInfo
	NewrelicoracledbSystemPgaCacheHitPercentage                        metricInfo
	NewrelicoracledbSystemPhysicalLobsReadsPerSecond                   metricInfo
	NewrelicoracledbSystemPhysicalLobsReadsPerTransaction              metricInfo
	NewrelicoracledbSystemPhysicalLobsWritesPerSecond                  metricInfo
	NewrelicoracledbSystemPhysicalLobsWritesPerTransaction             metricInfo
	NewrelicoracledbSystemPhysicalReadBytesPerSecond                   metricInfo
	NewrelicoracledbSystemPhysicalReadIoRequestsPerSecond              metricInfo
	NewrelicoracledbSystemPhysicalReadTotalBytesPerSecond              metricInfo
	NewrelicoracledbSystemPhysicalReadTotalIoRequestsPerSecond         metricInfo
	NewrelicoracledbSystemPhysicalReadsDirectPerSecond                 metricInfo
	NewrelicoracledbSystemPhysicalReadsDirectPerTransaction            metricInfo
	NewrelicoracledbSystemPhysicalReadsPerSecond                       metricInfo
	NewrelicoracledbSystemPhysicalReadsPerTransaction                  metricInfo
	NewrelicoracledbSystemPhysicalWriteBytesPerSecond                  metricInfo
	NewrelicoracledbSystemPhysicalWriteIoRequestsPerSecond             metricInfo
	NewrelicoracledbSystemPhysicalWriteTotalBytesPerSecond             metricInfo
	NewrelicoracledbSystemPhysicalWriteTotalIoRequestsPerSecond        metricInfo
	NewrelicoracledbSystemPhysicalWritesDirectPerSecond                metricInfo
	NewrelicoracledbSystemPhysicalWritesDirectPerTransaction           metricInfo
	NewrelicoracledbSystemPhysicalWritesPerSecond                      metricInfo
	NewrelicoracledbSystemPhysicalWritesPerTransaction                 metricInfo
	NewrelicoracledbSystemProcessLimitPercentage                       metricInfo
	NewrelicoracledbSystemRecursiveCallsPerSecond                      metricInfo
	NewrelicoracledbSystemRecursiveCallsPerTransaction                 metricInfo
	NewrelicoracledbSystemRedoAllocationHitRatio                       metricInfo
	NewrelicoracledbSystemRedoGeneratedBytesPerSecond                  metricInfo
	NewrelicoracledbSystemRedoGeneratedBytesPerTransaction             metricInfo
	NewrelicoracledbSystemRedoWritesPerSecond                          metricInfo
	NewrelicoracledbSystemRedoWritesPerTransaction                     metricInfo
	NewrelicoracledbSystemResponseTimePerTransaction                   metricInfo
	NewrelicoracledbSystemRowCacheHitRatio                             metricInfo
	NewrelicoracledbSystemRowCacheMissRatio                            metricInfo
	NewrelicoracledbSystemRowsPerSort                                  metricInfo
	NewrelicoracledbSystemSessionCount                                 metricInfo
	NewrelicoracledbSystemSessionLimitPercentage                       metricInfo
	NewrelicoracledbSystemSharedPoolFreePercentage                     metricInfo
	NewrelicoracledbSystemSoftParseRatio                               metricInfo
	NewrelicoracledbSystemSQLServiceResponseTime                       metricInfo
	NewrelicoracledbSystemStreamsPoolUsagePercentage                   metricInfo
	NewrelicoracledbSystemTempSpaceUsed                                metricInfo
	NewrelicoracledbSystemTotalIndexScansPerSecond                     metricInfo
	NewrelicoracledbSystemTotalIndexScansPerTransaction                metricInfo
	NewrelicoracledbSystemTotalParseCountPerSecond                     metricInfo
	NewrelicoracledbSystemTotalParseCountPerTransaction                metricInfo
	NewrelicoracledbSystemTotalSortsPerUserCall                        metricInfo
	NewrelicoracledbSystemTotalTableScansPerSecond                     metricInfo
	NewrelicoracledbSystemTotalTableScansPerTransaction                metricInfo
	NewrelicoracledbSystemTotalTableScansPerUserCall                   metricInfo
	NewrelicoracledbSystemTransactionsPerLogon                         metricInfo
	NewrelicoracledbSystemTransactionsPerSecond                        metricInfo
	NewrelicoracledbSystemUserCallsPerSecond                           metricInfo
	NewrelicoracledbSystemUserCallsPerTransaction                      metricInfo
	NewrelicoracledbSystemUserCallsRatio                               metricInfo
	NewrelicoracledbSystemUserCommitsPerSecond                         metricInfo
	NewrelicoracledbSystemUserCommitsPercentage                        metricInfo
	NewrelicoracledbSystemUserLimitPercentage                          metricInfo
	NewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerSecond      metricInfo
	NewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerTransaction metricInfo
	NewrelicoracledbSystemUserRollbacksPerSecond                       metricInfo
	NewrelicoracledbSystemUserRollbacksPercentage                      metricInfo
	NewrelicoracledbTablespaceDbID                                     metricInfo
	NewrelicoracledbTablespaceGlobalName                               metricInfo
	NewrelicoracledbTablespaceIsOffline                                metricInfo
	NewrelicoracledbTablespaceOfflineCdbDatafiles                      metricInfo
	NewrelicoracledbTablespaceOfflinePdbDatafiles                      metricInfo
	NewrelicoracledbTablespacePdbNonWriteMode                          metricInfo
	NewrelicoracledbTablespaceSpaceConsumedBytes                       metricInfo
	NewrelicoracledbTablespaceSpaceReservedBytes                       metricInfo
	NewrelicoracledbTablespaceSpaceUsedPercentage                      metricInfo
	NewrelicoracledbTablespaceTotalBytes                               metricInfo
	NewrelicoracledbTablespaceUsedBytes                                metricInfo
	NewrelicoracledbTablespaceUsedPercent                              metricInfo
}

type metricInfo struct {
	Name string
}

type metricNewrelicoracledbAsmDiskgroupFreeMb struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.asm.diskgroup.free_mb metric with initial data.
func (m *metricNewrelicoracledbAsmDiskgroupFreeMb) init() {
	m.data.SetName("newrelicoracledb.asm.diskgroup.free_mb")
	m.data.SetDescription("Available free space in the ASM disk group in MB")
	m.data.SetUnit("MB")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbAsmDiskgroupFreeMb) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, diskgroupNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("diskgroup.name", diskgroupNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbAsmDiskgroupFreeMb) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbAsmDiskgroupFreeMb) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbAsmDiskgroupFreeMb(cfg MetricConfig) metricNewrelicoracledbAsmDiskgroupFreeMb {
	m := metricNewrelicoracledbAsmDiskgroupFreeMb{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbAsmDiskgroupOfflineDisks struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.asm.diskgroup.offline_disks metric with initial data.
func (m *metricNewrelicoracledbAsmDiskgroupOfflineDisks) init() {
	m.data.SetName("newrelicoracledb.asm.diskgroup.offline_disks")
	m.data.SetDescription("Number of offline disks in the ASM disk group")
	m.data.SetUnit("{disks}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbAsmDiskgroupOfflineDisks) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, diskgroupNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("diskgroup.name", diskgroupNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbAsmDiskgroupOfflineDisks) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbAsmDiskgroupOfflineDisks) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbAsmDiskgroupOfflineDisks(cfg MetricConfig) metricNewrelicoracledbAsmDiskgroupOfflineDisks {
	m := metricNewrelicoracledbAsmDiskgroupOfflineDisks{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbAsmDiskgroupTotalMb struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.asm.diskgroup.total_mb metric with initial data.
func (m *metricNewrelicoracledbAsmDiskgroupTotalMb) init() {
	m.data.SetName("newrelicoracledb.asm.diskgroup.total_mb")
	m.data.SetDescription("Total capacity of the ASM disk group in MB")
	m.data.SetUnit("MB")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbAsmDiskgroupTotalMb) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, diskgroupNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("diskgroup.name", diskgroupNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbAsmDiskgroupTotalMb) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbAsmDiskgroupTotalMb) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbAsmDiskgroupTotalMb(cfg MetricConfig) metricNewrelicoracledbAsmDiskgroupTotalMb {
	m := metricNewrelicoracledbAsmDiskgroupTotalMb{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbConnectionActiveSessions struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.connection.active_sessions metric with initial data.
func (m *metricNewrelicoracledbConnectionActiveSessions) init() {
	m.data.SetName("newrelicoracledb.connection.active_sessions")
	m.data.SetDescription("Number of active Oracle database sessions")
	m.data.SetUnit("{sessions}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbConnectionActiveSessions) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbConnectionActiveSessions) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbConnectionActiveSessions) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbConnectionActiveSessions(cfg MetricConfig) metricNewrelicoracledbConnectionActiveSessions {
	m := metricNewrelicoracledbConnectionActiveSessions{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbConnectionBlockingSessions struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.connection.blocking_sessions metric with initial data.
func (m *metricNewrelicoracledbConnectionBlockingSessions) init() {
	m.data.SetName("newrelicoracledb.connection.blocking_sessions")
	m.data.SetDescription("Sessions blocked by other sessions")
	m.data.SetUnit("s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbConnectionBlockingSessions) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, sessionIDAttributeValue string, blockingSessionIDAttributeValue string, usernameAttributeValue string, waitEventAttributeValue string, programAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("session.id", sessionIDAttributeValue)
	dp.Attributes().PutStr("blocking.session.id", blockingSessionIDAttributeValue)
	dp.Attributes().PutStr("username", usernameAttributeValue)
	dp.Attributes().PutStr("wait.event", waitEventAttributeValue)
	dp.Attributes().PutStr("program", programAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbConnectionBlockingSessions) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbConnectionBlockingSessions) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbConnectionBlockingSessions(cfg MetricConfig) metricNewrelicoracledbConnectionBlockingSessions {
	m := metricNewrelicoracledbConnectionBlockingSessions{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbConnectionBytesReceived struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.connection.bytes_received metric with initial data.
func (m *metricNewrelicoracledbConnectionBytesReceived) init() {
	m.data.SetName("newrelicoracledb.connection.bytes_received")
	m.data.SetDescription("Bytes received via SQL*Net from client")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbConnectionBytesReceived) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbConnectionBytesReceived) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbConnectionBytesReceived) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbConnectionBytesReceived(cfg MetricConfig) metricNewrelicoracledbConnectionBytesReceived {
	m := metricNewrelicoracledbConnectionBytesReceived{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbConnectionBytesSent struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.connection.bytes_sent metric with initial data.
func (m *metricNewrelicoracledbConnectionBytesSent) init() {
	m.data.SetName("newrelicoracledb.connection.bytes_sent")
	m.data.SetDescription("Bytes sent via SQL*Net to client")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbConnectionBytesSent) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbConnectionBytesSent) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbConnectionBytesSent) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbConnectionBytesSent(cfg MetricConfig) metricNewrelicoracledbConnectionBytesSent {
	m := metricNewrelicoracledbConnectionBytesSent{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbConnectionCircuits struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.connection.circuits metric with initial data.
func (m *metricNewrelicoracledbConnectionCircuits) init() {
	m.data.SetName("newrelicoracledb.connection.circuits")
	m.data.SetDescription("Number of active circuits")
	m.data.SetUnit("{circuits}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbConnectionCircuits) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbConnectionCircuits) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbConnectionCircuits) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbConnectionCircuits(cfg MetricConfig) metricNewrelicoracledbConnectionCircuits {
	m := metricNewrelicoracledbConnectionCircuits{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbConnectionDispatchers struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.connection.dispatchers metric with initial data.
func (m *metricNewrelicoracledbConnectionDispatchers) init() {
	m.data.SetName("newrelicoracledb.connection.dispatchers")
	m.data.SetDescription("Number of dispatchers")
	m.data.SetUnit("{dispatchers}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbConnectionDispatchers) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbConnectionDispatchers) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbConnectionDispatchers) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbConnectionDispatchers(cfg MetricConfig) metricNewrelicoracledbConnectionDispatchers {
	m := metricNewrelicoracledbConnectionDispatchers{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbConnectionExecuteCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.connection.execute_count metric with initial data.
func (m *metricNewrelicoracledbConnectionExecuteCount) init() {
	m.data.SetName("newrelicoracledb.connection.execute_count")
	m.data.SetDescription("Number of SQL executions")
	m.data.SetUnit("{executions}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbConnectionExecuteCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbConnectionExecuteCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbConnectionExecuteCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbConnectionExecuteCount(cfg MetricConfig) metricNewrelicoracledbConnectionExecuteCount {
	m := metricNewrelicoracledbConnectionExecuteCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbConnectionInactiveSessions struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.connection.inactive_sessions metric with initial data.
func (m *metricNewrelicoracledbConnectionInactiveSessions) init() {
	m.data.SetName("newrelicoracledb.connection.inactive_sessions")
	m.data.SetDescription("Number of inactive Oracle database sessions")
	m.data.SetUnit("{sessions}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbConnectionInactiveSessions) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbConnectionInactiveSessions) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbConnectionInactiveSessions) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbConnectionInactiveSessions(cfg MetricConfig) metricNewrelicoracledbConnectionInactiveSessions {
	m := metricNewrelicoracledbConnectionInactiveSessions{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbConnectionLogonsCumulative struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.connection.logons_cumulative metric with initial data.
func (m *metricNewrelicoracledbConnectionLogonsCumulative) init() {
	m.data.SetName("newrelicoracledb.connection.logons_cumulative")
	m.data.SetDescription("Cumulative number of logons since instance startup")
	m.data.SetUnit("{logons}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbConnectionLogonsCumulative) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbConnectionLogonsCumulative) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbConnectionLogonsCumulative) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbConnectionLogonsCumulative(cfg MetricConfig) metricNewrelicoracledbConnectionLogonsCumulative {
	m := metricNewrelicoracledbConnectionLogonsCumulative{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbConnectionLogonsCurrent struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.connection.logons_current metric with initial data.
func (m *metricNewrelicoracledbConnectionLogonsCurrent) init() {
	m.data.SetName("newrelicoracledb.connection.logons_current")
	m.data.SetDescription("Current number of active logons")
	m.data.SetUnit("{logons}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbConnectionLogonsCurrent) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbConnectionLogonsCurrent) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbConnectionLogonsCurrent) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbConnectionLogonsCurrent(cfg MetricConfig) metricNewrelicoracledbConnectionLogonsCurrent {
	m := metricNewrelicoracledbConnectionLogonsCurrent{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbConnectionParseCountHard struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.connection.parse_count_hard metric with initial data.
func (m *metricNewrelicoracledbConnectionParseCountHard) init() {
	m.data.SetName("newrelicoracledb.connection.parse_count_hard")
	m.data.SetDescription("Number of hard parse calls")
	m.data.SetUnit("{parses}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbConnectionParseCountHard) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbConnectionParseCountHard) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbConnectionParseCountHard) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbConnectionParseCountHard(cfg MetricConfig) metricNewrelicoracledbConnectionParseCountHard {
	m := metricNewrelicoracledbConnectionParseCountHard{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbConnectionParseCountTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.connection.parse_count_total metric with initial data.
func (m *metricNewrelicoracledbConnectionParseCountTotal) init() {
	m.data.SetName("newrelicoracledb.connection.parse_count_total")
	m.data.SetDescription("Total number of parse calls")
	m.data.SetUnit("{parses}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbConnectionParseCountTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbConnectionParseCountTotal) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbConnectionParseCountTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbConnectionParseCountTotal(cfg MetricConfig) metricNewrelicoracledbConnectionParseCountTotal {
	m := metricNewrelicoracledbConnectionParseCountTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbConnectionResourceCurrentUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.connection.resource_current_utilization metric with initial data.
func (m *metricNewrelicoracledbConnectionResourceCurrentUtilization) init() {
	m.data.SetName("newrelicoracledb.connection.resource_current_utilization")
	m.data.SetDescription("Current utilization of Oracle resources")
	m.data.SetUnit("{resources}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbConnectionResourceCurrentUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, resourceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("resource.name", resourceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbConnectionResourceCurrentUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbConnectionResourceCurrentUtilization) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbConnectionResourceCurrentUtilization(cfg MetricConfig) metricNewrelicoracledbConnectionResourceCurrentUtilization {
	m := metricNewrelicoracledbConnectionResourceCurrentUtilization{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbConnectionResourceLimit struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.connection.resource_limit metric with initial data.
func (m *metricNewrelicoracledbConnectionResourceLimit) init() {
	m.data.SetName("newrelicoracledb.connection.resource_limit")
	m.data.SetDescription("Limit value for Oracle resources")
	m.data.SetUnit("{resources}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbConnectionResourceLimit) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, resourceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("resource.name", resourceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbConnectionResourceLimit) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbConnectionResourceLimit) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbConnectionResourceLimit(cfg MetricConfig) metricNewrelicoracledbConnectionResourceLimit {
	m := metricNewrelicoracledbConnectionResourceLimit{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbConnectionResourceMaxUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.connection.resource_max_utilization metric with initial data.
func (m *metricNewrelicoracledbConnectionResourceMaxUtilization) init() {
	m.data.SetName("newrelicoracledb.connection.resource_max_utilization")
	m.data.SetDescription("Maximum utilization of Oracle resources since startup")
	m.data.SetUnit("{resources}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbConnectionResourceMaxUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, resourceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("resource.name", resourceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbConnectionResourceMaxUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbConnectionResourceMaxUtilization) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbConnectionResourceMaxUtilization(cfg MetricConfig) metricNewrelicoracledbConnectionResourceMaxUtilization {
	m := metricNewrelicoracledbConnectionResourceMaxUtilization{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbConnectionSessionCPUUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.connection.session_cpu_usage metric with initial data.
func (m *metricNewrelicoracledbConnectionSessionCPUUsage) init() {
	m.data.SetName("newrelicoracledb.connection.session_cpu_usage")
	m.data.SetDescription("CPU usage by session in seconds")
	m.data.SetUnit("s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbConnectionSessionCPUUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, sessionIDAttributeValue string, usernameAttributeValue string, sessionStatusAttributeValue string, programAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("session.id", sessionIDAttributeValue)
	dp.Attributes().PutStr("username", usernameAttributeValue)
	dp.Attributes().PutStr("session.status", sessionStatusAttributeValue)
	dp.Attributes().PutStr("program", programAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbConnectionSessionCPUUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbConnectionSessionCPUUsage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbConnectionSessionCPUUsage(cfg MetricConfig) metricNewrelicoracledbConnectionSessionCPUUsage {
	m := metricNewrelicoracledbConnectionSessionCPUUsage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbConnectionSessionIdleTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.connection.session_idle_time metric with initial data.
func (m *metricNewrelicoracledbConnectionSessionIdleTime) init() {
	m.data.SetName("newrelicoracledb.connection.session_idle_time")
	m.data.SetDescription("Session idle time in seconds")
	m.data.SetUnit("s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbConnectionSessionIdleTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, sessionIDAttributeValue string, usernameAttributeValue string, sessionStatusAttributeValue string, programAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("session.id", sessionIDAttributeValue)
	dp.Attributes().PutStr("username", usernameAttributeValue)
	dp.Attributes().PutStr("session.status", sessionStatusAttributeValue)
	dp.Attributes().PutStr("program", programAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbConnectionSessionIdleTime) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbConnectionSessionIdleTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbConnectionSessionIdleTime(cfg MetricConfig) metricNewrelicoracledbConnectionSessionIdleTime {
	m := metricNewrelicoracledbConnectionSessionIdleTime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbConnectionSessionLogicalReads struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.connection.session_logical_reads metric with initial data.
func (m *metricNewrelicoracledbConnectionSessionLogicalReads) init() {
	m.data.SetName("newrelicoracledb.connection.session_logical_reads")
	m.data.SetDescription("Logical reads by session")
	m.data.SetUnit("{reads}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbConnectionSessionLogicalReads) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, sessionIDAttributeValue string, usernameAttributeValue string, sessionStatusAttributeValue string, programAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("session.id", sessionIDAttributeValue)
	dp.Attributes().PutStr("username", usernameAttributeValue)
	dp.Attributes().PutStr("session.status", sessionStatusAttributeValue)
	dp.Attributes().PutStr("program", programAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbConnectionSessionLogicalReads) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbConnectionSessionLogicalReads) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbConnectionSessionLogicalReads(cfg MetricConfig) metricNewrelicoracledbConnectionSessionLogicalReads {
	m := metricNewrelicoracledbConnectionSessionLogicalReads{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbConnectionSessionPgaMemory struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.connection.session_pga_memory metric with initial data.
func (m *metricNewrelicoracledbConnectionSessionPgaMemory) init() {
	m.data.SetName("newrelicoracledb.connection.session_pga_memory")
	m.data.SetDescription("PGA memory usage by session")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbConnectionSessionPgaMemory) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, sessionIDAttributeValue string, usernameAttributeValue string, sessionStatusAttributeValue string, programAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("session.id", sessionIDAttributeValue)
	dp.Attributes().PutStr("username", usernameAttributeValue)
	dp.Attributes().PutStr("session.status", sessionStatusAttributeValue)
	dp.Attributes().PutStr("program", programAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbConnectionSessionPgaMemory) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbConnectionSessionPgaMemory) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbConnectionSessionPgaMemory(cfg MetricConfig) metricNewrelicoracledbConnectionSessionPgaMemory {
	m := metricNewrelicoracledbConnectionSessionPgaMemory{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbConnectionSessionsByStatus struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.connection.sessions_by_status metric with initial data.
func (m *metricNewrelicoracledbConnectionSessionsByStatus) init() {
	m.data.SetName("newrelicoracledb.connection.sessions_by_status")
	m.data.SetDescription("Number of sessions grouped by status")
	m.data.SetUnit("{sessions}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbConnectionSessionsByStatus) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, sessionStatusAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("session.status", sessionStatusAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbConnectionSessionsByStatus) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbConnectionSessionsByStatus) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbConnectionSessionsByStatus(cfg MetricConfig) metricNewrelicoracledbConnectionSessionsByStatus {
	m := metricNewrelicoracledbConnectionSessionsByStatus{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbConnectionSessionsByType struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.connection.sessions_by_type metric with initial data.
func (m *metricNewrelicoracledbConnectionSessionsByType) init() {
	m.data.SetName("newrelicoracledb.connection.sessions_by_type")
	m.data.SetDescription("Number of sessions grouped by type")
	m.data.SetUnit("{sessions}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbConnectionSessionsByType) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, sessionTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("session.type", sessionTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbConnectionSessionsByType) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbConnectionSessionsByType) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbConnectionSessionsByType(cfg MetricConfig) metricNewrelicoracledbConnectionSessionsByType {
	m := metricNewrelicoracledbConnectionSessionsByType{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbConnectionSharedServers struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.connection.shared_servers metric with initial data.
func (m *metricNewrelicoracledbConnectionSharedServers) init() {
	m.data.SetName("newrelicoracledb.connection.shared_servers")
	m.data.SetDescription("Number of shared servers")
	m.data.SetUnit("{servers}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbConnectionSharedServers) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbConnectionSharedServers) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbConnectionSharedServers) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbConnectionSharedServers(cfg MetricConfig) metricNewrelicoracledbConnectionSharedServers {
	m := metricNewrelicoracledbConnectionSharedServers{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbConnectionSqlnetRoundtrips struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.connection.sqlnet_roundtrips metric with initial data.
func (m *metricNewrelicoracledbConnectionSqlnetRoundtrips) init() {
	m.data.SetName("newrelicoracledb.connection.sqlnet_roundtrips")
	m.data.SetDescription("Number of SQL*Net roundtrips to/from client")
	m.data.SetUnit("{roundtrips}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbConnectionSqlnetRoundtrips) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbConnectionSqlnetRoundtrips) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbConnectionSqlnetRoundtrips) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbConnectionSqlnetRoundtrips(cfg MetricConfig) metricNewrelicoracledbConnectionSqlnetRoundtrips {
	m := metricNewrelicoracledbConnectionSqlnetRoundtrips{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbConnectionTotalSessions struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.connection.total_sessions metric with initial data.
func (m *metricNewrelicoracledbConnectionTotalSessions) init() {
	m.data.SetName("newrelicoracledb.connection.total_sessions")
	m.data.SetDescription("Total number of Oracle database sessions")
	m.data.SetUnit("{sessions}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbConnectionTotalSessions) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbConnectionTotalSessions) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbConnectionTotalSessions) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbConnectionTotalSessions(cfg MetricConfig) metricNewrelicoracledbConnectionTotalSessions {
	m := metricNewrelicoracledbConnectionTotalSessions{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbConnectionUserCommits struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.connection.user_commits metric with initial data.
func (m *metricNewrelicoracledbConnectionUserCommits) init() {
	m.data.SetName("newrelicoracledb.connection.user_commits")
	m.data.SetDescription("Number of user commits")
	m.data.SetUnit("{commits}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbConnectionUserCommits) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbConnectionUserCommits) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbConnectionUserCommits) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbConnectionUserCommits(cfg MetricConfig) metricNewrelicoracledbConnectionUserCommits {
	m := metricNewrelicoracledbConnectionUserCommits{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbConnectionUserRollbacks struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.connection.user_rollbacks metric with initial data.
func (m *metricNewrelicoracledbConnectionUserRollbacks) init() {
	m.data.SetName("newrelicoracledb.connection.user_rollbacks")
	m.data.SetDescription("Number of user rollbacks")
	m.data.SetUnit("{rollbacks}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbConnectionUserRollbacks) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbConnectionUserRollbacks) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbConnectionUserRollbacks) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbConnectionUserRollbacks(cfg MetricConfig) metricNewrelicoracledbConnectionUserRollbacks {
	m := metricNewrelicoracledbConnectionUserRollbacks{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbConnectionWaitEventAvgWaitTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.connection.wait_event_avg_wait_time metric with initial data.
func (m *metricNewrelicoracledbConnectionWaitEventAvgWaitTime) init() {
	m.data.SetName("newrelicoracledb.connection.wait_event_avg_wait_time")
	m.data.SetDescription("Average wait time for each wait event")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbConnectionWaitEventAvgWaitTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, waitEventAttributeValue string, waitClassAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("wait.event", waitEventAttributeValue)
	dp.Attributes().PutStr("wait.class", waitClassAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbConnectionWaitEventAvgWaitTime) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbConnectionWaitEventAvgWaitTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbConnectionWaitEventAvgWaitTime(cfg MetricConfig) metricNewrelicoracledbConnectionWaitEventAvgWaitTime {
	m := metricNewrelicoracledbConnectionWaitEventAvgWaitTime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbConnectionWaitEventTimeWaited struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.connection.wait_event_time_waited metric with initial data.
func (m *metricNewrelicoracledbConnectionWaitEventTimeWaited) init() {
	m.data.SetName("newrelicoracledb.connection.wait_event_time_waited")
	m.data.SetDescription("Total time waited for each wait event")
	m.data.SetUnit("ms")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbConnectionWaitEventTimeWaited) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, waitEventAttributeValue string, waitClassAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("wait.event", waitEventAttributeValue)
	dp.Attributes().PutStr("wait.class", waitClassAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbConnectionWaitEventTimeWaited) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbConnectionWaitEventTimeWaited) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbConnectionWaitEventTimeWaited(cfg MetricConfig) metricNewrelicoracledbConnectionWaitEventTimeWaited {
	m := metricNewrelicoracledbConnectionWaitEventTimeWaited{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbConnectionWaitEventTotalWaits struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.connection.wait_event_total_waits metric with initial data.
func (m *metricNewrelicoracledbConnectionWaitEventTotalWaits) init() {
	m.data.SetName("newrelicoracledb.connection.wait_event_total_waits")
	m.data.SetDescription("Total number of waits for each wait event")
	m.data.SetUnit("{waits}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbConnectionWaitEventTotalWaits) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, waitEventAttributeValue string, waitClassAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("wait.event", waitEventAttributeValue)
	dp.Attributes().PutStr("wait.class", waitClassAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbConnectionWaitEventTotalWaits) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbConnectionWaitEventTotalWaits) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbConnectionWaitEventTotalWaits(cfg MetricConfig) metricNewrelicoracledbConnectionWaitEventTotalWaits {
	m := metricNewrelicoracledbConnectionWaitEventTotalWaits{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbConnectionWaitEvents struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.connection.wait_events metric with initial data.
func (m *metricNewrelicoracledbConnectionWaitEvents) init() {
	m.data.SetName("newrelicoracledb.connection.wait_events")
	m.data.SetDescription("Current wait events and wait time")
	m.data.SetUnit("s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbConnectionWaitEvents) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, sessionIDAttributeValue string, usernameAttributeValue string, waitEventAttributeValue string, waitStateAttributeValue string, waitClassAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("session.id", sessionIDAttributeValue)
	dp.Attributes().PutStr("username", usernameAttributeValue)
	dp.Attributes().PutStr("wait.event", waitEventAttributeValue)
	dp.Attributes().PutStr("wait.state", waitStateAttributeValue)
	dp.Attributes().PutStr("wait.class", waitClassAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbConnectionWaitEvents) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbConnectionWaitEvents) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbConnectionWaitEvents(cfg MetricConfig) metricNewrelicoracledbConnectionWaitEvents {
	m := metricNewrelicoracledbConnectionWaitEvents{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbContainerRestricted struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.container.restricted metric with initial data.
func (m *metricNewrelicoracledbContainerRestricted) init() {
	m.data.SetName("newrelicoracledb.container.restricted")
	m.data.SetDescription("Oracle container restricted status (1=YES, 0=NO)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbContainerRestricted) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, conIDAttributeValue string, containerNameAttributeValue string, restrictedStatusAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("con.id", conIDAttributeValue)
	dp.Attributes().PutStr("container.name", containerNameAttributeValue)
	dp.Attributes().PutStr("restricted.status", restrictedStatusAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbContainerRestricted) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbContainerRestricted) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbContainerRestricted(cfg MetricConfig) metricNewrelicoracledbContainerRestricted {
	m := metricNewrelicoracledbContainerRestricted{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbContainerStatus struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.container.status metric with initial data.
func (m *metricNewrelicoracledbContainerStatus) init() {
	m.data.SetName("newrelicoracledb.container.status")
	m.data.SetDescription("Oracle container status (1=READ WRITE, 0=other)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbContainerStatus) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, conIDAttributeValue string, containerNameAttributeValue string, openModeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("con.id", conIDAttributeValue)
	dp.Attributes().PutStr("container.name", containerNameAttributeValue)
	dp.Attributes().PutStr("open.mode", openModeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbContainerStatus) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbContainerStatus) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbContainerStatus(cfg MetricConfig) metricNewrelicoracledbContainerStatus {
	m := metricNewrelicoracledbContainerStatus{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbDatafileAutoextensible struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.datafile.autoextensible metric with initial data.
func (m *metricNewrelicoracledbDatafileAutoextensible) init() {
	m.data.SetName("newrelicoracledb.datafile.autoextensible")
	m.data.SetDescription("Data file autoextensible status (1=YES, 0=NO)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbDatafileAutoextensible) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, conIDAttributeValue string, tablespaceNameAttributeValue string, fileNameAttributeValue string, containerStatusAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("con.id", conIDAttributeValue)
	dp.Attributes().PutStr("tablespace.name", tablespaceNameAttributeValue)
	dp.Attributes().PutStr("file.name", fileNameAttributeValue)
	dp.Attributes().PutStr("container.status", containerStatusAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbDatafileAutoextensible) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbDatafileAutoextensible) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbDatafileAutoextensible(cfg MetricConfig) metricNewrelicoracledbDatafileAutoextensible {
	m := metricNewrelicoracledbDatafileAutoextensible{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbDatafileSizeBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.datafile.size_bytes metric with initial data.
func (m *metricNewrelicoracledbDatafileSizeBytes) init() {
	m.data.SetName("newrelicoracledb.datafile.size_bytes")
	m.data.SetDescription("Size of data file in bytes")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbDatafileSizeBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, conIDAttributeValue string, tablespaceNameAttributeValue string, fileNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("con.id", conIDAttributeValue)
	dp.Attributes().PutStr("tablespace.name", tablespaceNameAttributeValue)
	dp.Attributes().PutStr("file.name", fileNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbDatafileSizeBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbDatafileSizeBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbDatafileSizeBytes(cfg MetricConfig) metricNewrelicoracledbDatafileSizeBytes {
	m := metricNewrelicoracledbDatafileSizeBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbDatafileUsedBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.datafile.used_bytes metric with initial data.
func (m *metricNewrelicoracledbDatafileUsedBytes) init() {
	m.data.SetName("newrelicoracledb.datafile.used_bytes")
	m.data.SetDescription("Used bytes in data file")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbDatafileUsedBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, conIDAttributeValue string, tablespaceNameAttributeValue string, fileNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("con.id", conIDAttributeValue)
	dp.Attributes().PutStr("tablespace.name", tablespaceNameAttributeValue)
	dp.Attributes().PutStr("file.name", fileNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbDatafileUsedBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbDatafileUsedBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbDatafileUsedBytes(cfg MetricConfig) metricNewrelicoracledbDatafileUsedBytes {
	m := metricNewrelicoracledbDatafileUsedBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbDbID struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.db_id metric with initial data.
func (m *metricNewrelicoracledbDbID) init() {
	m.data.SetName("newrelicoracledb.db_id")
	m.data.SetDescription("Oracle database ID information")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbDbID) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string, dbIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
	dp.Attributes().PutStr("db.id", dbIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbDbID) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbDbID) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbDbID(cfg MetricConfig) metricNewrelicoracledbDbID {
	m := metricNewrelicoracledbDbID{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbDiskBlocksRead struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.disk.blocks_read metric with initial data.
func (m *metricNewrelicoracledbDiskBlocksRead) init() {
	m.data.SetName("newrelicoracledb.disk.blocks_read")
	m.data.SetDescription("Number of physical blocks read from disk")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbDiskBlocksRead) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbDiskBlocksRead) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbDiskBlocksRead) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbDiskBlocksRead(cfg MetricConfig) metricNewrelicoracledbDiskBlocksRead {
	m := metricNewrelicoracledbDiskBlocksRead{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbDiskBlocksWritten struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.disk.blocks_written metric with initial data.
func (m *metricNewrelicoracledbDiskBlocksWritten) init() {
	m.data.SetName("newrelicoracledb.disk.blocks_written")
	m.data.SetDescription("Number of physical blocks written to disk")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbDiskBlocksWritten) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbDiskBlocksWritten) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbDiskBlocksWritten) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbDiskBlocksWritten(cfg MetricConfig) metricNewrelicoracledbDiskBlocksWritten {
	m := metricNewrelicoracledbDiskBlocksWritten{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbDiskReadTimeMilliseconds struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.disk.read_time_milliseconds metric with initial data.
func (m *metricNewrelicoracledbDiskReadTimeMilliseconds) init() {
	m.data.SetName("newrelicoracledb.disk.read_time_milliseconds")
	m.data.SetDescription("Time spent reading from disk in milliseconds")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbDiskReadTimeMilliseconds) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbDiskReadTimeMilliseconds) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbDiskReadTimeMilliseconds) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbDiskReadTimeMilliseconds(cfg MetricConfig) metricNewrelicoracledbDiskReadTimeMilliseconds {
	m := metricNewrelicoracledbDiskReadTimeMilliseconds{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbDiskReads struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.disk.reads metric with initial data.
func (m *metricNewrelicoracledbDiskReads) init() {
	m.data.SetName("newrelicoracledb.disk.reads")
	m.data.SetDescription("Number of physical disk reads")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbDiskReads) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbDiskReads) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbDiskReads) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbDiskReads(cfg MetricConfig) metricNewrelicoracledbDiskReads {
	m := metricNewrelicoracledbDiskReads{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbDiskWriteTimeMilliseconds struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.disk.write_time_milliseconds metric with initial data.
func (m *metricNewrelicoracledbDiskWriteTimeMilliseconds) init() {
	m.data.SetName("newrelicoracledb.disk.write_time_milliseconds")
	m.data.SetDescription("Time spent writing to disk in milliseconds")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbDiskWriteTimeMilliseconds) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbDiskWriteTimeMilliseconds) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbDiskWriteTimeMilliseconds) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbDiskWriteTimeMilliseconds(cfg MetricConfig) metricNewrelicoracledbDiskWriteTimeMilliseconds {
	m := metricNewrelicoracledbDiskWriteTimeMilliseconds{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbDiskWrites struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.disk.writes metric with initial data.
func (m *metricNewrelicoracledbDiskWrites) init() {
	m.data.SetName("newrelicoracledb.disk.writes")
	m.data.SetDescription("Number of physical disk writes")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbDiskWrites) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbDiskWrites) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbDiskWrites) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbDiskWrites(cfg MetricConfig) metricNewrelicoracledbDiskWrites {
	m := metricNewrelicoracledbDiskWrites{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbGlobalName struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.global_name metric with initial data.
func (m *metricNewrelicoracledbGlobalName) init() {
	m.data.SetName("newrelicoracledb.global_name")
	m.data.SetDescription("Oracle database global name information")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbGlobalName) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string, globalNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
	dp.Attributes().PutStr("global.name", globalNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbGlobalName) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbGlobalName) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbGlobalName(cfg MetricConfig) metricNewrelicoracledbGlobalName {
	m := metricNewrelicoracledbGlobalName{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbLockedAccounts struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.locked_accounts metric with initial data.
func (m *metricNewrelicoracledbLockedAccounts) init() {
	m.data.SetName("newrelicoracledb.locked_accounts")
	m.data.SetDescription("Count of locked user accounts in the database")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbLockedAccounts) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbLockedAccounts) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbLockedAccounts) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbLockedAccounts(cfg MetricConfig) metricNewrelicoracledbLockedAccounts {
	m := metricNewrelicoracledbLockedAccounts{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbLongRunningQueries struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.long_running_queries metric with initial data.
func (m *metricNewrelicoracledbLongRunningQueries) init() {
	m.data.SetName("newrelicoracledb.long_running_queries")
	m.data.SetDescription("Number of long running queries (active sessions running for more than 60 seconds)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbLongRunningQueries) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbLongRunningQueries) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbLongRunningQueries) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbLongRunningQueries(cfg MetricConfig) metricNewrelicoracledbLongRunningQueries {
	m := metricNewrelicoracledbLongRunningQueries{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbMemoryPgaAllocatedBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.memory.pga_allocated_bytes metric with initial data.
func (m *metricNewrelicoracledbMemoryPgaAllocatedBytes) init() {
	m.data.SetName("newrelicoracledb.memory.pga_allocated_bytes")
	m.data.SetDescription("Total PGA memory allocated in bytes")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbMemoryPgaAllocatedBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbMemoryPgaAllocatedBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbMemoryPgaAllocatedBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbMemoryPgaAllocatedBytes(cfg MetricConfig) metricNewrelicoracledbMemoryPgaAllocatedBytes {
	m := metricNewrelicoracledbMemoryPgaAllocatedBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbMemoryPgaFreeableBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.memory.pga_freeable_bytes metric with initial data.
func (m *metricNewrelicoracledbMemoryPgaFreeableBytes) init() {
	m.data.SetName("newrelicoracledb.memory.pga_freeable_bytes")
	m.data.SetDescription("Total freeable PGA memory in bytes")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbMemoryPgaFreeableBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbMemoryPgaFreeableBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbMemoryPgaFreeableBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbMemoryPgaFreeableBytes(cfg MetricConfig) metricNewrelicoracledbMemoryPgaFreeableBytes {
	m := metricNewrelicoracledbMemoryPgaFreeableBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbMemoryPgaInUseBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.memory.pga_in_use_bytes metric with initial data.
func (m *metricNewrelicoracledbMemoryPgaInUseBytes) init() {
	m.data.SetName("newrelicoracledb.memory.pga_in_use_bytes")
	m.data.SetDescription("Total PGA memory currently in use in bytes")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbMemoryPgaInUseBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbMemoryPgaInUseBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbMemoryPgaInUseBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbMemoryPgaInUseBytes(cfg MetricConfig) metricNewrelicoracledbMemoryPgaInUseBytes {
	m := metricNewrelicoracledbMemoryPgaInUseBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbMemoryPgaMaxSizeBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.memory.pga_max_size_bytes metric with initial data.
func (m *metricNewrelicoracledbMemoryPgaMaxSizeBytes) init() {
	m.data.SetName("newrelicoracledb.memory.pga_max_size_bytes")
	m.data.SetDescription("Global memory bound for PGA in bytes")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbMemoryPgaMaxSizeBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbMemoryPgaMaxSizeBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbMemoryPgaMaxSizeBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbMemoryPgaMaxSizeBytes(cfg MetricConfig) metricNewrelicoracledbMemoryPgaMaxSizeBytes {
	m := metricNewrelicoracledbMemoryPgaMaxSizeBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbMemorySgaSharedPoolLibraryCacheSharableBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.memory.sga_shared_pool_library_cache_sharable_bytes metric with initial data.
func (m *metricNewrelicoracledbMemorySgaSharedPoolLibraryCacheSharableBytes) init() {
	m.data.SetName("newrelicoracledb.memory.sga_shared_pool_library_cache_sharable_bytes")
	m.data.SetDescription("SGA shared pool library cache sharable memory in bytes for statements with more than 5 executions")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbMemorySgaSharedPoolLibraryCacheSharableBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbMemorySgaSharedPoolLibraryCacheSharableBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbMemorySgaSharedPoolLibraryCacheSharableBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbMemorySgaSharedPoolLibraryCacheSharableBytes(cfg MetricConfig) metricNewrelicoracledbMemorySgaSharedPoolLibraryCacheSharableBytes {
	m := metricNewrelicoracledbMemorySgaSharedPoolLibraryCacheSharableBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbMemorySgaSharedPoolLibraryCacheUserBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.memory.sga_shared_pool_library_cache_user_bytes metric with initial data.
func (m *metricNewrelicoracledbMemorySgaSharedPoolLibraryCacheUserBytes) init() {
	m.data.SetName("newrelicoracledb.memory.sga_shared_pool_library_cache_user_bytes")
	m.data.SetDescription("SGA shared pool library cache shareable memory per user in bytes (250 * users_opening)")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbMemorySgaSharedPoolLibraryCacheUserBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbMemorySgaSharedPoolLibraryCacheUserBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbMemorySgaSharedPoolLibraryCacheUserBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbMemorySgaSharedPoolLibraryCacheUserBytes(cfg MetricConfig) metricNewrelicoracledbMemorySgaSharedPoolLibraryCacheUserBytes {
	m := metricNewrelicoracledbMemorySgaSharedPoolLibraryCacheUserBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbMemorySgaUgaTotalBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.memory.sga_uga_total_bytes metric with initial data.
func (m *metricNewrelicoracledbMemorySgaUgaTotalBytes) init() {
	m.data.SetName("newrelicoracledb.memory.sga_uga_total_bytes")
	m.data.SetDescription("Total SGA UGA memory in bytes (session uga memory max)")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbMemorySgaUgaTotalBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbMemorySgaUgaTotalBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbMemorySgaUgaTotalBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbMemorySgaUgaTotalBytes(cfg MetricConfig) metricNewrelicoracledbMemorySgaUgaTotalBytes {
	m := metricNewrelicoracledbMemorySgaUgaTotalBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbActiveParallelSessions struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.active_parallel_sessions metric with initial data.
func (m *metricNewrelicoracledbPdbActiveParallelSessions) init() {
	m.data.SetName("newrelicoracledb.pdb.active_parallel_sessions")
	m.data.SetDescription("Number of active parallel sessions in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbActiveParallelSessions) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbActiveParallelSessions) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbActiveParallelSessions) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbActiveParallelSessions(cfg MetricConfig) metricNewrelicoracledbPdbActiveParallelSessions {
	m := metricNewrelicoracledbPdbActiveParallelSessions{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbActiveSerialSessions struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.active_serial_sessions metric with initial data.
func (m *metricNewrelicoracledbPdbActiveSerialSessions) init() {
	m.data.SetName("newrelicoracledb.pdb.active_serial_sessions")
	m.data.SetDescription("Number of active serial sessions in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbActiveSerialSessions) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbActiveSerialSessions) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbActiveSerialSessions) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbActiveSerialSessions(cfg MetricConfig) metricNewrelicoracledbPdbActiveSerialSessions {
	m := metricNewrelicoracledbPdbActiveSerialSessions{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbAverageActiveSessions struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.average_active_sessions metric with initial data.
func (m *metricNewrelicoracledbPdbAverageActiveSessions) init() {
	m.data.SetName("newrelicoracledb.pdb.average_active_sessions")
	m.data.SetDescription("Average number of active sessions in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbAverageActiveSessions) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbAverageActiveSessions) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbAverageActiveSessions) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbAverageActiveSessions(cfg MetricConfig) metricNewrelicoracledbPdbAverageActiveSessions {
	m := metricNewrelicoracledbPdbAverageActiveSessions{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbBackgroundCPUUsagePerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.background_cpu_usage_per_second metric with initial data.
func (m *metricNewrelicoracledbPdbBackgroundCPUUsagePerSecond) init() {
	m.data.SetName("newrelicoracledb.pdb.background_cpu_usage_per_second")
	m.data.SetDescription("Background CPU usage per second in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbBackgroundCPUUsagePerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbBackgroundCPUUsagePerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbBackgroundCPUUsagePerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbBackgroundCPUUsagePerSecond(cfg MetricConfig) metricNewrelicoracledbPdbBackgroundCPUUsagePerSecond {
	m := metricNewrelicoracledbPdbBackgroundCPUUsagePerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbBackgroundTimePerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.background_time_per_second metric with initial data.
func (m *metricNewrelicoracledbPdbBackgroundTimePerSecond) init() {
	m.data.SetName("newrelicoracledb.pdb.background_time_per_second")
	m.data.SetDescription("Background time per second in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbBackgroundTimePerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbBackgroundTimePerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbBackgroundTimePerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbBackgroundTimePerSecond(cfg MetricConfig) metricNewrelicoracledbPdbBackgroundTimePerSecond {
	m := metricNewrelicoracledbPdbBackgroundTimePerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbBlockChangesPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.block_changes_per_second metric with initial data.
func (m *metricNewrelicoracledbPdbBlockChangesPerSecond) init() {
	m.data.SetName("newrelicoracledb.pdb.block_changes_per_second")
	m.data.SetDescription("DB block changes per second in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbBlockChangesPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbBlockChangesPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbBlockChangesPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbBlockChangesPerSecond(cfg MetricConfig) metricNewrelicoracledbPdbBlockChangesPerSecond {
	m := metricNewrelicoracledbPdbBlockChangesPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbBlockChangesPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.block_changes_per_transaction metric with initial data.
func (m *metricNewrelicoracledbPdbBlockChangesPerTransaction) init() {
	m.data.SetName("newrelicoracledb.pdb.block_changes_per_transaction")
	m.data.SetDescription("DB block changes per transaction in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbBlockChangesPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbBlockChangesPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbBlockChangesPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbBlockChangesPerTransaction(cfg MetricConfig) metricNewrelicoracledbPdbBlockChangesPerTransaction {
	m := metricNewrelicoracledbPdbBlockChangesPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbCPUTimeRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.cpu_time_ratio metric with initial data.
func (m *metricNewrelicoracledbPdbCPUTimeRatio) init() {
	m.data.SetName("newrelicoracledb.pdb.cpu_time_ratio")
	m.data.SetDescription("Database CPU time ratio in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbCPUTimeRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbCPUTimeRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbCPUTimeRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbCPUTimeRatio(cfg MetricConfig) metricNewrelicoracledbPdbCPUTimeRatio {
	m := metricNewrelicoracledbPdbCPUTimeRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbCPUUsagePerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.cpu_usage_per_second metric with initial data.
func (m *metricNewrelicoracledbPdbCPUUsagePerSecond) init() {
	m.data.SetName("newrelicoracledb.pdb.cpu_usage_per_second")
	m.data.SetDescription("CPU usage per second in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbCPUUsagePerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbCPUUsagePerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbCPUUsagePerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbCPUUsagePerSecond(cfg MetricConfig) metricNewrelicoracledbPdbCPUUsagePerSecond {
	m := metricNewrelicoracledbPdbCPUUsagePerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbCPUUsagePerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.cpu_usage_per_transaction metric with initial data.
func (m *metricNewrelicoracledbPdbCPUUsagePerTransaction) init() {
	m.data.SetName("newrelicoracledb.pdb.cpu_usage_per_transaction")
	m.data.SetDescription("CPU usage per transaction in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbCPUUsagePerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbCPUUsagePerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbCPUUsagePerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbCPUUsagePerTransaction(cfg MetricConfig) metricNewrelicoracledbPdbCPUUsagePerTransaction {
	m := metricNewrelicoracledbPdbCPUUsagePerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbCurrentLogons struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.current_logons metric with initial data.
func (m *metricNewrelicoracledbPdbCurrentLogons) init() {
	m.data.SetName("newrelicoracledb.pdb.current_logons")
	m.data.SetDescription("Current number of logons in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbCurrentLogons) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbCurrentLogons) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbCurrentLogons) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbCurrentLogons(cfg MetricConfig) metricNewrelicoracledbPdbCurrentLogons {
	m := metricNewrelicoracledbPdbCurrentLogons{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbCurrentOpenCursors struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.current_open_cursors metric with initial data.
func (m *metricNewrelicoracledbPdbCurrentOpenCursors) init() {
	m.data.SetName("newrelicoracledb.pdb.current_open_cursors")
	m.data.SetDescription("Current number of open cursors in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbCurrentOpenCursors) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbCurrentOpenCursors) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbCurrentOpenCursors) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbCurrentOpenCursors(cfg MetricConfig) metricNewrelicoracledbPdbCurrentOpenCursors {
	m := metricNewrelicoracledbPdbCurrentOpenCursors{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbDbPhysicalReadBytesPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.db_physical_read_bytes_per_second metric with initial data.
func (m *metricNewrelicoracledbPdbDbPhysicalReadBytesPerSecond) init() {
	m.data.SetName("newrelicoracledb.pdb.db_physical_read_bytes_per_second")
	m.data.SetDescription("Physical read bytes per second in PDB")
	m.data.SetUnit("By/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbDbPhysicalReadBytesPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbDbPhysicalReadBytesPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbDbPhysicalReadBytesPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbDbPhysicalReadBytesPerSecond(cfg MetricConfig) metricNewrelicoracledbPdbDbPhysicalReadBytesPerSecond {
	m := metricNewrelicoracledbPdbDbPhysicalReadBytesPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbDbPhysicalReadsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.db_physical_reads_per_second metric with initial data.
func (m *metricNewrelicoracledbPdbDbPhysicalReadsPerSecond) init() {
	m.data.SetName("newrelicoracledb.pdb.db_physical_reads_per_second")
	m.data.SetDescription("Physical reads per second in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbDbPhysicalReadsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbDbPhysicalReadsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbDbPhysicalReadsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbDbPhysicalReadsPerSecond(cfg MetricConfig) metricNewrelicoracledbPdbDbPhysicalReadsPerSecond {
	m := metricNewrelicoracledbPdbDbPhysicalReadsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbDbPhysicalWriteBytesPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.db_physical_write_bytes_per_second metric with initial data.
func (m *metricNewrelicoracledbPdbDbPhysicalWriteBytesPerSecond) init() {
	m.data.SetName("newrelicoracledb.pdb.db_physical_write_bytes_per_second")
	m.data.SetDescription("Physical write bytes per second in PDB")
	m.data.SetUnit("By/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbDbPhysicalWriteBytesPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbDbPhysicalWriteBytesPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbDbPhysicalWriteBytesPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbDbPhysicalWriteBytesPerSecond(cfg MetricConfig) metricNewrelicoracledbPdbDbPhysicalWriteBytesPerSecond {
	m := metricNewrelicoracledbPdbDbPhysicalWriteBytesPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbDbPhysicalWritesPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.db_physical_writes_per_second metric with initial data.
func (m *metricNewrelicoracledbPdbDbPhysicalWritesPerSecond) init() {
	m.data.SetName("newrelicoracledb.pdb.db_physical_writes_per_second")
	m.data.SetDescription("Physical writes per second in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbDbPhysicalWritesPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbDbPhysicalWritesPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbDbPhysicalWritesPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbDbPhysicalWritesPerSecond(cfg MetricConfig) metricNewrelicoracledbPdbDbPhysicalWritesPerSecond {
	m := metricNewrelicoracledbPdbDbPhysicalWritesPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbExecuteWithoutParseRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.execute_without_parse_ratio metric with initial data.
func (m *metricNewrelicoracledbPdbExecuteWithoutParseRatio) init() {
	m.data.SetName("newrelicoracledb.pdb.execute_without_parse_ratio")
	m.data.SetDescription("Execute without parse ratio in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbExecuteWithoutParseRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbExecuteWithoutParseRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbExecuteWithoutParseRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbExecuteWithoutParseRatio(cfg MetricConfig) metricNewrelicoracledbPdbExecuteWithoutParseRatio {
	m := metricNewrelicoracledbPdbExecuteWithoutParseRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbExecutionsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.executions_per_second metric with initial data.
func (m *metricNewrelicoracledbPdbExecutionsPerSecond) init() {
	m.data.SetName("newrelicoracledb.pdb.executions_per_second")
	m.data.SetDescription("Executions per second in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbExecutionsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbExecutionsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbExecutionsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbExecutionsPerSecond(cfg MetricConfig) metricNewrelicoracledbPdbExecutionsPerSecond {
	m := metricNewrelicoracledbPdbExecutionsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbExecutionsPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.executions_per_transaction metric with initial data.
func (m *metricNewrelicoracledbPdbExecutionsPerTransaction) init() {
	m.data.SetName("newrelicoracledb.pdb.executions_per_transaction")
	m.data.SetDescription("Executions per transaction in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbExecutionsPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbExecutionsPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbExecutionsPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbExecutionsPerTransaction(cfg MetricConfig) metricNewrelicoracledbPdbExecutionsPerTransaction {
	m := metricNewrelicoracledbPdbExecutionsPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbHardParseCountPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.hard_parse_count_per_second metric with initial data.
func (m *metricNewrelicoracledbPdbHardParseCountPerSecond) init() {
	m.data.SetName("newrelicoracledb.pdb.hard_parse_count_per_second")
	m.data.SetDescription("Hard parse count per second in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbHardParseCountPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbHardParseCountPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbHardParseCountPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbHardParseCountPerSecond(cfg MetricConfig) metricNewrelicoracledbPdbHardParseCountPerSecond {
	m := metricNewrelicoracledbPdbHardParseCountPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbHardParseCountPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.hard_parse_count_per_transaction metric with initial data.
func (m *metricNewrelicoracledbPdbHardParseCountPerTransaction) init() {
	m.data.SetName("newrelicoracledb.pdb.hard_parse_count_per_transaction")
	m.data.SetDescription("Hard parse count per transaction in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbHardParseCountPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbHardParseCountPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbHardParseCountPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbHardParseCountPerTransaction(cfg MetricConfig) metricNewrelicoracledbPdbHardParseCountPerTransaction {
	m := metricNewrelicoracledbPdbHardParseCountPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbLogicalReadsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.logical_reads_per_second metric with initial data.
func (m *metricNewrelicoracledbPdbLogicalReadsPerSecond) init() {
	m.data.SetName("newrelicoracledb.pdb.logical_reads_per_second")
	m.data.SetDescription("Logical reads per second in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbLogicalReadsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbLogicalReadsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbLogicalReadsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbLogicalReadsPerSecond(cfg MetricConfig) metricNewrelicoracledbPdbLogicalReadsPerSecond {
	m := metricNewrelicoracledbPdbLogicalReadsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbLogicalReadsPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.logical_reads_per_transaction metric with initial data.
func (m *metricNewrelicoracledbPdbLogicalReadsPerTransaction) init() {
	m.data.SetName("newrelicoracledb.pdb.logical_reads_per_transaction")
	m.data.SetDescription("Logical reads per transaction in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbLogicalReadsPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbLogicalReadsPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbLogicalReadsPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbLogicalReadsPerTransaction(cfg MetricConfig) metricNewrelicoracledbPdbLogicalReadsPerTransaction {
	m := metricNewrelicoracledbPdbLogicalReadsPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbLogonsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.logons_per_second metric with initial data.
func (m *metricNewrelicoracledbPdbLogonsPerSecond) init() {
	m.data.SetName("newrelicoracledb.pdb.logons_per_second")
	m.data.SetDescription("Logons per second in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbLogonsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbLogonsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbLogonsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbLogonsPerSecond(cfg MetricConfig) metricNewrelicoracledbPdbLogonsPerSecond {
	m := metricNewrelicoracledbPdbLogonsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbLogonsPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.logons_per_transaction metric with initial data.
func (m *metricNewrelicoracledbPdbLogonsPerTransaction) init() {
	m.data.SetName("newrelicoracledb.pdb.logons_per_transaction")
	m.data.SetDescription("Logons per transaction in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbLogonsPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbLogonsPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbLogonsPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbLogonsPerTransaction(cfg MetricConfig) metricNewrelicoracledbPdbLogonsPerTransaction {
	m := metricNewrelicoracledbPdbLogonsPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbNetworkTrafficBytePerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.network_traffic_byte_per_second metric with initial data.
func (m *metricNewrelicoracledbPdbNetworkTrafficBytePerSecond) init() {
	m.data.SetName("newrelicoracledb.pdb.network_traffic_byte_per_second")
	m.data.SetDescription("Network traffic volume per second in bytes in PDB")
	m.data.SetUnit("By/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbNetworkTrafficBytePerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbNetworkTrafficBytePerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbNetworkTrafficBytePerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbNetworkTrafficBytePerSecond(cfg MetricConfig) metricNewrelicoracledbPdbNetworkTrafficBytePerSecond {
	m := metricNewrelicoracledbPdbNetworkTrafficBytePerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbOpenCursorsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.open_cursors_per_second metric with initial data.
func (m *metricNewrelicoracledbPdbOpenCursorsPerSecond) init() {
	m.data.SetName("newrelicoracledb.pdb.open_cursors_per_second")
	m.data.SetDescription("Open cursors per second in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbOpenCursorsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbOpenCursorsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbOpenCursorsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbOpenCursorsPerSecond(cfg MetricConfig) metricNewrelicoracledbPdbOpenCursorsPerSecond {
	m := metricNewrelicoracledbPdbOpenCursorsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbOpenCursorsPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.open_cursors_per_transaction metric with initial data.
func (m *metricNewrelicoracledbPdbOpenCursorsPerTransaction) init() {
	m.data.SetName("newrelicoracledb.pdb.open_cursors_per_transaction")
	m.data.SetDescription("Open cursors per transaction in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbOpenCursorsPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbOpenCursorsPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbOpenCursorsPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbOpenCursorsPerTransaction(cfg MetricConfig) metricNewrelicoracledbPdbOpenCursorsPerTransaction {
	m := metricNewrelicoracledbPdbOpenCursorsPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbOpenMode struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.open_mode metric with initial data.
func (m *metricNewrelicoracledbPdbOpenMode) init() {
	m.data.SetName("newrelicoracledb.pdb.open_mode")
	m.data.SetDescription("Oracle PDB open mode (1=READ WRITE, 0=other)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbOpenMode) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, conIDAttributeValue string, pdbNameAttributeValue string, openModeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("con.id", conIDAttributeValue)
	dp.Attributes().PutStr("pdb.name", pdbNameAttributeValue)
	dp.Attributes().PutStr("open.mode", openModeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbOpenMode) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbOpenMode) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbOpenMode(cfg MetricConfig) metricNewrelicoracledbPdbOpenMode {
	m := metricNewrelicoracledbPdbOpenMode{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbParseFailureCountPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.parse_failure_count_per_second metric with initial data.
func (m *metricNewrelicoracledbPdbParseFailureCountPerSecond) init() {
	m.data.SetName("newrelicoracledb.pdb.parse_failure_count_per_second")
	m.data.SetDescription("Parse failure count per second in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbParseFailureCountPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbParseFailureCountPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbParseFailureCountPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbParseFailureCountPerSecond(cfg MetricConfig) metricNewrelicoracledbPdbParseFailureCountPerSecond {
	m := metricNewrelicoracledbPdbParseFailureCountPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbPhysicalReadBytesPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.physical_read_bytes_per_second metric with initial data.
func (m *metricNewrelicoracledbPdbPhysicalReadBytesPerSecond) init() {
	m.data.SetName("newrelicoracledb.pdb.physical_read_bytes_per_second")
	m.data.SetDescription("Physical read total bytes per second in PDB")
	m.data.SetUnit("By/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbPhysicalReadBytesPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbPhysicalReadBytesPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbPhysicalReadBytesPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbPhysicalReadBytesPerSecond(cfg MetricConfig) metricNewrelicoracledbPdbPhysicalReadBytesPerSecond {
	m := metricNewrelicoracledbPdbPhysicalReadBytesPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbPhysicalReadsPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.physical_reads_per_transaction metric with initial data.
func (m *metricNewrelicoracledbPdbPhysicalReadsPerTransaction) init() {
	m.data.SetName("newrelicoracledb.pdb.physical_reads_per_transaction")
	m.data.SetDescription("Physical reads per transaction in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbPhysicalReadsPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbPhysicalReadsPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbPhysicalReadsPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbPhysicalReadsPerTransaction(cfg MetricConfig) metricNewrelicoracledbPdbPhysicalReadsPerTransaction {
	m := metricNewrelicoracledbPdbPhysicalReadsPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbPhysicalWriteBytesPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.physical_write_bytes_per_second metric with initial data.
func (m *metricNewrelicoracledbPdbPhysicalWriteBytesPerSecond) init() {
	m.data.SetName("newrelicoracledb.pdb.physical_write_bytes_per_second")
	m.data.SetDescription("Physical write total bytes per second in PDB")
	m.data.SetUnit("By/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbPhysicalWriteBytesPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbPhysicalWriteBytesPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbPhysicalWriteBytesPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbPhysicalWriteBytesPerSecond(cfg MetricConfig) metricNewrelicoracledbPdbPhysicalWriteBytesPerSecond {
	m := metricNewrelicoracledbPdbPhysicalWriteBytesPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbPhysicalWritesPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.physical_writes_per_transaction metric with initial data.
func (m *metricNewrelicoracledbPdbPhysicalWritesPerTransaction) init() {
	m.data.SetName("newrelicoracledb.pdb.physical_writes_per_transaction")
	m.data.SetDescription("Physical writes per transaction in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbPhysicalWritesPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbPhysicalWritesPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbPhysicalWritesPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbPhysicalWritesPerTransaction(cfg MetricConfig) metricNewrelicoracledbPdbPhysicalWritesPerTransaction {
	m := metricNewrelicoracledbPdbPhysicalWritesPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbRedoGeneratedBytesPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.redo_generated_bytes_per_second metric with initial data.
func (m *metricNewrelicoracledbPdbRedoGeneratedBytesPerSecond) init() {
	m.data.SetName("newrelicoracledb.pdb.redo_generated_bytes_per_second")
	m.data.SetDescription("Redo generated per second in bytes in PDB")
	m.data.SetUnit("By/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbRedoGeneratedBytesPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbRedoGeneratedBytesPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbRedoGeneratedBytesPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbRedoGeneratedBytesPerSecond(cfg MetricConfig) metricNewrelicoracledbPdbRedoGeneratedBytesPerSecond {
	m := metricNewrelicoracledbPdbRedoGeneratedBytesPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbRedoGeneratedBytesPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.redo_generated_bytes_per_transaction metric with initial data.
func (m *metricNewrelicoracledbPdbRedoGeneratedBytesPerTransaction) init() {
	m.data.SetName("newrelicoracledb.pdb.redo_generated_bytes_per_transaction")
	m.data.SetDescription("Redo generated per transaction in bytes in PDB")
	m.data.SetUnit("By/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbRedoGeneratedBytesPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbRedoGeneratedBytesPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbRedoGeneratedBytesPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbRedoGeneratedBytesPerTransaction(cfg MetricConfig) metricNewrelicoracledbPdbRedoGeneratedBytesPerTransaction {
	m := metricNewrelicoracledbPdbRedoGeneratedBytesPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbResponseTimePerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.response_time_per_transaction metric with initial data.
func (m *metricNewrelicoracledbPdbResponseTimePerTransaction) init() {
	m.data.SetName("newrelicoracledb.pdb.response_time_per_transaction")
	m.data.SetDescription("Response time per transaction in PDB")
	m.data.SetUnit("s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbResponseTimePerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbResponseTimePerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbResponseTimePerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbResponseTimePerTransaction(cfg MetricConfig) metricNewrelicoracledbPdbResponseTimePerTransaction {
	m := metricNewrelicoracledbPdbResponseTimePerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbSessionCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.session_count metric with initial data.
func (m *metricNewrelicoracledbPdbSessionCount) init() {
	m.data.SetName("newrelicoracledb.pdb.session_count")
	m.data.SetDescription("Session count in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbSessionCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbSessionCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbSessionCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbSessionCount(cfg MetricConfig) metricNewrelicoracledbPdbSessionCount {
	m := metricNewrelicoracledbPdbSessionCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbSoftParseRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.soft_parse_ratio metric with initial data.
func (m *metricNewrelicoracledbPdbSoftParseRatio) init() {
	m.data.SetName("newrelicoracledb.pdb.soft_parse_ratio")
	m.data.SetDescription("Soft parse ratio in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbSoftParseRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbSoftParseRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbSoftParseRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbSoftParseRatio(cfg MetricConfig) metricNewrelicoracledbPdbSoftParseRatio {
	m := metricNewrelicoracledbPdbSoftParseRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbSQLServiceResponseTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.sql_service_response_time metric with initial data.
func (m *metricNewrelicoracledbPdbSQLServiceResponseTime) init() {
	m.data.SetName("newrelicoracledb.pdb.sql_service_response_time")
	m.data.SetDescription("SQL service response time in PDB")
	m.data.SetUnit("s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbSQLServiceResponseTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbSQLServiceResponseTime) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbSQLServiceResponseTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbSQLServiceResponseTime(cfg MetricConfig) metricNewrelicoracledbPdbSQLServiceResponseTime {
	m := metricNewrelicoracledbPdbSQLServiceResponseTime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbStatus struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.status metric with initial data.
func (m *metricNewrelicoracledbPdbStatus) init() {
	m.data.SetName("newrelicoracledb.pdb.status")
	m.data.SetDescription("Oracle PDB status (1=NORMAL, 0=other)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbStatus) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, conIDAttributeValue string, pdbNameAttributeValue string, containerStatusAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("con.id", conIDAttributeValue)
	dp.Attributes().PutStr("pdb.name", pdbNameAttributeValue)
	dp.Attributes().PutStr("container.status", containerStatusAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbStatus) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbStatus) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbStatus(cfg MetricConfig) metricNewrelicoracledbPdbStatus {
	m := metricNewrelicoracledbPdbStatus{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbTotalParseCountPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.total_parse_count_per_second metric with initial data.
func (m *metricNewrelicoracledbPdbTotalParseCountPerSecond) init() {
	m.data.SetName("newrelicoracledb.pdb.total_parse_count_per_second")
	m.data.SetDescription("Total parse count per second in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbTotalParseCountPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbTotalParseCountPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbTotalParseCountPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbTotalParseCountPerSecond(cfg MetricConfig) metricNewrelicoracledbPdbTotalParseCountPerSecond {
	m := metricNewrelicoracledbPdbTotalParseCountPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbTotalParseCountPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.total_parse_count_per_transaction metric with initial data.
func (m *metricNewrelicoracledbPdbTotalParseCountPerTransaction) init() {
	m.data.SetName("newrelicoracledb.pdb.total_parse_count_per_transaction")
	m.data.SetDescription("Total parse count per transaction in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbTotalParseCountPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbTotalParseCountPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbTotalParseCountPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbTotalParseCountPerTransaction(cfg MetricConfig) metricNewrelicoracledbPdbTotalParseCountPerTransaction {
	m := metricNewrelicoracledbPdbTotalParseCountPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbTotalSizeBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.total_size_bytes metric with initial data.
func (m *metricNewrelicoracledbPdbTotalSizeBytes) init() {
	m.data.SetName("newrelicoracledb.pdb.total_size_bytes")
	m.data.SetDescription("Total size of PDB in bytes")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbTotalSizeBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, conIDAttributeValue string, pdbNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("con.id", conIDAttributeValue)
	dp.Attributes().PutStr("pdb.name", pdbNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbTotalSizeBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbTotalSizeBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbTotalSizeBytes(cfg MetricConfig) metricNewrelicoracledbPdbTotalSizeBytes {
	m := metricNewrelicoracledbPdbTotalSizeBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbTransactionsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.transactions_per_second metric with initial data.
func (m *metricNewrelicoracledbPdbTransactionsPerSecond) init() {
	m.data.SetName("newrelicoracledb.pdb.transactions_per_second")
	m.data.SetDescription("User transactions per second in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbTransactionsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbTransactionsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbTransactionsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbTransactionsPerSecond(cfg MetricConfig) metricNewrelicoracledbPdbTransactionsPerSecond {
	m := metricNewrelicoracledbPdbTransactionsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbUserCallsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.user_calls_per_second metric with initial data.
func (m *metricNewrelicoracledbPdbUserCallsPerSecond) init() {
	m.data.SetName("newrelicoracledb.pdb.user_calls_per_second")
	m.data.SetDescription("User calls per second in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbUserCallsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbUserCallsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbUserCallsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbUserCallsPerSecond(cfg MetricConfig) metricNewrelicoracledbPdbUserCallsPerSecond {
	m := metricNewrelicoracledbPdbUserCallsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbUserCallsPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.user_calls_per_transaction metric with initial data.
func (m *metricNewrelicoracledbPdbUserCallsPerTransaction) init() {
	m.data.SetName("newrelicoracledb.pdb.user_calls_per_transaction")
	m.data.SetDescription("User calls per transaction in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbUserCallsPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbUserCallsPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbUserCallsPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbUserCallsPerTransaction(cfg MetricConfig) metricNewrelicoracledbPdbUserCallsPerTransaction {
	m := metricNewrelicoracledbPdbUserCallsPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbUserCommitsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.user_commits_per_second metric with initial data.
func (m *metricNewrelicoracledbPdbUserCommitsPerSecond) init() {
	m.data.SetName("newrelicoracledb.pdb.user_commits_per_second")
	m.data.SetDescription("User commits per second in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbUserCommitsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbUserCommitsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbUserCommitsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbUserCommitsPerSecond(cfg MetricConfig) metricNewrelicoracledbPdbUserCommitsPerSecond {
	m := metricNewrelicoracledbPdbUserCommitsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbUserCommitsPercentage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.user_commits_percentage metric with initial data.
func (m *metricNewrelicoracledbPdbUserCommitsPercentage) init() {
	m.data.SetName("newrelicoracledb.pdb.user_commits_percentage")
	m.data.SetDescription("User commits percentage in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbUserCommitsPercentage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbUserCommitsPercentage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbUserCommitsPercentage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbUserCommitsPercentage(cfg MetricConfig) metricNewrelicoracledbPdbUserCommitsPercentage {
	m := metricNewrelicoracledbPdbUserCommitsPercentage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbUserRollbacksPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.user_rollbacks_per_second metric with initial data.
func (m *metricNewrelicoracledbPdbUserRollbacksPerSecond) init() {
	m.data.SetName("newrelicoracledb.pdb.user_rollbacks_per_second")
	m.data.SetDescription("User rollbacks per second in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbUserRollbacksPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbUserRollbacksPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbUserRollbacksPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbUserRollbacksPerSecond(cfg MetricConfig) metricNewrelicoracledbPdbUserRollbacksPerSecond {
	m := metricNewrelicoracledbPdbUserRollbacksPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbUserRollbacksPercentage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.user_rollbacks_percentage metric with initial data.
func (m *metricNewrelicoracledbPdbUserRollbacksPercentage) init() {
	m.data.SetName("newrelicoracledb.pdb.user_rollbacks_percentage")
	m.data.SetDescription("User rollbacks percentage in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbUserRollbacksPercentage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbUserRollbacksPercentage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbUserRollbacksPercentage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbUserRollbacksPercentage(cfg MetricConfig) metricNewrelicoracledbPdbUserRollbacksPercentage {
	m := metricNewrelicoracledbPdbUserRollbacksPercentage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbPdbWaitTimeRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.pdb.wait_time_ratio metric with initial data.
func (m *metricNewrelicoracledbPdbWaitTimeRatio) init() {
	m.data.SetName("newrelicoracledb.pdb.wait_time_ratio")
	m.data.SetDescription("Database wait time ratio in PDB")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbPdbWaitTimeRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbPdbWaitTimeRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbPdbWaitTimeRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbPdbWaitTimeRatio(cfg MetricConfig) metricNewrelicoracledbPdbWaitTimeRatio {
	m := metricNewrelicoracledbPdbWaitTimeRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbRacInstanceActiveState struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.rac.instance.active_state metric with initial data.
func (m *metricNewrelicoracledbRacInstanceActiveState) init() {
	m.data.SetName("newrelicoracledb.rac.instance.active_state")
	m.data.SetDescription("Instance active state indicator (1=NORMAL, 0=other)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbRacInstanceActiveState) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string, racInstanceNameAttributeValue string, hostNameRacAttributeValue string, activeStateAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
	dp.Attributes().PutStr("rac.instance.name", racInstanceNameAttributeValue)
	dp.Attributes().PutStr("host.name.rac", hostNameRacAttributeValue)
	dp.Attributes().PutStr("active.state", activeStateAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbRacInstanceActiveState) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbRacInstanceActiveState) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbRacInstanceActiveState(cfg MetricConfig) metricNewrelicoracledbRacInstanceActiveState {
	m := metricNewrelicoracledbRacInstanceActiveState{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbRacInstanceArchiverStarted struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.rac.instance.archiver_started metric with initial data.
func (m *metricNewrelicoracledbRacInstanceArchiverStarted) init() {
	m.data.SetName("newrelicoracledb.rac.instance.archiver_started")
	m.data.SetDescription("Archiver status indicator (1=STARTED, 0=STOPPED)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbRacInstanceArchiverStarted) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string, racInstanceNameAttributeValue string, hostNameRacAttributeValue string, archiverStatusAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
	dp.Attributes().PutStr("rac.instance.name", racInstanceNameAttributeValue)
	dp.Attributes().PutStr("host.name.rac", hostNameRacAttributeValue)
	dp.Attributes().PutStr("archiver.status", archiverStatusAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbRacInstanceArchiverStarted) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbRacInstanceArchiverStarted) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbRacInstanceArchiverStarted(cfg MetricConfig) metricNewrelicoracledbRacInstanceArchiverStarted {
	m := metricNewrelicoracledbRacInstanceArchiverStarted{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbRacInstanceDatabaseStatus struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.rac.instance.database_status metric with initial data.
func (m *metricNewrelicoracledbRacInstanceDatabaseStatus) init() {
	m.data.SetName("newrelicoracledb.rac.instance.database_status")
	m.data.SetDescription("Database status indicator (1=ACTIVE, 0=other)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbRacInstanceDatabaseStatus) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string, racInstanceNameAttributeValue string, hostNameRacAttributeValue string, databaseStatusAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
	dp.Attributes().PutStr("rac.instance.name", racInstanceNameAttributeValue)
	dp.Attributes().PutStr("host.name.rac", hostNameRacAttributeValue)
	dp.Attributes().PutStr("database.status", databaseStatusAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbRacInstanceDatabaseStatus) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbRacInstanceDatabaseStatus) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbRacInstanceDatabaseStatus(cfg MetricConfig) metricNewrelicoracledbRacInstanceDatabaseStatus {
	m := metricNewrelicoracledbRacInstanceDatabaseStatus{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbRacInstanceLoginsAllowed struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.rac.instance.logins_allowed metric with initial data.
func (m *metricNewrelicoracledbRacInstanceLoginsAllowed) init() {
	m.data.SetName("newrelicoracledb.rac.instance.logins_allowed")
	m.data.SetDescription("Instance login status indicator (1=ALLOWED, 0=RESTRICTED)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbRacInstanceLoginsAllowed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string, racInstanceNameAttributeValue string, hostNameRacAttributeValue string, loginsStatusAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
	dp.Attributes().PutStr("rac.instance.name", racInstanceNameAttributeValue)
	dp.Attributes().PutStr("host.name.rac", hostNameRacAttributeValue)
	dp.Attributes().PutStr("logins.status", loginsStatusAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbRacInstanceLoginsAllowed) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbRacInstanceLoginsAllowed) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbRacInstanceLoginsAllowed(cfg MetricConfig) metricNewrelicoracledbRacInstanceLoginsAllowed {
	m := metricNewrelicoracledbRacInstanceLoginsAllowed{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbRacInstanceStatus struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.rac.instance.status metric with initial data.
func (m *metricNewrelicoracledbRacInstanceStatus) init() {
	m.data.SetName("newrelicoracledb.rac.instance.status")
	m.data.SetDescription("RAC instance status (1=OPEN, 0=other)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbRacInstanceStatus) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string, racInstanceNameAttributeValue string, hostNameRacAttributeValue string, instanceStatusAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
	dp.Attributes().PutStr("rac.instance.name", racInstanceNameAttributeValue)
	dp.Attributes().PutStr("host.name.rac", hostNameRacAttributeValue)
	dp.Attributes().PutStr("instance.status", instanceStatusAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbRacInstanceStatus) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbRacInstanceStatus) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbRacInstanceStatus(cfg MetricConfig) metricNewrelicoracledbRacInstanceStatus {
	m := metricNewrelicoracledbRacInstanceStatus{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbRacInstanceUptimeSeconds struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.rac.instance.uptime_seconds metric with initial data.
func (m *metricNewrelicoracledbRacInstanceUptimeSeconds) init() {
	m.data.SetName("newrelicoracledb.rac.instance.uptime_seconds")
	m.data.SetDescription("Instance uptime in seconds since startup")
	m.data.SetUnit("s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbRacInstanceUptimeSeconds) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string, racInstanceNameAttributeValue string, hostNameRacAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
	dp.Attributes().PutStr("rac.instance.name", racInstanceNameAttributeValue)
	dp.Attributes().PutStr("host.name.rac", hostNameRacAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbRacInstanceUptimeSeconds) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbRacInstanceUptimeSeconds) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbRacInstanceUptimeSeconds(cfg MetricConfig) metricNewrelicoracledbRacInstanceUptimeSeconds {
	m := metricNewrelicoracledbRacInstanceUptimeSeconds{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbRacInstanceVersionInfo struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.rac.instance.version_info metric with initial data.
func (m *metricNewrelicoracledbRacInstanceVersionInfo) init() {
	m.data.SetName("newrelicoracledb.rac.instance.version_info")
	m.data.SetDescription("Oracle database version information (always 1, version in attributes)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbRacInstanceVersionInfo) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string, racInstanceNameAttributeValue string, hostNameRacAttributeValue string, oracleVersionAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
	dp.Attributes().PutStr("rac.instance.name", racInstanceNameAttributeValue)
	dp.Attributes().PutStr("host.name.rac", hostNameRacAttributeValue)
	dp.Attributes().PutStr("oracle.version", oracleVersionAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbRacInstanceVersionInfo) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbRacInstanceVersionInfo) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbRacInstanceVersionInfo(cfg MetricConfig) metricNewrelicoracledbRacInstanceVersionInfo {
	m := metricNewrelicoracledbRacInstanceVersionInfo{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbRacServiceClbConfig struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.rac.service.clb_config metric with initial data.
func (m *metricNewrelicoracledbRacServiceClbConfig) init() {
	m.data.SetName("newrelicoracledb.rac.service.clb_config")
	m.data.SetDescription("Connection load balancing configuration (always 1, config in attributes)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbRacServiceClbConfig) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, serviceNameAttributeValue string, instanceIDAttributeValue string, clbGoalAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("service.name", serviceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
	dp.Attributes().PutStr("clb.goal", clbGoalAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbRacServiceClbConfig) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbRacServiceClbConfig) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbRacServiceClbConfig(cfg MetricConfig) metricNewrelicoracledbRacServiceClbConfig {
	m := metricNewrelicoracledbRacServiceClbConfig{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbRacServiceCreationAgeDays struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.rac.service.creation_age_days metric with initial data.
func (m *metricNewrelicoracledbRacServiceCreationAgeDays) init() {
	m.data.SetName("newrelicoracledb.rac.service.creation_age_days")
	m.data.SetDescription("Service age in days since creation")
	m.data.SetUnit("d")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbRacServiceCreationAgeDays) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, serviceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("service.name", serviceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbRacServiceCreationAgeDays) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbRacServiceCreationAgeDays) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbRacServiceCreationAgeDays(cfg MetricConfig) metricNewrelicoracledbRacServiceCreationAgeDays {
	m := metricNewrelicoracledbRacServiceCreationAgeDays{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbRacServiceFailoverConfig struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.rac.service.failover_config metric with initial data.
func (m *metricNewrelicoracledbRacServiceFailoverConfig) init() {
	m.data.SetName("newrelicoracledb.rac.service.failover_config")
	m.data.SetDescription("Service failover configuration indicator (always 1, config in attributes)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbRacServiceFailoverConfig) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, serviceNameAttributeValue string, instanceIDAttributeValue string, failoverMethodAttributeValue string, failoverTypeAttributeValue string, serviceGoalAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("service.name", serviceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
	dp.Attributes().PutStr("failover.method", failoverMethodAttributeValue)
	dp.Attributes().PutStr("failover.type", failoverTypeAttributeValue)
	dp.Attributes().PutStr("service.goal", serviceGoalAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbRacServiceFailoverConfig) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbRacServiceFailoverConfig) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbRacServiceFailoverConfig(cfg MetricConfig) metricNewrelicoracledbRacServiceFailoverConfig {
	m := metricNewrelicoracledbRacServiceFailoverConfig{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbRacServiceFailoverDelaySeconds struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.rac.service.failover_delay_seconds metric with initial data.
func (m *metricNewrelicoracledbRacServiceFailoverDelaySeconds) init() {
	m.data.SetName("newrelicoracledb.rac.service.failover_delay_seconds")
	m.data.SetDescription("Failover delay in seconds configured for the service")
	m.data.SetUnit("s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbRacServiceFailoverDelaySeconds) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, serviceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("service.name", serviceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbRacServiceFailoverDelaySeconds) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbRacServiceFailoverDelaySeconds) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbRacServiceFailoverDelaySeconds(cfg MetricConfig) metricNewrelicoracledbRacServiceFailoverDelaySeconds {
	m := metricNewrelicoracledbRacServiceFailoverDelaySeconds{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbRacServiceFailoverRetries struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.rac.service.failover_retries metric with initial data.
func (m *metricNewrelicoracledbRacServiceFailoverRetries) init() {
	m.data.SetName("newrelicoracledb.rac.service.failover_retries")
	m.data.SetDescription("Number of failover retries configured for the service")
	m.data.SetUnit("{retries}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbRacServiceFailoverRetries) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, serviceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("service.name", serviceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbRacServiceFailoverRetries) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbRacServiceFailoverRetries) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbRacServiceFailoverRetries(cfg MetricConfig) metricNewrelicoracledbRacServiceFailoverRetries {
	m := metricNewrelicoracledbRacServiceFailoverRetries{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbRacServiceInstanceID struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.rac.service.instance_id metric with initial data.
func (m *metricNewrelicoracledbRacServiceInstanceID) init() {
	m.data.SetName("newrelicoracledb.rac.service.instance_id")
	m.data.SetDescription("Instance ID where the service is currently running")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbRacServiceInstanceID) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, serviceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("service.name", serviceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbRacServiceInstanceID) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbRacServiceInstanceID) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbRacServiceInstanceID(cfg MetricConfig) metricNewrelicoracledbRacServiceInstanceID {
	m := metricNewrelicoracledbRacServiceInstanceID{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbRacServiceNetworkConfig struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.rac.service.network_config metric with initial data.
func (m *metricNewrelicoracledbRacServiceNetworkConfig) init() {
	m.data.SetName("newrelicoracledb.rac.service.network_config")
	m.data.SetDescription("Service network configuration (always 1, config in attributes)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbRacServiceNetworkConfig) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, serviceNameAttributeValue string, instanceIDAttributeValue string, networkNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("service.name", serviceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
	dp.Attributes().PutStr("network.name", networkNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbRacServiceNetworkConfig) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbRacServiceNetworkConfig) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbRacServiceNetworkConfig(cfg MetricConfig) metricNewrelicoracledbRacServiceNetworkConfig {
	m := metricNewrelicoracledbRacServiceNetworkConfig{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbRacTotalWaits struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.rac.total_waits metric with initial data.
func (m *metricNewrelicoracledbRacTotalWaits) init() {
	m.data.SetName("newrelicoracledb.rac.total_waits")
	m.data.SetDescription("Total number of cluster wait events")
	m.data.SetUnit("{waits}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbRacTotalWaits) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string, waitEventAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
	dp.Attributes().PutStr("wait.event", waitEventAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbRacTotalWaits) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbRacTotalWaits) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbRacTotalWaits(cfg MetricConfig) metricNewrelicoracledbRacTotalWaits {
	m := metricNewrelicoracledbRacTotalWaits{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbRacWaitTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.rac.wait_time metric with initial data.
func (m *metricNewrelicoracledbRacWaitTime) init() {
	m.data.SetName("newrelicoracledb.rac.wait_time")
	m.data.SetDescription("Rate of cluster wait time in microseconds per second")
	m.data.SetUnit("us/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbRacWaitTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string, waitEventAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
	dp.Attributes().PutStr("wait.event", waitEventAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbRacWaitTime) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbRacWaitTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbRacWaitTime(cfg MetricConfig) metricNewrelicoracledbRacWaitTime {
	m := metricNewrelicoracledbRacWaitTime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbRedoLogParallelWriteWaits struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.redo_log_parallel_write_waits metric with initial data.
func (m *metricNewrelicoracledbRedoLogParallelWriteWaits) init() {
	m.data.SetName("newrelicoracledb.redo_log_parallel_write_waits")
	m.data.SetDescription("Number of waits for log file parallel write events")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbRedoLogParallelWriteWaits) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbRedoLogParallelWriteWaits) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbRedoLogParallelWriteWaits) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbRedoLogParallelWriteWaits(cfg MetricConfig) metricNewrelicoracledbRedoLogParallelWriteWaits {
	m := metricNewrelicoracledbRedoLogParallelWriteWaits{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbRedoLogSwitchArchivingNeededWaits struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.redo_log_switch_archiving_needed_waits metric with initial data.
func (m *metricNewrelicoracledbRedoLogSwitchArchivingNeededWaits) init() {
	m.data.SetName("newrelicoracledb.redo_log_switch_archiving_needed_waits")
	m.data.SetDescription("Number of waits for log file switch (archiving needed) events")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbRedoLogSwitchArchivingNeededWaits) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbRedoLogSwitchArchivingNeededWaits) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbRedoLogSwitchArchivingNeededWaits) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbRedoLogSwitchArchivingNeededWaits(cfg MetricConfig) metricNewrelicoracledbRedoLogSwitchArchivingNeededWaits {
	m := metricNewrelicoracledbRedoLogSwitchArchivingNeededWaits{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbRedoLogSwitchCheckpointIncompleteWaits struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.redo_log_switch_checkpoint_incomplete_waits metric with initial data.
func (m *metricNewrelicoracledbRedoLogSwitchCheckpointIncompleteWaits) init() {
	m.data.SetName("newrelicoracledb.redo_log_switch_checkpoint_incomplete_waits")
	m.data.SetDescription("Number of waits for log file switch (checkpoint incomplete) events")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbRedoLogSwitchCheckpointIncompleteWaits) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbRedoLogSwitchCheckpointIncompleteWaits) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbRedoLogSwitchCheckpointIncompleteWaits) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbRedoLogSwitchCheckpointIncompleteWaits(cfg MetricConfig) metricNewrelicoracledbRedoLogSwitchCheckpointIncompleteWaits {
	m := metricNewrelicoracledbRedoLogSwitchCheckpointIncompleteWaits{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbRedoLogSwitchCompletionWaits struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.redo_log_switch_completion_waits metric with initial data.
func (m *metricNewrelicoracledbRedoLogSwitchCompletionWaits) init() {
	m.data.SetName("newrelicoracledb.redo_log_switch_completion_waits")
	m.data.SetDescription("Number of waits for log file switch completion events")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbRedoLogSwitchCompletionWaits) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbRedoLogSwitchCompletionWaits) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbRedoLogSwitchCompletionWaits) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbRedoLogSwitchCompletionWaits(cfg MetricConfig) metricNewrelicoracledbRedoLogSwitchCompletionWaits {
	m := metricNewrelicoracledbRedoLogSwitchCompletionWaits{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbRollbackSegmentsGets struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.rollback_segments_gets metric with initial data.
func (m *metricNewrelicoracledbRollbackSegmentsGets) init() {
	m.data.SetName("newrelicoracledb.rollback_segments_gets")
	m.data.SetDescription("Number of gets on rollback segments")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbRollbackSegmentsGets) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbRollbackSegmentsGets) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbRollbackSegmentsGets) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbRollbackSegmentsGets(cfg MetricConfig) metricNewrelicoracledbRollbackSegmentsGets {
	m := metricNewrelicoracledbRollbackSegmentsGets{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbRollbackSegmentsWaitRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.rollback_segments_wait_ratio metric with initial data.
func (m *metricNewrelicoracledbRollbackSegmentsWaitRatio) init() {
	m.data.SetName("newrelicoracledb.rollback_segments_wait_ratio")
	m.data.SetDescription("Rollback segments wait ratio (waits/gets)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbRollbackSegmentsWaitRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbRollbackSegmentsWaitRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbRollbackSegmentsWaitRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbRollbackSegmentsWaitRatio(cfg MetricConfig) metricNewrelicoracledbRollbackSegmentsWaitRatio {
	m := metricNewrelicoracledbRollbackSegmentsWaitRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbRollbackSegmentsWaits struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.rollback_segments_waits metric with initial data.
func (m *metricNewrelicoracledbRollbackSegmentsWaits) init() {
	m.data.SetName("newrelicoracledb.rollback_segments_waits")
	m.data.SetDescription("Number of waits on rollback segments")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbRollbackSegmentsWaits) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbRollbackSegmentsWaits) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbRollbackSegmentsWaits) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbRollbackSegmentsWaits(cfg MetricConfig) metricNewrelicoracledbRollbackSegmentsWaits {
	m := metricNewrelicoracledbRollbackSegmentsWaits{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbServiceCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.service.count metric with initial data.
func (m *metricNewrelicoracledbServiceCount) init() {
	m.data.SetName("newrelicoracledb.service.count")
	m.data.SetDescription("Count of services per container")
	m.data.SetUnit("{services}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbServiceCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, conIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("con.id", conIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbServiceCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbServiceCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbServiceCount(cfg MetricConfig) metricNewrelicoracledbServiceCount {
	m := metricNewrelicoracledbServiceCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbServiceStatus struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.service.status metric with initial data.
func (m *metricNewrelicoracledbServiceStatus) init() {
	m.data.SetName("newrelicoracledb.service.status")
	m.data.SetDescription("Oracle service status (1=active, 0=inactive)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbServiceStatus) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, conIDAttributeValue string, serviceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("con.id", conIDAttributeValue)
	dp.Attributes().PutStr("service.name", serviceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbServiceStatus) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbServiceStatus) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbServiceStatus(cfg MetricConfig) metricNewrelicoracledbServiceStatus {
	m := metricNewrelicoracledbServiceStatus{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSessionsCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.sessions.count metric with initial data.
func (m *metricNewrelicoracledbSessionsCount) init() {
	m.data.SetName("newrelicoracledb.sessions.count")
	m.data.SetDescription("Total number of active Oracle database sessions")
	m.data.SetUnit("{sessions}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSessionsCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSessionsCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSessionsCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSessionsCount(cfg MetricConfig) metricNewrelicoracledbSessionsCount {
	m := metricNewrelicoracledbSessionsCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSgaBufferBusyWaits struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.sga_buffer_busy_waits metric with initial data.
func (m *metricNewrelicoracledbSgaBufferBusyWaits) init() {
	m.data.SetName("newrelicoracledb.sga_buffer_busy_waits")
	m.data.SetDescription("Number of buffer busy waits events")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSgaBufferBusyWaits) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSgaBufferBusyWaits) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSgaBufferBusyWaits) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSgaBufferBusyWaits(cfg MetricConfig) metricNewrelicoracledbSgaBufferBusyWaits {
	m := metricNewrelicoracledbSgaBufferBusyWaits{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSgaFixedSizeBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.sga_fixed_size_bytes metric with initial data.
func (m *metricNewrelicoracledbSgaFixedSizeBytes) init() {
	m.data.SetName("newrelicoracledb.sga_fixed_size_bytes")
	m.data.SetDescription("SGA fixed size memory in bytes")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSgaFixedSizeBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSgaFixedSizeBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSgaFixedSizeBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSgaFixedSizeBytes(cfg MetricConfig) metricNewrelicoracledbSgaFixedSizeBytes {
	m := metricNewrelicoracledbSgaFixedSizeBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSgaFreeBufferInspectedWaits struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.sga_free_buffer_inspected_waits metric with initial data.
func (m *metricNewrelicoracledbSgaFreeBufferInspectedWaits) init() {
	m.data.SetName("newrelicoracledb.sga_free_buffer_inspected_waits")
	m.data.SetDescription("Number of free buffer inspected waits events")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSgaFreeBufferInspectedWaits) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSgaFreeBufferInspectedWaits) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSgaFreeBufferInspectedWaits) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSgaFreeBufferInspectedWaits(cfg MetricConfig) metricNewrelicoracledbSgaFreeBufferInspectedWaits {
	m := metricNewrelicoracledbSgaFreeBufferInspectedWaits{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSgaFreeBufferWaits struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.sga_free_buffer_waits metric with initial data.
func (m *metricNewrelicoracledbSgaFreeBufferWaits) init() {
	m.data.SetName("newrelicoracledb.sga_free_buffer_waits")
	m.data.SetDescription("Number of free buffer waits events")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSgaFreeBufferWaits) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSgaFreeBufferWaits) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSgaFreeBufferWaits) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSgaFreeBufferWaits(cfg MetricConfig) metricNewrelicoracledbSgaFreeBufferWaits {
	m := metricNewrelicoracledbSgaFreeBufferWaits{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSgaHitRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.sga_hit_ratio metric with initial data.
func (m *metricNewrelicoracledbSgaHitRatio) init() {
	m.data.SetName("newrelicoracledb.sga_hit_ratio")
	m.data.SetDescription("SGA hit ratio (session logical reads minus physical reads / session logical reads)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSgaHitRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSgaHitRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSgaHitRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSgaHitRatio(cfg MetricConfig) metricNewrelicoracledbSgaHitRatio {
	m := metricNewrelicoracledbSgaHitRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSgaLogAllocationRetriesRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.sga_log_allocation_retries_ratio metric with initial data.
func (m *metricNewrelicoracledbSgaLogAllocationRetriesRatio) init() {
	m.data.SetName("newrelicoracledb.sga_log_allocation_retries_ratio")
	m.data.SetDescription("SGA log allocation retries ratio (redo buffer allocation retries / redo entries)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSgaLogAllocationRetriesRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSgaLogAllocationRetriesRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSgaLogAllocationRetriesRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSgaLogAllocationRetriesRatio(cfg MetricConfig) metricNewrelicoracledbSgaLogAllocationRetriesRatio {
	m := metricNewrelicoracledbSgaLogAllocationRetriesRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSgaLogBufferRedoAllocationRetries struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.sga_log_buffer_redo_allocation_retries metric with initial data.
func (m *metricNewrelicoracledbSgaLogBufferRedoAllocationRetries) init() {
	m.data.SetName("newrelicoracledb.sga_log_buffer_redo_allocation_retries")
	m.data.SetDescription("Number of redo buffer allocation retries from sysstat")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSgaLogBufferRedoAllocationRetries) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSgaLogBufferRedoAllocationRetries) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSgaLogBufferRedoAllocationRetries) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSgaLogBufferRedoAllocationRetries(cfg MetricConfig) metricNewrelicoracledbSgaLogBufferRedoAllocationRetries {
	m := metricNewrelicoracledbSgaLogBufferRedoAllocationRetries{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSgaLogBufferRedoEntries struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.sga_log_buffer_redo_entries metric with initial data.
func (m *metricNewrelicoracledbSgaLogBufferRedoEntries) init() {
	m.data.SetName("newrelicoracledb.sga_log_buffer_redo_entries")
	m.data.SetDescription("Number of redo entries from sysstat")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSgaLogBufferRedoEntries) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSgaLogBufferRedoEntries) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSgaLogBufferRedoEntries) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSgaLogBufferRedoEntries(cfg MetricConfig) metricNewrelicoracledbSgaLogBufferRedoEntries {
	m := metricNewrelicoracledbSgaLogBufferRedoEntries{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSgaLogBufferSpaceWaits struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.sga_log_buffer_space_waits metric with initial data.
func (m *metricNewrelicoracledbSgaLogBufferSpaceWaits) init() {
	m.data.SetName("newrelicoracledb.sga_log_buffer_space_waits")
	m.data.SetDescription("Number of sessions waiting for log buffer space")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSgaLogBufferSpaceWaits) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSgaLogBufferSpaceWaits) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSgaLogBufferSpaceWaits) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSgaLogBufferSpaceWaits(cfg MetricConfig) metricNewrelicoracledbSgaLogBufferSpaceWaits {
	m := metricNewrelicoracledbSgaLogBufferSpaceWaits{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSgaRedoBuffersBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.sga_redo_buffers_bytes metric with initial data.
func (m *metricNewrelicoracledbSgaRedoBuffersBytes) init() {
	m.data.SetName("newrelicoracledb.sga_redo_buffers_bytes")
	m.data.SetDescription("SGA redo buffers memory in bytes")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSgaRedoBuffersBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSgaRedoBuffersBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSgaRedoBuffersBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSgaRedoBuffersBytes(cfg MetricConfig) metricNewrelicoracledbSgaRedoBuffersBytes {
	m := metricNewrelicoracledbSgaRedoBuffersBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSgaSharedPoolDictCacheMissRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.sga_shared_pool_dict_cache_miss_ratio metric with initial data.
func (m *metricNewrelicoracledbSgaSharedPoolDictCacheMissRatio) init() {
	m.data.SetName("newrelicoracledb.sga_shared_pool_dict_cache_miss_ratio")
	m.data.SetDescription("SGA shared pool dictionary cache miss ratio (getmisses/gets)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSgaSharedPoolDictCacheMissRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSgaSharedPoolDictCacheMissRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSgaSharedPoolDictCacheMissRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSgaSharedPoolDictCacheMissRatio(cfg MetricConfig) metricNewrelicoracledbSgaSharedPoolDictCacheMissRatio {
	m := metricNewrelicoracledbSgaSharedPoolDictCacheMissRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSgaSharedPoolLibraryCacheHitRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.sga_shared_pool_library_cache_hit_ratio metric with initial data.
func (m *metricNewrelicoracledbSgaSharedPoolLibraryCacheHitRatio) init() {
	m.data.SetName("newrelicoracledb.sga_shared_pool_library_cache_hit_ratio")
	m.data.SetDescription("SGA shared pool library cache hit ratio for SQL AREA namespace")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSgaSharedPoolLibraryCacheHitRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSgaSharedPoolLibraryCacheHitRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSgaSharedPoolLibraryCacheHitRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSgaSharedPoolLibraryCacheHitRatio(cfg MetricConfig) metricNewrelicoracledbSgaSharedPoolLibraryCacheHitRatio {
	m := metricNewrelicoracledbSgaSharedPoolLibraryCacheHitRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSgaSharedPoolLibraryCacheReloadRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.sga_shared_pool_library_cache_reload_ratio metric with initial data.
func (m *metricNewrelicoracledbSgaSharedPoolLibraryCacheReloadRatio) init() {
	m.data.SetName("newrelicoracledb.sga_shared_pool_library_cache_reload_ratio")
	m.data.SetDescription("SGA shared pool library cache reload ratio (reloads/pins)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSgaSharedPoolLibraryCacheReloadRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSgaSharedPoolLibraryCacheReloadRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSgaSharedPoolLibraryCacheReloadRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSgaSharedPoolLibraryCacheReloadRatio(cfg MetricConfig) metricNewrelicoracledbSgaSharedPoolLibraryCacheReloadRatio {
	m := metricNewrelicoracledbSgaSharedPoolLibraryCacheReloadRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSortsDisk struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.sorts_disk metric with initial data.
func (m *metricNewrelicoracledbSortsDisk) init() {
	m.data.SetName("newrelicoracledb.sorts_disk")
	m.data.SetDescription("Number of sorts performed on disk from sysstat")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSortsDisk) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSortsDisk) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSortsDisk) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSortsDisk(cfg MetricConfig) metricNewrelicoracledbSortsDisk {
	m := metricNewrelicoracledbSortsDisk{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSortsMemory struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.sorts_memory metric with initial data.
func (m *metricNewrelicoracledbSortsMemory) init() {
	m.data.SetName("newrelicoracledb.sorts_memory")
	m.data.SetDescription("Number of sorts performed in memory from sysstat")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSortsMemory) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSortsMemory) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSortsMemory) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSortsMemory(cfg MetricConfig) metricNewrelicoracledbSortsMemory {
	m := metricNewrelicoracledbSortsMemory{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemActiveParallelSessions struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.active_parallel_sessions metric with initial data.
func (m *metricNewrelicoracledbSystemActiveParallelSessions) init() {
	m.data.SetName("newrelicoracledb.system.active_parallel_sessions")
	m.data.SetDescription("Active Parallel Sessions")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemActiveParallelSessions) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemActiveParallelSessions) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemActiveParallelSessions) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemActiveParallelSessions(cfg MetricConfig) metricNewrelicoracledbSystemActiveParallelSessions {
	m := metricNewrelicoracledbSystemActiveParallelSessions{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemActiveSerialSessions struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.active_serial_sessions metric with initial data.
func (m *metricNewrelicoracledbSystemActiveSerialSessions) init() {
	m.data.SetName("newrelicoracledb.system.active_serial_sessions")
	m.data.SetDescription("Active Serial Sessions")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemActiveSerialSessions) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemActiveSerialSessions) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemActiveSerialSessions) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemActiveSerialSessions(cfg MetricConfig) metricNewrelicoracledbSystemActiveSerialSessions {
	m := metricNewrelicoracledbSystemActiveSerialSessions{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemAverageActiveSessions struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.average_active_sessions metric with initial data.
func (m *metricNewrelicoracledbSystemAverageActiveSessions) init() {
	m.data.SetName("newrelicoracledb.system.average_active_sessions")
	m.data.SetDescription("Average Active Sessions")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemAverageActiveSessions) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemAverageActiveSessions) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemAverageActiveSessions) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemAverageActiveSessions(cfg MetricConfig) metricNewrelicoracledbSystemAverageActiveSessions {
	m := metricNewrelicoracledbSystemAverageActiveSessions{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemBackgroundCheckpointsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.background_checkpoints_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemBackgroundCheckpointsPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.background_checkpoints_per_second")
	m.data.SetDescription("Background Checkpoints Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemBackgroundCheckpointsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemBackgroundCheckpointsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemBackgroundCheckpointsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemBackgroundCheckpointsPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemBackgroundCheckpointsPerSecond {
	m := metricNewrelicoracledbSystemBackgroundCheckpointsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemBackgroundCPUUsagePerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.background_cpu_usage_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemBackgroundCPUUsagePerSecond) init() {
	m.data.SetName("newrelicoracledb.system.background_cpu_usage_per_second")
	m.data.SetDescription("Background CPU Usage Per Sec")
	m.data.SetUnit("s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemBackgroundCPUUsagePerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemBackgroundCPUUsagePerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemBackgroundCPUUsagePerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemBackgroundCPUUsagePerSecond(cfg MetricConfig) metricNewrelicoracledbSystemBackgroundCPUUsagePerSecond {
	m := metricNewrelicoracledbSystemBackgroundCPUUsagePerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemBackgroundTimePerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.background_time_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemBackgroundTimePerSecond) init() {
	m.data.SetName("newrelicoracledb.system.background_time_per_second")
	m.data.SetDescription("Background Time Per Sec")
	m.data.SetUnit("s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemBackgroundTimePerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemBackgroundTimePerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemBackgroundTimePerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemBackgroundTimePerSecond(cfg MetricConfig) metricNewrelicoracledbSystemBackgroundTimePerSecond {
	m := metricNewrelicoracledbSystemBackgroundTimePerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemBranchNodeSplitsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.branch_node_splits_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemBranchNodeSplitsPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.branch_node_splits_per_second")
	m.data.SetDescription("Branch Node Splits Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemBranchNodeSplitsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemBranchNodeSplitsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemBranchNodeSplitsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemBranchNodeSplitsPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemBranchNodeSplitsPerSecond {
	m := metricNewrelicoracledbSystemBranchNodeSplitsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemBranchNodeSplitsPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.branch_node_splits_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemBranchNodeSplitsPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.branch_node_splits_per_transaction")
	m.data.SetDescription("Branch Node Splits Per Txn")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemBranchNodeSplitsPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemBranchNodeSplitsPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemBranchNodeSplitsPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemBranchNodeSplitsPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemBranchNodeSplitsPerTransaction {
	m := metricNewrelicoracledbSystemBranchNodeSplitsPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemBufferCacheHitRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.buffer_cache_hit_ratio metric with initial data.
func (m *metricNewrelicoracledbSystemBufferCacheHitRatio) init() {
	m.data.SetName("newrelicoracledb.system.buffer_cache_hit_ratio")
	m.data.SetDescription("Buffer Cache Hit Ratio")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemBufferCacheHitRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemBufferCacheHitRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemBufferCacheHitRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemBufferCacheHitRatio(cfg MetricConfig) metricNewrelicoracledbSystemBufferCacheHitRatio {
	m := metricNewrelicoracledbSystemBufferCacheHitRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemCapturedUserCalls struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.captured_user_calls metric with initial data.
func (m *metricNewrelicoracledbSystemCapturedUserCalls) init() {
	m.data.SetName("newrelicoracledb.system.captured_user_calls")
	m.data.SetDescription("Captured user calls")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemCapturedUserCalls) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemCapturedUserCalls) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemCapturedUserCalls) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemCapturedUserCalls(cfg MetricConfig) metricNewrelicoracledbSystemCapturedUserCalls {
	m := metricNewrelicoracledbSystemCapturedUserCalls{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemConsistentReadChangesPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.consistent_read_changes_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemConsistentReadChangesPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.consistent_read_changes_per_second")
	m.data.SetDescription("Consistent Read Changes Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemConsistentReadChangesPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemConsistentReadChangesPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemConsistentReadChangesPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemConsistentReadChangesPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemConsistentReadChangesPerSecond {
	m := metricNewrelicoracledbSystemConsistentReadChangesPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemConsistentReadChangesPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.consistent_read_changes_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemConsistentReadChangesPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.consistent_read_changes_per_transaction")
	m.data.SetDescription("Consistent Read Changes Per Txn")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemConsistentReadChangesPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemConsistentReadChangesPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemConsistentReadChangesPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemConsistentReadChangesPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemConsistentReadChangesPerTransaction {
	m := metricNewrelicoracledbSystemConsistentReadChangesPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemConsistentReadGetsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.consistent_read_gets_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemConsistentReadGetsPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.consistent_read_gets_per_second")
	m.data.SetDescription("Consistent Read Gets Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemConsistentReadGetsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemConsistentReadGetsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemConsistentReadGetsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemConsistentReadGetsPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemConsistentReadGetsPerSecond {
	m := metricNewrelicoracledbSystemConsistentReadGetsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemConsistentReadGetsPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.consistent_read_gets_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemConsistentReadGetsPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.consistent_read_gets_per_transaction")
	m.data.SetDescription("Consistent Read Gets Per Txn")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemConsistentReadGetsPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemConsistentReadGetsPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemConsistentReadGetsPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemConsistentReadGetsPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemConsistentReadGetsPerTransaction {
	m := metricNewrelicoracledbSystemConsistentReadGetsPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemCPUUsagePerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.cpu_usage_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemCPUUsagePerSecond) init() {
	m.data.SetName("newrelicoracledb.system.cpu_usage_per_second")
	m.data.SetDescription("CPU Usage Per Sec")
	m.data.SetUnit("s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemCPUUsagePerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemCPUUsagePerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemCPUUsagePerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemCPUUsagePerSecond(cfg MetricConfig) metricNewrelicoracledbSystemCPUUsagePerSecond {
	m := metricNewrelicoracledbSystemCPUUsagePerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemCPUUsagePerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.cpu_usage_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemCPUUsagePerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.cpu_usage_per_transaction")
	m.data.SetDescription("CPU Usage Per Txn")
	m.data.SetUnit("s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemCPUUsagePerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemCPUUsagePerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemCPUUsagePerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemCPUUsagePerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemCPUUsagePerTransaction {
	m := metricNewrelicoracledbSystemCPUUsagePerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemCrBlocksCreatedPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.cr_blocks_created_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemCrBlocksCreatedPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.cr_blocks_created_per_second")
	m.data.SetDescription("CR Blocks Created Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemCrBlocksCreatedPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemCrBlocksCreatedPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemCrBlocksCreatedPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemCrBlocksCreatedPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemCrBlocksCreatedPerSecond {
	m := metricNewrelicoracledbSystemCrBlocksCreatedPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemCrBlocksCreatedPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.cr_blocks_created_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemCrBlocksCreatedPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.cr_blocks_created_per_transaction")
	m.data.SetDescription("CR Blocks Created Per Txn")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemCrBlocksCreatedPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemCrBlocksCreatedPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemCrBlocksCreatedPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemCrBlocksCreatedPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemCrBlocksCreatedPerTransaction {
	m := metricNewrelicoracledbSystemCrBlocksCreatedPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemCrUndoRecordsAppliedPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.cr_undo_records_applied_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemCrUndoRecordsAppliedPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.cr_undo_records_applied_per_second")
	m.data.SetDescription("CR Undo Records Applied Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemCrUndoRecordsAppliedPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemCrUndoRecordsAppliedPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemCrUndoRecordsAppliedPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemCrUndoRecordsAppliedPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemCrUndoRecordsAppliedPerSecond {
	m := metricNewrelicoracledbSystemCrUndoRecordsAppliedPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemCrUndoRecordsAppliedPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.cr_undo_records_applied_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemCrUndoRecordsAppliedPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.cr_undo_records_applied_per_transaction")
	m.data.SetDescription("CR Undo Records Applied Per Txn")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemCrUndoRecordsAppliedPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemCrUndoRecordsAppliedPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemCrUndoRecordsAppliedPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemCrUndoRecordsAppliedPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemCrUndoRecordsAppliedPerTransaction {
	m := metricNewrelicoracledbSystemCrUndoRecordsAppliedPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemCurrentLogonsCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.current_logons_count metric with initial data.
func (m *metricNewrelicoracledbSystemCurrentLogonsCount) init() {
	m.data.SetName("newrelicoracledb.system.current_logons_count")
	m.data.SetDescription("Current Logons Count")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemCurrentLogonsCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemCurrentLogonsCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemCurrentLogonsCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemCurrentLogonsCount(cfg MetricConfig) metricNewrelicoracledbSystemCurrentLogonsCount {
	m := metricNewrelicoracledbSystemCurrentLogonsCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemCurrentOpenCursorsCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.current_open_cursors_count metric with initial data.
func (m *metricNewrelicoracledbSystemCurrentOpenCursorsCount) init() {
	m.data.SetName("newrelicoracledb.system.current_open_cursors_count")
	m.data.SetDescription("Current Open Cursors Count")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemCurrentOpenCursorsCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemCurrentOpenCursorsCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemCurrentOpenCursorsCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemCurrentOpenCursorsCount(cfg MetricConfig) metricNewrelicoracledbSystemCurrentOpenCursorsCount {
	m := metricNewrelicoracledbSystemCurrentOpenCursorsCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemCurrentOsLoad struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.current_os_load metric with initial data.
func (m *metricNewrelicoracledbSystemCurrentOsLoad) init() {
	m.data.SetName("newrelicoracledb.system.current_os_load")
	m.data.SetDescription("Current OS Load")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemCurrentOsLoad) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemCurrentOsLoad) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemCurrentOsLoad) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemCurrentOsLoad(cfg MetricConfig) metricNewrelicoracledbSystemCurrentOsLoad {
	m := metricNewrelicoracledbSystemCurrentOsLoad{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemCursorCacheHitRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.cursor_cache_hit_ratio metric with initial data.
func (m *metricNewrelicoracledbSystemCursorCacheHitRatio) init() {
	m.data.SetName("newrelicoracledb.system.cursor_cache_hit_ratio")
	m.data.SetDescription("Cursor Cache Hit Ratio")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemCursorCacheHitRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemCursorCacheHitRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemCursorCacheHitRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemCursorCacheHitRatio(cfg MetricConfig) metricNewrelicoracledbSystemCursorCacheHitRatio {
	m := metricNewrelicoracledbSystemCursorCacheHitRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemDatabaseCPUTimeRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.database_cpu_time_ratio metric with initial data.
func (m *metricNewrelicoracledbSystemDatabaseCPUTimeRatio) init() {
	m.data.SetName("newrelicoracledb.system.database_cpu_time_ratio")
	m.data.SetDescription("Database CPU Time Ratio")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemDatabaseCPUTimeRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemDatabaseCPUTimeRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemDatabaseCPUTimeRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemDatabaseCPUTimeRatio(cfg MetricConfig) metricNewrelicoracledbSystemDatabaseCPUTimeRatio {
	m := metricNewrelicoracledbSystemDatabaseCPUTimeRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemDatabaseTimePerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.database_time_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemDatabaseTimePerSecond) init() {
	m.data.SetName("newrelicoracledb.system.database_time_per_second")
	m.data.SetDescription("Database Time Per Sec")
	m.data.SetUnit("s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemDatabaseTimePerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemDatabaseTimePerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemDatabaseTimePerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemDatabaseTimePerSecond(cfg MetricConfig) metricNewrelicoracledbSystemDatabaseTimePerSecond {
	m := metricNewrelicoracledbSystemDatabaseTimePerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemDatabaseWaitTimeRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.database_wait_time_ratio metric with initial data.
func (m *metricNewrelicoracledbSystemDatabaseWaitTimeRatio) init() {
	m.data.SetName("newrelicoracledb.system.database_wait_time_ratio")
	m.data.SetDescription("Database Wait Time Ratio")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemDatabaseWaitTimeRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemDatabaseWaitTimeRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemDatabaseWaitTimeRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemDatabaseWaitTimeRatio(cfg MetricConfig) metricNewrelicoracledbSystemDatabaseWaitTimeRatio {
	m := metricNewrelicoracledbSystemDatabaseWaitTimeRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemDbBlockChangesPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.db_block_changes_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemDbBlockChangesPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.db_block_changes_per_second")
	m.data.SetDescription("DB Block Changes Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemDbBlockChangesPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemDbBlockChangesPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemDbBlockChangesPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemDbBlockChangesPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemDbBlockChangesPerSecond {
	m := metricNewrelicoracledbSystemDbBlockChangesPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemDbBlockChangesPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.db_block_changes_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemDbBlockChangesPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.db_block_changes_per_transaction")
	m.data.SetDescription("DB Block Changes Per Txn")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemDbBlockChangesPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemDbBlockChangesPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemDbBlockChangesPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemDbBlockChangesPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemDbBlockChangesPerTransaction {
	m := metricNewrelicoracledbSystemDbBlockChangesPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemDbBlockChangesPerUserCall struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.db_block_changes_per_user_call metric with initial data.
func (m *metricNewrelicoracledbSystemDbBlockChangesPerUserCall) init() {
	m.data.SetName("newrelicoracledb.system.db_block_changes_per_user_call")
	m.data.SetDescription("DB Block Changes Per User Call")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemDbBlockChangesPerUserCall) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemDbBlockChangesPerUserCall) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemDbBlockChangesPerUserCall) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemDbBlockChangesPerUserCall(cfg MetricConfig) metricNewrelicoracledbSystemDbBlockChangesPerUserCall {
	m := metricNewrelicoracledbSystemDbBlockChangesPerUserCall{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemDbBlockGetsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.db_block_gets_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemDbBlockGetsPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.db_block_gets_per_second")
	m.data.SetDescription("DB Block Gets Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemDbBlockGetsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemDbBlockGetsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemDbBlockGetsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemDbBlockGetsPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemDbBlockGetsPerSecond {
	m := metricNewrelicoracledbSystemDbBlockGetsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemDbBlockGetsPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.db_block_gets_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemDbBlockGetsPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.db_block_gets_per_transaction")
	m.data.SetDescription("DB Block Gets Per Txn")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemDbBlockGetsPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemDbBlockGetsPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemDbBlockGetsPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemDbBlockGetsPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemDbBlockGetsPerTransaction {
	m := metricNewrelicoracledbSystemDbBlockGetsPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemDbBlockGetsPerUserCall struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.db_block_gets_per_user_call metric with initial data.
func (m *metricNewrelicoracledbSystemDbBlockGetsPerUserCall) init() {
	m.data.SetName("newrelicoracledb.system.db_block_gets_per_user_call")
	m.data.SetDescription("DB Block Gets Per User Call")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemDbBlockGetsPerUserCall) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemDbBlockGetsPerUserCall) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemDbBlockGetsPerUserCall) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemDbBlockGetsPerUserCall(cfg MetricConfig) metricNewrelicoracledbSystemDbBlockGetsPerUserCall {
	m := metricNewrelicoracledbSystemDbBlockGetsPerUserCall{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemDbwrCheckpointsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.dbwr_checkpoints_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemDbwrCheckpointsPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.dbwr_checkpoints_per_second")
	m.data.SetDescription("DBWR Checkpoints Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemDbwrCheckpointsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemDbwrCheckpointsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemDbwrCheckpointsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemDbwrCheckpointsPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemDbwrCheckpointsPerSecond {
	m := metricNewrelicoracledbSystemDbwrCheckpointsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemDiskSortPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.disk_sort_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemDiskSortPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.disk_sort_per_second")
	m.data.SetDescription("Disk Sort Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemDiskSortPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemDiskSortPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemDiskSortPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemDiskSortPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemDiskSortPerSecond {
	m := metricNewrelicoracledbSystemDiskSortPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemDiskSortPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.disk_sort_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemDiskSortPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.disk_sort_per_transaction")
	m.data.SetDescription("Disk Sort Per Txn")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemDiskSortPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemDiskSortPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemDiskSortPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemDiskSortPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemDiskSortPerTransaction {
	m := metricNewrelicoracledbSystemDiskSortPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemEnqueueDeadlocksPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.enqueue_deadlocks_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemEnqueueDeadlocksPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.enqueue_deadlocks_per_second")
	m.data.SetDescription("Enqueue Deadlocks Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemEnqueueDeadlocksPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemEnqueueDeadlocksPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemEnqueueDeadlocksPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemEnqueueDeadlocksPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemEnqueueDeadlocksPerSecond {
	m := metricNewrelicoracledbSystemEnqueueDeadlocksPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemEnqueueDeadlocksPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.enqueue_deadlocks_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemEnqueueDeadlocksPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.enqueue_deadlocks_per_transaction")
	m.data.SetDescription("Enqueue Deadlocks Per Txn")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemEnqueueDeadlocksPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemEnqueueDeadlocksPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemEnqueueDeadlocksPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemEnqueueDeadlocksPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemEnqueueDeadlocksPerTransaction {
	m := metricNewrelicoracledbSystemEnqueueDeadlocksPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemEnqueueRequestsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.enqueue_requests_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemEnqueueRequestsPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.enqueue_requests_per_second")
	m.data.SetDescription("Enqueue Requests Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemEnqueueRequestsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemEnqueueRequestsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemEnqueueRequestsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemEnqueueRequestsPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemEnqueueRequestsPerSecond {
	m := metricNewrelicoracledbSystemEnqueueRequestsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemEnqueueRequestsPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.enqueue_requests_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemEnqueueRequestsPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.enqueue_requests_per_transaction")
	m.data.SetDescription("Enqueue Requests Per Txn")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemEnqueueRequestsPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemEnqueueRequestsPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemEnqueueRequestsPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemEnqueueRequestsPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemEnqueueRequestsPerTransaction {
	m := metricNewrelicoracledbSystemEnqueueRequestsPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemEnqueueTimeoutsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.enqueue_timeouts_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemEnqueueTimeoutsPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.enqueue_timeouts_per_second")
	m.data.SetDescription("Enqueue Timeouts Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemEnqueueTimeoutsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemEnqueueTimeoutsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemEnqueueTimeoutsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemEnqueueTimeoutsPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemEnqueueTimeoutsPerSecond {
	m := metricNewrelicoracledbSystemEnqueueTimeoutsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemEnqueueTimeoutsPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.enqueue_timeouts_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemEnqueueTimeoutsPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.enqueue_timeouts_per_transaction")
	m.data.SetDescription("Enqueue Timeouts Per Txn")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemEnqueueTimeoutsPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemEnqueueTimeoutsPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemEnqueueTimeoutsPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemEnqueueTimeoutsPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemEnqueueTimeoutsPerTransaction {
	m := metricNewrelicoracledbSystemEnqueueTimeoutsPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemEnqueueWaitsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.enqueue_waits_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemEnqueueWaitsPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.enqueue_waits_per_second")
	m.data.SetDescription("Enqueue Waits Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemEnqueueWaitsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemEnqueueWaitsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemEnqueueWaitsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemEnqueueWaitsPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemEnqueueWaitsPerSecond {
	m := metricNewrelicoracledbSystemEnqueueWaitsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemEnqueueWaitsPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.enqueue_waits_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemEnqueueWaitsPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.enqueue_waits_per_transaction")
	m.data.SetDescription("Enqueue Waits Per Txn")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemEnqueueWaitsPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemEnqueueWaitsPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemEnqueueWaitsPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemEnqueueWaitsPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemEnqueueWaitsPerTransaction {
	m := metricNewrelicoracledbSystemEnqueueWaitsPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemExecuteWithoutParseRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.execute_without_parse_ratio metric with initial data.
func (m *metricNewrelicoracledbSystemExecuteWithoutParseRatio) init() {
	m.data.SetName("newrelicoracledb.system.execute_without_parse_ratio")
	m.data.SetDescription("Execute Without Parse Ratio")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemExecuteWithoutParseRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemExecuteWithoutParseRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemExecuteWithoutParseRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemExecuteWithoutParseRatio(cfg MetricConfig) metricNewrelicoracledbSystemExecuteWithoutParseRatio {
	m := metricNewrelicoracledbSystemExecuteWithoutParseRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemExecutionsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.executions_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemExecutionsPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.executions_per_second")
	m.data.SetDescription("Executions Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemExecutionsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemExecutionsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemExecutionsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemExecutionsPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemExecutionsPerSecond {
	m := metricNewrelicoracledbSystemExecutionsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemExecutionsPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.executions_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemExecutionsPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.executions_per_transaction")
	m.data.SetDescription("Executions Per Txn")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemExecutionsPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemExecutionsPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemExecutionsPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemExecutionsPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemExecutionsPerTransaction {
	m := metricNewrelicoracledbSystemExecutionsPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemExecutionsPerUserCall struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.executions_per_user_call metric with initial data.
func (m *metricNewrelicoracledbSystemExecutionsPerUserCall) init() {
	m.data.SetName("newrelicoracledb.system.executions_per_user_call")
	m.data.SetDescription("Executions Per User Call")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemExecutionsPerUserCall) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemExecutionsPerUserCall) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemExecutionsPerUserCall) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemExecutionsPerUserCall(cfg MetricConfig) metricNewrelicoracledbSystemExecutionsPerUserCall {
	m := metricNewrelicoracledbSystemExecutionsPerUserCall{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemFullIndexScansPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.full_index_scans_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemFullIndexScansPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.full_index_scans_per_second")
	m.data.SetDescription("Full Index Scans Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemFullIndexScansPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemFullIndexScansPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemFullIndexScansPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemFullIndexScansPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemFullIndexScansPerSecond {
	m := metricNewrelicoracledbSystemFullIndexScansPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemFullIndexScansPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.full_index_scans_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemFullIndexScansPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.full_index_scans_per_transaction")
	m.data.SetDescription("Full Index Scans Per Txn")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemFullIndexScansPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemFullIndexScansPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemFullIndexScansPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemFullIndexScansPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemFullIndexScansPerTransaction {
	m := metricNewrelicoracledbSystemFullIndexScansPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemGcCrBlockReceivedPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.gc_cr_block_received_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemGcCrBlockReceivedPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.gc_cr_block_received_per_second")
	m.data.SetDescription("GC CR Block Received Per Second")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemGcCrBlockReceivedPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemGcCrBlockReceivedPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemGcCrBlockReceivedPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemGcCrBlockReceivedPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemGcCrBlockReceivedPerSecond {
	m := metricNewrelicoracledbSystemGcCrBlockReceivedPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemGcCrBlockReceivedPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.gc_cr_block_received_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemGcCrBlockReceivedPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.gc_cr_block_received_per_transaction")
	m.data.SetDescription("GC CR Block Received Per Txn")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemGcCrBlockReceivedPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemGcCrBlockReceivedPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemGcCrBlockReceivedPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemGcCrBlockReceivedPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemGcCrBlockReceivedPerTransaction {
	m := metricNewrelicoracledbSystemGcCrBlockReceivedPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemGcCurrentBlockReceivedPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.gc_current_block_received_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemGcCurrentBlockReceivedPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.gc_current_block_received_per_second")
	m.data.SetDescription("GC Current Block Received Per Second")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemGcCurrentBlockReceivedPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemGcCurrentBlockReceivedPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemGcCurrentBlockReceivedPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemGcCurrentBlockReceivedPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemGcCurrentBlockReceivedPerSecond {
	m := metricNewrelicoracledbSystemGcCurrentBlockReceivedPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemGcCurrentBlockReceivedPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.gc_current_block_received_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemGcCurrentBlockReceivedPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.gc_current_block_received_per_transaction")
	m.data.SetDescription("GC Current Block Received Per Txn")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemGcCurrentBlockReceivedPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemGcCurrentBlockReceivedPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemGcCurrentBlockReceivedPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemGcCurrentBlockReceivedPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemGcCurrentBlockReceivedPerTransaction {
	m := metricNewrelicoracledbSystemGcCurrentBlockReceivedPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemGlobalCacheAverageCrGetTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.global_cache_average_cr_get_time metric with initial data.
func (m *metricNewrelicoracledbSystemGlobalCacheAverageCrGetTime) init() {
	m.data.SetName("newrelicoracledb.system.global_cache_average_cr_get_time")
	m.data.SetDescription("Global Cache Average CR Get Time")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemGlobalCacheAverageCrGetTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemGlobalCacheAverageCrGetTime) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemGlobalCacheAverageCrGetTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemGlobalCacheAverageCrGetTime(cfg MetricConfig) metricNewrelicoracledbSystemGlobalCacheAverageCrGetTime {
	m := metricNewrelicoracledbSystemGlobalCacheAverageCrGetTime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemGlobalCacheAverageCurrentGetTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.global_cache_average_current_get_time metric with initial data.
func (m *metricNewrelicoracledbSystemGlobalCacheAverageCurrentGetTime) init() {
	m.data.SetName("newrelicoracledb.system.global_cache_average_current_get_time")
	m.data.SetDescription("Global Cache Average Current Get Time")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemGlobalCacheAverageCurrentGetTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemGlobalCacheAverageCurrentGetTime) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemGlobalCacheAverageCurrentGetTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemGlobalCacheAverageCurrentGetTime(cfg MetricConfig) metricNewrelicoracledbSystemGlobalCacheAverageCurrentGetTime {
	m := metricNewrelicoracledbSystemGlobalCacheAverageCurrentGetTime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemGlobalCacheBlocksCorrupted struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.global_cache_blocks_corrupted metric with initial data.
func (m *metricNewrelicoracledbSystemGlobalCacheBlocksCorrupted) init() {
	m.data.SetName("newrelicoracledb.system.global_cache_blocks_corrupted")
	m.data.SetDescription("Global Cache Blocks Corrupted")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemGlobalCacheBlocksCorrupted) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemGlobalCacheBlocksCorrupted) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemGlobalCacheBlocksCorrupted) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemGlobalCacheBlocksCorrupted(cfg MetricConfig) metricNewrelicoracledbSystemGlobalCacheBlocksCorrupted {
	m := metricNewrelicoracledbSystemGlobalCacheBlocksCorrupted{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemGlobalCacheBlocksLost struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.global_cache_blocks_lost metric with initial data.
func (m *metricNewrelicoracledbSystemGlobalCacheBlocksLost) init() {
	m.data.SetName("newrelicoracledb.system.global_cache_blocks_lost")
	m.data.SetDescription("Global Cache Blocks Lost")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemGlobalCacheBlocksLost) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemGlobalCacheBlocksLost) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemGlobalCacheBlocksLost) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemGlobalCacheBlocksLost(cfg MetricConfig) metricNewrelicoracledbSystemGlobalCacheBlocksLost {
	m := metricNewrelicoracledbSystemGlobalCacheBlocksLost{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemHardParseCountPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.hard_parse_count_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemHardParseCountPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.hard_parse_count_per_second")
	m.data.SetDescription("Hard Parse Count Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemHardParseCountPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemHardParseCountPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemHardParseCountPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemHardParseCountPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemHardParseCountPerSecond {
	m := metricNewrelicoracledbSystemHardParseCountPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemHardParseCountPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.hard_parse_count_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemHardParseCountPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.hard_parse_count_per_transaction")
	m.data.SetDescription("Hard Parse Count Per Txn")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemHardParseCountPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemHardParseCountPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemHardParseCountPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemHardParseCountPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemHardParseCountPerTransaction {
	m := metricNewrelicoracledbSystemHardParseCountPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemHostCPUUsagePerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.host_cpu_usage_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemHostCPUUsagePerSecond) init() {
	m.data.SetName("newrelicoracledb.system.host_cpu_usage_per_second")
	m.data.SetDescription("Host CPU Usage Per Sec")
	m.data.SetUnit("s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemHostCPUUsagePerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemHostCPUUsagePerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemHostCPUUsagePerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemHostCPUUsagePerSecond(cfg MetricConfig) metricNewrelicoracledbSystemHostCPUUsagePerSecond {
	m := metricNewrelicoracledbSystemHostCPUUsagePerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemHostCPUUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.host_cpu_utilization metric with initial data.
func (m *metricNewrelicoracledbSystemHostCPUUtilization) init() {
	m.data.SetName("newrelicoracledb.system.host_cpu_utilization")
	m.data.SetDescription("Host CPU Utilization (%)")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemHostCPUUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemHostCPUUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemHostCPUUtilization) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemHostCPUUtilization(cfg MetricConfig) metricNewrelicoracledbSystemHostCPUUtilization {
	m := metricNewrelicoracledbSystemHostCPUUtilization{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemIoMegabytesPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.io_megabytes_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemIoMegabytesPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.io_megabytes_per_second")
	m.data.SetDescription("I/O Megabytes per Second")
	m.data.SetUnit("MBy/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemIoMegabytesPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemIoMegabytesPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemIoMegabytesPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemIoMegabytesPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemIoMegabytesPerSecond {
	m := metricNewrelicoracledbSystemIoMegabytesPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemIoRequestsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.io_requests_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemIoRequestsPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.io_requests_per_second")
	m.data.SetDescription("I/O Requests per Second")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemIoRequestsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemIoRequestsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemIoRequestsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemIoRequestsPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemIoRequestsPerSecond {
	m := metricNewrelicoracledbSystemIoRequestsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemLeafNodeSplitsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.leaf_node_splits_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemLeafNodeSplitsPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.leaf_node_splits_per_second")
	m.data.SetDescription("Leaf Node Splits Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemLeafNodeSplitsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemLeafNodeSplitsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemLeafNodeSplitsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemLeafNodeSplitsPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemLeafNodeSplitsPerSecond {
	m := metricNewrelicoracledbSystemLeafNodeSplitsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemLeafNodeSplitsPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.leaf_node_splits_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemLeafNodeSplitsPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.leaf_node_splits_per_transaction")
	m.data.SetDescription("Leaf Node Splits Per Txn")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemLeafNodeSplitsPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemLeafNodeSplitsPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemLeafNodeSplitsPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemLeafNodeSplitsPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemLeafNodeSplitsPerTransaction {
	m := metricNewrelicoracledbSystemLeafNodeSplitsPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemLibraryCacheHitRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.library_cache_hit_ratio metric with initial data.
func (m *metricNewrelicoracledbSystemLibraryCacheHitRatio) init() {
	m.data.SetName("newrelicoracledb.system.library_cache_hit_ratio")
	m.data.SetDescription("Library Cache Hit Ratio")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemLibraryCacheHitRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemLibraryCacheHitRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemLibraryCacheHitRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemLibraryCacheHitRatio(cfg MetricConfig) metricNewrelicoracledbSystemLibraryCacheHitRatio {
	m := metricNewrelicoracledbSystemLibraryCacheHitRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemLibraryCacheMissRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.library_cache_miss_ratio metric with initial data.
func (m *metricNewrelicoracledbSystemLibraryCacheMissRatio) init() {
	m.data.SetName("newrelicoracledb.system.library_cache_miss_ratio")
	m.data.SetDescription("Library Cache Miss Ratio")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemLibraryCacheMissRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemLibraryCacheMissRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemLibraryCacheMissRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemLibraryCacheMissRatio(cfg MetricConfig) metricNewrelicoracledbSystemLibraryCacheMissRatio {
	m := metricNewrelicoracledbSystemLibraryCacheMissRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemLogicalReadsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.logical_reads_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemLogicalReadsPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.logical_reads_per_second")
	m.data.SetDescription("Logical Reads Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemLogicalReadsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemLogicalReadsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemLogicalReadsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemLogicalReadsPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemLogicalReadsPerSecond {
	m := metricNewrelicoracledbSystemLogicalReadsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemLogicalReadsPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.logical_reads_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemLogicalReadsPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.logical_reads_per_transaction")
	m.data.SetDescription("Logical Reads Per Txn")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemLogicalReadsPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemLogicalReadsPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemLogicalReadsPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemLogicalReadsPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemLogicalReadsPerTransaction {
	m := metricNewrelicoracledbSystemLogicalReadsPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemLogicalReadsPerUserCall struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.logical_reads_per_user_call metric with initial data.
func (m *metricNewrelicoracledbSystemLogicalReadsPerUserCall) init() {
	m.data.SetName("newrelicoracledb.system.logical_reads_per_user_call")
	m.data.SetDescription("Logical Reads Per User Call")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemLogicalReadsPerUserCall) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemLogicalReadsPerUserCall) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemLogicalReadsPerUserCall) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemLogicalReadsPerUserCall(cfg MetricConfig) metricNewrelicoracledbSystemLogicalReadsPerUserCall {
	m := metricNewrelicoracledbSystemLogicalReadsPerUserCall{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemLogonsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.logons_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemLogonsPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.logons_per_second")
	m.data.SetDescription("Logons Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemLogonsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemLogonsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemLogonsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemLogonsPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemLogonsPerSecond {
	m := metricNewrelicoracledbSystemLogonsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemLogonsPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.logons_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemLogonsPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.logons_per_transaction")
	m.data.SetDescription("Logons Per Txn")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemLogonsPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemLogonsPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemLogonsPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemLogonsPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemLogonsPerTransaction {
	m := metricNewrelicoracledbSystemLogonsPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemLongTableScansPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.long_table_scans_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemLongTableScansPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.long_table_scans_per_second")
	m.data.SetDescription("Long Table Scans Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemLongTableScansPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemLongTableScansPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemLongTableScansPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemLongTableScansPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemLongTableScansPerSecond {
	m := metricNewrelicoracledbSystemLongTableScansPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemLongTableScansPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.long_table_scans_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemLongTableScansPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.long_table_scans_per_transaction")
	m.data.SetDescription("Long Table Scans Per Txn")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemLongTableScansPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemLongTableScansPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemLongTableScansPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemLongTableScansPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemLongTableScansPerTransaction {
	m := metricNewrelicoracledbSystemLongTableScansPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemMemorySortsRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.memory_sorts_ratio metric with initial data.
func (m *metricNewrelicoracledbSystemMemorySortsRatio) init() {
	m.data.SetName("newrelicoracledb.system.memory_sorts_ratio")
	m.data.SetDescription("Memory Sorts Ratio")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemMemorySortsRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemMemorySortsRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemMemorySortsRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemMemorySortsRatio(cfg MetricConfig) metricNewrelicoracledbSystemMemorySortsRatio {
	m := metricNewrelicoracledbSystemMemorySortsRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemNetworkTrafficVolumePerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.network_traffic_volume_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemNetworkTrafficVolumePerSecond) init() {
	m.data.SetName("newrelicoracledb.system.network_traffic_volume_per_second")
	m.data.SetDescription("Network Traffic Volume Per Sec")
	m.data.SetUnit("By/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemNetworkTrafficVolumePerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemNetworkTrafficVolumePerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemNetworkTrafficVolumePerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemNetworkTrafficVolumePerSecond(cfg MetricConfig) metricNewrelicoracledbSystemNetworkTrafficVolumePerSecond {
	m := metricNewrelicoracledbSystemNetworkTrafficVolumePerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemOpenCursorsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.open_cursors_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemOpenCursorsPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.open_cursors_per_second")
	m.data.SetDescription("Open Cursors Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemOpenCursorsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemOpenCursorsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemOpenCursorsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemOpenCursorsPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemOpenCursorsPerSecond {
	m := metricNewrelicoracledbSystemOpenCursorsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemOpenCursorsPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.open_cursors_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemOpenCursorsPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.open_cursors_per_transaction")
	m.data.SetDescription("Open Cursors Per Txn")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemOpenCursorsPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemOpenCursorsPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemOpenCursorsPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemOpenCursorsPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemOpenCursorsPerTransaction {
	m := metricNewrelicoracledbSystemOpenCursorsPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemParseFailureCountPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.parse_failure_count_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemParseFailureCountPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.parse_failure_count_per_second")
	m.data.SetDescription("Parse Failure Count Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemParseFailureCountPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemParseFailureCountPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemParseFailureCountPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemParseFailureCountPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemParseFailureCountPerSecond {
	m := metricNewrelicoracledbSystemParseFailureCountPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemParseFailureCountPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.parse_failure_count_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemParseFailureCountPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.parse_failure_count_per_transaction")
	m.data.SetDescription("Parse Failure Count Per Txn")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemParseFailureCountPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemParseFailureCountPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemParseFailureCountPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemParseFailureCountPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemParseFailureCountPerTransaction {
	m := metricNewrelicoracledbSystemParseFailureCountPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemPgaCacheHitPercentage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.pga_cache_hit_percentage metric with initial data.
func (m *metricNewrelicoracledbSystemPgaCacheHitPercentage) init() {
	m.data.SetName("newrelicoracledb.system.pga_cache_hit_percentage")
	m.data.SetDescription("PGA Cache Hit %")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemPgaCacheHitPercentage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemPgaCacheHitPercentage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemPgaCacheHitPercentage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemPgaCacheHitPercentage(cfg MetricConfig) metricNewrelicoracledbSystemPgaCacheHitPercentage {
	m := metricNewrelicoracledbSystemPgaCacheHitPercentage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemPhysicalLobsReadsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.physical_lobs_reads_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemPhysicalLobsReadsPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.physical_lobs_reads_per_second")
	m.data.SetDescription("Physical Reads Direct Lobs Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemPhysicalLobsReadsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemPhysicalLobsReadsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemPhysicalLobsReadsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemPhysicalLobsReadsPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemPhysicalLobsReadsPerSecond {
	m := metricNewrelicoracledbSystemPhysicalLobsReadsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemPhysicalLobsReadsPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.physical_lobs_reads_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemPhysicalLobsReadsPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.physical_lobs_reads_per_transaction")
	m.data.SetDescription("Physical Reads Direct Lobs Per Txn")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemPhysicalLobsReadsPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemPhysicalLobsReadsPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemPhysicalLobsReadsPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemPhysicalLobsReadsPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemPhysicalLobsReadsPerTransaction {
	m := metricNewrelicoracledbSystemPhysicalLobsReadsPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemPhysicalLobsWritesPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.physical_lobs_writes_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemPhysicalLobsWritesPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.physical_lobs_writes_per_second")
	m.data.SetDescription("Physical Writes Direct Lobs Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemPhysicalLobsWritesPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemPhysicalLobsWritesPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemPhysicalLobsWritesPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemPhysicalLobsWritesPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemPhysicalLobsWritesPerSecond {
	m := metricNewrelicoracledbSystemPhysicalLobsWritesPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemPhysicalLobsWritesPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.physical_lobs_writes_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemPhysicalLobsWritesPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.physical_lobs_writes_per_transaction")
	m.data.SetDescription("Physical Writes Direct Lobs Per Txn")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemPhysicalLobsWritesPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemPhysicalLobsWritesPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemPhysicalLobsWritesPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemPhysicalLobsWritesPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemPhysicalLobsWritesPerTransaction {
	m := metricNewrelicoracledbSystemPhysicalLobsWritesPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemPhysicalReadBytesPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.physical_read_bytes_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemPhysicalReadBytesPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.physical_read_bytes_per_second")
	m.data.SetDescription("Physical Read Bytes Per Sec")
	m.data.SetUnit("By/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemPhysicalReadBytesPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemPhysicalReadBytesPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemPhysicalReadBytesPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemPhysicalReadBytesPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemPhysicalReadBytesPerSecond {
	m := metricNewrelicoracledbSystemPhysicalReadBytesPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemPhysicalReadIoRequestsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.physical_read_io_requests_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemPhysicalReadIoRequestsPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.physical_read_io_requests_per_second")
	m.data.SetDescription("Physical Read IO Requests Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemPhysicalReadIoRequestsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemPhysicalReadIoRequestsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemPhysicalReadIoRequestsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemPhysicalReadIoRequestsPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemPhysicalReadIoRequestsPerSecond {
	m := metricNewrelicoracledbSystemPhysicalReadIoRequestsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemPhysicalReadTotalBytesPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.physical_read_total_bytes_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemPhysicalReadTotalBytesPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.physical_read_total_bytes_per_second")
	m.data.SetDescription("Physical Read Total Bytes Per Sec")
	m.data.SetUnit("By/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemPhysicalReadTotalBytesPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemPhysicalReadTotalBytesPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemPhysicalReadTotalBytesPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemPhysicalReadTotalBytesPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemPhysicalReadTotalBytesPerSecond {
	m := metricNewrelicoracledbSystemPhysicalReadTotalBytesPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemPhysicalReadTotalIoRequestsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.physical_read_total_io_requests_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemPhysicalReadTotalIoRequestsPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.physical_read_total_io_requests_per_second")
	m.data.SetDescription("Physical Read Total IO Requests Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemPhysicalReadTotalIoRequestsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemPhysicalReadTotalIoRequestsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemPhysicalReadTotalIoRequestsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemPhysicalReadTotalIoRequestsPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemPhysicalReadTotalIoRequestsPerSecond {
	m := metricNewrelicoracledbSystemPhysicalReadTotalIoRequestsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemPhysicalReadsDirectPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.physical_reads_direct_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemPhysicalReadsDirectPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.physical_reads_direct_per_second")
	m.data.SetDescription("Physical Reads Direct Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemPhysicalReadsDirectPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemPhysicalReadsDirectPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemPhysicalReadsDirectPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemPhysicalReadsDirectPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemPhysicalReadsDirectPerSecond {
	m := metricNewrelicoracledbSystemPhysicalReadsDirectPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemPhysicalReadsDirectPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.physical_reads_direct_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemPhysicalReadsDirectPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.physical_reads_direct_per_transaction")
	m.data.SetDescription("Physical Reads Direct Per Txn")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemPhysicalReadsDirectPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemPhysicalReadsDirectPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemPhysicalReadsDirectPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemPhysicalReadsDirectPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemPhysicalReadsDirectPerTransaction {
	m := metricNewrelicoracledbSystemPhysicalReadsDirectPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemPhysicalReadsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.physical_reads_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemPhysicalReadsPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.physical_reads_per_second")
	m.data.SetDescription("Physical Reads Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemPhysicalReadsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemPhysicalReadsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemPhysicalReadsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemPhysicalReadsPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemPhysicalReadsPerSecond {
	m := metricNewrelicoracledbSystemPhysicalReadsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemPhysicalReadsPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.physical_reads_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemPhysicalReadsPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.physical_reads_per_transaction")
	m.data.SetDescription("Physical Reads Per Txn")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemPhysicalReadsPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemPhysicalReadsPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemPhysicalReadsPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemPhysicalReadsPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemPhysicalReadsPerTransaction {
	m := metricNewrelicoracledbSystemPhysicalReadsPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemPhysicalWriteBytesPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.physical_write_bytes_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemPhysicalWriteBytesPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.physical_write_bytes_per_second")
	m.data.SetDescription("Physical Write Bytes Per Sec")
	m.data.SetUnit("By/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemPhysicalWriteBytesPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemPhysicalWriteBytesPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemPhysicalWriteBytesPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemPhysicalWriteBytesPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemPhysicalWriteBytesPerSecond {
	m := metricNewrelicoracledbSystemPhysicalWriteBytesPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemPhysicalWriteIoRequestsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.physical_write_io_requests_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemPhysicalWriteIoRequestsPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.physical_write_io_requests_per_second")
	m.data.SetDescription("Physical Write IO Requests Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemPhysicalWriteIoRequestsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemPhysicalWriteIoRequestsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemPhysicalWriteIoRequestsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemPhysicalWriteIoRequestsPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemPhysicalWriteIoRequestsPerSecond {
	m := metricNewrelicoracledbSystemPhysicalWriteIoRequestsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemPhysicalWriteTotalBytesPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.physical_write_total_bytes_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemPhysicalWriteTotalBytesPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.physical_write_total_bytes_per_second")
	m.data.SetDescription("Physical Write Total Bytes Per Sec")
	m.data.SetUnit("By/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemPhysicalWriteTotalBytesPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemPhysicalWriteTotalBytesPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemPhysicalWriteTotalBytesPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemPhysicalWriteTotalBytesPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemPhysicalWriteTotalBytesPerSecond {
	m := metricNewrelicoracledbSystemPhysicalWriteTotalBytesPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemPhysicalWriteTotalIoRequestsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.physical_write_total_io_requests_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemPhysicalWriteTotalIoRequestsPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.physical_write_total_io_requests_per_second")
	m.data.SetDescription("Physical Write Total IO Requests Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemPhysicalWriteTotalIoRequestsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemPhysicalWriteTotalIoRequestsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemPhysicalWriteTotalIoRequestsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemPhysicalWriteTotalIoRequestsPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemPhysicalWriteTotalIoRequestsPerSecond {
	m := metricNewrelicoracledbSystemPhysicalWriteTotalIoRequestsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemPhysicalWritesDirectPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.physical_writes_direct_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemPhysicalWritesDirectPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.physical_writes_direct_per_second")
	m.data.SetDescription("Physical Writes Direct Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemPhysicalWritesDirectPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemPhysicalWritesDirectPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemPhysicalWritesDirectPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemPhysicalWritesDirectPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemPhysicalWritesDirectPerSecond {
	m := metricNewrelicoracledbSystemPhysicalWritesDirectPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemPhysicalWritesDirectPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.physical_writes_direct_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemPhysicalWritesDirectPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.physical_writes_direct_per_transaction")
	m.data.SetDescription("Physical Writes Direct Per Txn")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemPhysicalWritesDirectPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemPhysicalWritesDirectPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemPhysicalWritesDirectPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemPhysicalWritesDirectPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemPhysicalWritesDirectPerTransaction {
	m := metricNewrelicoracledbSystemPhysicalWritesDirectPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemPhysicalWritesPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.physical_writes_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemPhysicalWritesPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.physical_writes_per_second")
	m.data.SetDescription("Physical Writes Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemPhysicalWritesPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemPhysicalWritesPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemPhysicalWritesPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemPhysicalWritesPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemPhysicalWritesPerSecond {
	m := metricNewrelicoracledbSystemPhysicalWritesPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemPhysicalWritesPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.physical_writes_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemPhysicalWritesPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.physical_writes_per_transaction")
	m.data.SetDescription("Physical Writes Per Txn")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemPhysicalWritesPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemPhysicalWritesPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemPhysicalWritesPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemPhysicalWritesPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemPhysicalWritesPerTransaction {
	m := metricNewrelicoracledbSystemPhysicalWritesPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemProcessLimitPercentage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.process_limit_percentage metric with initial data.
func (m *metricNewrelicoracledbSystemProcessLimitPercentage) init() {
	m.data.SetName("newrelicoracledb.system.process_limit_percentage")
	m.data.SetDescription("Process Limit %")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemProcessLimitPercentage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemProcessLimitPercentage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemProcessLimitPercentage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemProcessLimitPercentage(cfg MetricConfig) metricNewrelicoracledbSystemProcessLimitPercentage {
	m := metricNewrelicoracledbSystemProcessLimitPercentage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemRecursiveCallsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.recursive_calls_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemRecursiveCallsPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.recursive_calls_per_second")
	m.data.SetDescription("Recursive Calls Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemRecursiveCallsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemRecursiveCallsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemRecursiveCallsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemRecursiveCallsPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemRecursiveCallsPerSecond {
	m := metricNewrelicoracledbSystemRecursiveCallsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemRecursiveCallsPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.recursive_calls_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemRecursiveCallsPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.recursive_calls_per_transaction")
	m.data.SetDescription("Recursive Calls Per Txn")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemRecursiveCallsPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemRecursiveCallsPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemRecursiveCallsPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemRecursiveCallsPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemRecursiveCallsPerTransaction {
	m := metricNewrelicoracledbSystemRecursiveCallsPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemRedoAllocationHitRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.redo_allocation_hit_ratio metric with initial data.
func (m *metricNewrelicoracledbSystemRedoAllocationHitRatio) init() {
	m.data.SetName("newrelicoracledb.system.redo_allocation_hit_ratio")
	m.data.SetDescription("Redo Allocation Hit Ratio")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemRedoAllocationHitRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemRedoAllocationHitRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemRedoAllocationHitRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemRedoAllocationHitRatio(cfg MetricConfig) metricNewrelicoracledbSystemRedoAllocationHitRatio {
	m := metricNewrelicoracledbSystemRedoAllocationHitRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemRedoGeneratedBytesPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.redo_generated_bytes_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemRedoGeneratedBytesPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.redo_generated_bytes_per_second")
	m.data.SetDescription("Redo Generated Per Sec")
	m.data.SetUnit("By/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemRedoGeneratedBytesPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemRedoGeneratedBytesPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemRedoGeneratedBytesPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemRedoGeneratedBytesPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemRedoGeneratedBytesPerSecond {
	m := metricNewrelicoracledbSystemRedoGeneratedBytesPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemRedoGeneratedBytesPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.redo_generated_bytes_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemRedoGeneratedBytesPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.redo_generated_bytes_per_transaction")
	m.data.SetDescription("Redo Generated Per Txn")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemRedoGeneratedBytesPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemRedoGeneratedBytesPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemRedoGeneratedBytesPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemRedoGeneratedBytesPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemRedoGeneratedBytesPerTransaction {
	m := metricNewrelicoracledbSystemRedoGeneratedBytesPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemRedoWritesPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.redo_writes_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemRedoWritesPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.redo_writes_per_second")
	m.data.SetDescription("Redo Writes Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemRedoWritesPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemRedoWritesPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemRedoWritesPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemRedoWritesPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemRedoWritesPerSecond {
	m := metricNewrelicoracledbSystemRedoWritesPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemRedoWritesPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.redo_writes_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemRedoWritesPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.redo_writes_per_transaction")
	m.data.SetDescription("Redo Writes Per Txn")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemRedoWritesPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemRedoWritesPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemRedoWritesPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemRedoWritesPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemRedoWritesPerTransaction {
	m := metricNewrelicoracledbSystemRedoWritesPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemResponseTimePerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.response_time_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemResponseTimePerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.response_time_per_transaction")
	m.data.SetDescription("Response Time Per Txn")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemResponseTimePerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemResponseTimePerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemResponseTimePerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemResponseTimePerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemResponseTimePerTransaction {
	m := metricNewrelicoracledbSystemResponseTimePerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemRowCacheHitRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.row_cache_hit_ratio metric with initial data.
func (m *metricNewrelicoracledbSystemRowCacheHitRatio) init() {
	m.data.SetName("newrelicoracledb.system.row_cache_hit_ratio")
	m.data.SetDescription("Row Cache Hit Ratio")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemRowCacheHitRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemRowCacheHitRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemRowCacheHitRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemRowCacheHitRatio(cfg MetricConfig) metricNewrelicoracledbSystemRowCacheHitRatio {
	m := metricNewrelicoracledbSystemRowCacheHitRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemRowCacheMissRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.row_cache_miss_ratio metric with initial data.
func (m *metricNewrelicoracledbSystemRowCacheMissRatio) init() {
	m.data.SetName("newrelicoracledb.system.row_cache_miss_ratio")
	m.data.SetDescription("Row Cache Miss Ratio")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemRowCacheMissRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemRowCacheMissRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemRowCacheMissRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemRowCacheMissRatio(cfg MetricConfig) metricNewrelicoracledbSystemRowCacheMissRatio {
	m := metricNewrelicoracledbSystemRowCacheMissRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemRowsPerSort struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.rows_per_sort metric with initial data.
func (m *metricNewrelicoracledbSystemRowsPerSort) init() {
	m.data.SetName("newrelicoracledb.system.rows_per_sort")
	m.data.SetDescription("Rows Per Sort")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemRowsPerSort) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemRowsPerSort) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemRowsPerSort) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemRowsPerSort(cfg MetricConfig) metricNewrelicoracledbSystemRowsPerSort {
	m := metricNewrelicoracledbSystemRowsPerSort{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemSessionCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.session_count metric with initial data.
func (m *metricNewrelicoracledbSystemSessionCount) init() {
	m.data.SetName("newrelicoracledb.system.session_count")
	m.data.SetDescription("Session Count")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemSessionCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemSessionCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemSessionCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemSessionCount(cfg MetricConfig) metricNewrelicoracledbSystemSessionCount {
	m := metricNewrelicoracledbSystemSessionCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemSessionLimitPercentage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.session_limit_percentage metric with initial data.
func (m *metricNewrelicoracledbSystemSessionLimitPercentage) init() {
	m.data.SetName("newrelicoracledb.system.session_limit_percentage")
	m.data.SetDescription("Session Limit %")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemSessionLimitPercentage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemSessionLimitPercentage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemSessionLimitPercentage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemSessionLimitPercentage(cfg MetricConfig) metricNewrelicoracledbSystemSessionLimitPercentage {
	m := metricNewrelicoracledbSystemSessionLimitPercentage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemSharedPoolFreePercentage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.shared_pool_free_percentage metric with initial data.
func (m *metricNewrelicoracledbSystemSharedPoolFreePercentage) init() {
	m.data.SetName("newrelicoracledb.system.shared_pool_free_percentage")
	m.data.SetDescription("Shared Pool Free %")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemSharedPoolFreePercentage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemSharedPoolFreePercentage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemSharedPoolFreePercentage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemSharedPoolFreePercentage(cfg MetricConfig) metricNewrelicoracledbSystemSharedPoolFreePercentage {
	m := metricNewrelicoracledbSystemSharedPoolFreePercentage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemSoftParseRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.soft_parse_ratio metric with initial data.
func (m *metricNewrelicoracledbSystemSoftParseRatio) init() {
	m.data.SetName("newrelicoracledb.system.soft_parse_ratio")
	m.data.SetDescription("Soft Parse Ratio")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemSoftParseRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemSoftParseRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemSoftParseRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemSoftParseRatio(cfg MetricConfig) metricNewrelicoracledbSystemSoftParseRatio {
	m := metricNewrelicoracledbSystemSoftParseRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemSQLServiceResponseTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.sql_service_response_time metric with initial data.
func (m *metricNewrelicoracledbSystemSQLServiceResponseTime) init() {
	m.data.SetName("newrelicoracledb.system.sql_service_response_time")
	m.data.SetDescription("SQL Service Response Time")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemSQLServiceResponseTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemSQLServiceResponseTime) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemSQLServiceResponseTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemSQLServiceResponseTime(cfg MetricConfig) metricNewrelicoracledbSystemSQLServiceResponseTime {
	m := metricNewrelicoracledbSystemSQLServiceResponseTime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemStreamsPoolUsagePercentage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.streams_pool_usage_percentage metric with initial data.
func (m *metricNewrelicoracledbSystemStreamsPoolUsagePercentage) init() {
	m.data.SetName("newrelicoracledb.system.streams_pool_usage_percentage")
	m.data.SetDescription("Streams Pool Usage Percentage")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemStreamsPoolUsagePercentage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemStreamsPoolUsagePercentage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemStreamsPoolUsagePercentage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemStreamsPoolUsagePercentage(cfg MetricConfig) metricNewrelicoracledbSystemStreamsPoolUsagePercentage {
	m := metricNewrelicoracledbSystemStreamsPoolUsagePercentage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemTempSpaceUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.temp_space_used metric with initial data.
func (m *metricNewrelicoracledbSystemTempSpaceUsed) init() {
	m.data.SetName("newrelicoracledb.system.temp_space_used")
	m.data.SetDescription("Temp Space Used")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemTempSpaceUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemTempSpaceUsed) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemTempSpaceUsed) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemTempSpaceUsed(cfg MetricConfig) metricNewrelicoracledbSystemTempSpaceUsed {
	m := metricNewrelicoracledbSystemTempSpaceUsed{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemTotalIndexScansPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.total_index_scans_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemTotalIndexScansPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.total_index_scans_per_second")
	m.data.SetDescription("Total Index Scans Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemTotalIndexScansPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemTotalIndexScansPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemTotalIndexScansPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemTotalIndexScansPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemTotalIndexScansPerSecond {
	m := metricNewrelicoracledbSystemTotalIndexScansPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemTotalIndexScansPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.total_index_scans_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemTotalIndexScansPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.total_index_scans_per_transaction")
	m.data.SetDescription("Total Index Scans Per Txn")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemTotalIndexScansPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemTotalIndexScansPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemTotalIndexScansPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemTotalIndexScansPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemTotalIndexScansPerTransaction {
	m := metricNewrelicoracledbSystemTotalIndexScansPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemTotalParseCountPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.total_parse_count_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemTotalParseCountPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.total_parse_count_per_second")
	m.data.SetDescription("Total Parse Count Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemTotalParseCountPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemTotalParseCountPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemTotalParseCountPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemTotalParseCountPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemTotalParseCountPerSecond {
	m := metricNewrelicoracledbSystemTotalParseCountPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemTotalParseCountPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.total_parse_count_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemTotalParseCountPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.total_parse_count_per_transaction")
	m.data.SetDescription("Total Parse Count Per Txn")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemTotalParseCountPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemTotalParseCountPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemTotalParseCountPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemTotalParseCountPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemTotalParseCountPerTransaction {
	m := metricNewrelicoracledbSystemTotalParseCountPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemTotalSortsPerUserCall struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.total_sorts_per_user_call metric with initial data.
func (m *metricNewrelicoracledbSystemTotalSortsPerUserCall) init() {
	m.data.SetName("newrelicoracledb.system.total_sorts_per_user_call")
	m.data.SetDescription("Total Sorts Per User Call")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemTotalSortsPerUserCall) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemTotalSortsPerUserCall) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemTotalSortsPerUserCall) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemTotalSortsPerUserCall(cfg MetricConfig) metricNewrelicoracledbSystemTotalSortsPerUserCall {
	m := metricNewrelicoracledbSystemTotalSortsPerUserCall{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemTotalTableScansPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.total_table_scans_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemTotalTableScansPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.total_table_scans_per_second")
	m.data.SetDescription("Total Table Scans Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemTotalTableScansPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemTotalTableScansPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemTotalTableScansPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemTotalTableScansPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemTotalTableScansPerSecond {
	m := metricNewrelicoracledbSystemTotalTableScansPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemTotalTableScansPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.total_table_scans_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemTotalTableScansPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.total_table_scans_per_transaction")
	m.data.SetDescription("Total Table Scans Per Txn")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemTotalTableScansPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemTotalTableScansPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemTotalTableScansPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemTotalTableScansPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemTotalTableScansPerTransaction {
	m := metricNewrelicoracledbSystemTotalTableScansPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemTotalTableScansPerUserCall struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.total_table_scans_per_user_call metric with initial data.
func (m *metricNewrelicoracledbSystemTotalTableScansPerUserCall) init() {
	m.data.SetName("newrelicoracledb.system.total_table_scans_per_user_call")
	m.data.SetDescription("Total Table Scans Per User Call")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemTotalTableScansPerUserCall) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemTotalTableScansPerUserCall) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemTotalTableScansPerUserCall) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemTotalTableScansPerUserCall(cfg MetricConfig) metricNewrelicoracledbSystemTotalTableScansPerUserCall {
	m := metricNewrelicoracledbSystemTotalTableScansPerUserCall{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemTransactionsPerLogon struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.transactions_per_logon metric with initial data.
func (m *metricNewrelicoracledbSystemTransactionsPerLogon) init() {
	m.data.SetName("newrelicoracledb.system.transactions_per_logon")
	m.data.SetDescription("Txns Per Logon")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemTransactionsPerLogon) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemTransactionsPerLogon) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemTransactionsPerLogon) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemTransactionsPerLogon(cfg MetricConfig) metricNewrelicoracledbSystemTransactionsPerLogon {
	m := metricNewrelicoracledbSystemTransactionsPerLogon{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemTransactionsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.transactions_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemTransactionsPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.transactions_per_second")
	m.data.SetDescription("User Transaction Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemTransactionsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemTransactionsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemTransactionsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemTransactionsPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemTransactionsPerSecond {
	m := metricNewrelicoracledbSystemTransactionsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemUserCallsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.user_calls_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemUserCallsPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.user_calls_per_second")
	m.data.SetDescription("User Calls Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemUserCallsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemUserCallsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemUserCallsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemUserCallsPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemUserCallsPerSecond {
	m := metricNewrelicoracledbSystemUserCallsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemUserCallsPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.user_calls_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemUserCallsPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.user_calls_per_transaction")
	m.data.SetDescription("User Calls Per Txn")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemUserCallsPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemUserCallsPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemUserCallsPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemUserCallsPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemUserCallsPerTransaction {
	m := metricNewrelicoracledbSystemUserCallsPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemUserCallsRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.user_calls_ratio metric with initial data.
func (m *metricNewrelicoracledbSystemUserCallsRatio) init() {
	m.data.SetName("newrelicoracledb.system.user_calls_ratio")
	m.data.SetDescription("User Calls Ratio")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemUserCallsRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemUserCallsRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemUserCallsRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemUserCallsRatio(cfg MetricConfig) metricNewrelicoracledbSystemUserCallsRatio {
	m := metricNewrelicoracledbSystemUserCallsRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemUserCommitsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.user_commits_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemUserCommitsPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.user_commits_per_second")
	m.data.SetDescription("User Commits Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemUserCommitsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemUserCommitsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemUserCommitsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemUserCommitsPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemUserCommitsPerSecond {
	m := metricNewrelicoracledbSystemUserCommitsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemUserCommitsPercentage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.user_commits_percentage metric with initial data.
func (m *metricNewrelicoracledbSystemUserCommitsPercentage) init() {
	m.data.SetName("newrelicoracledb.system.user_commits_percentage")
	m.data.SetDescription("User Commits Percentage")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemUserCommitsPercentage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemUserCommitsPercentage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemUserCommitsPercentage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemUserCommitsPercentage(cfg MetricConfig) metricNewrelicoracledbSystemUserCommitsPercentage {
	m := metricNewrelicoracledbSystemUserCommitsPercentage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemUserLimitPercentage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.user_limit_percentage metric with initial data.
func (m *metricNewrelicoracledbSystemUserLimitPercentage) init() {
	m.data.SetName("newrelicoracledb.system.user_limit_percentage")
	m.data.SetDescription("User Limit %")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemUserLimitPercentage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemUserLimitPercentage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemUserLimitPercentage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemUserLimitPercentage(cfg MetricConfig) metricNewrelicoracledbSystemUserLimitPercentage {
	m := metricNewrelicoracledbSystemUserLimitPercentage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.user_rollback_undo_records_applied_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.user_rollback_undo_records_applied_per_second")
	m.data.SetDescription("User Rollback UndoRec Applied Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerSecond {
	m := metricNewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.user_rollback_undo_records_applied_per_transaction metric with initial data.
func (m *metricNewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerTransaction) init() {
	m.data.SetName("newrelicoracledb.system.user_rollback_undo_records_applied_per_transaction")
	m.data.SetDescription("User Rollback Undo Records Applied Per Txn")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerTransaction(cfg MetricConfig) metricNewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerTransaction {
	m := metricNewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemUserRollbacksPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.user_rollbacks_per_second metric with initial data.
func (m *metricNewrelicoracledbSystemUserRollbacksPerSecond) init() {
	m.data.SetName("newrelicoracledb.system.user_rollbacks_per_second")
	m.data.SetDescription("User Rollbacks Per Sec")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemUserRollbacksPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemUserRollbacksPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemUserRollbacksPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemUserRollbacksPerSecond(cfg MetricConfig) metricNewrelicoracledbSystemUserRollbacksPerSecond {
	m := metricNewrelicoracledbSystemUserRollbacksPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbSystemUserRollbacksPercentage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.system.user_rollbacks_percentage metric with initial data.
func (m *metricNewrelicoracledbSystemUserRollbacksPercentage) init() {
	m.data.SetName("newrelicoracledb.system.user_rollbacks_percentage")
	m.data.SetDescription("User Rollbacks Percentage")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbSystemUserRollbacksPercentage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("instance.id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbSystemUserRollbacksPercentage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbSystemUserRollbacksPercentage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbSystemUserRollbacksPercentage(cfg MetricConfig) metricNewrelicoracledbSystemUserRollbacksPercentage {
	m := metricNewrelicoracledbSystemUserRollbacksPercentage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbTablespaceDbID struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.tablespace.db_id metric with initial data.
func (m *metricNewrelicoracledbTablespaceDbID) init() {
	m.data.SetName("newrelicoracledb.tablespace.db_id")
	m.data.SetDescription("Database ID information for tablespace")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbTablespaceDbID) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, tablespaceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("tablespace.name", tablespaceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbTablespaceDbID) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbTablespaceDbID) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbTablespaceDbID(cfg MetricConfig) metricNewrelicoracledbTablespaceDbID {
	m := metricNewrelicoracledbTablespaceDbID{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbTablespaceGlobalName struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.tablespace.global_name metric with initial data.
func (m *metricNewrelicoracledbTablespaceGlobalName) init() {
	m.data.SetName("newrelicoracledb.tablespace.global_name")
	m.data.SetDescription("Global name information for tablespace")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbTablespaceGlobalName) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, tablespaceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("tablespace.name", tablespaceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbTablespaceGlobalName) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbTablespaceGlobalName) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbTablespaceGlobalName(cfg MetricConfig) metricNewrelicoracledbTablespaceGlobalName {
	m := metricNewrelicoracledbTablespaceGlobalName{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbTablespaceIsOffline struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.tablespace.is_offline metric with initial data.
func (m *metricNewrelicoracledbTablespaceIsOffline) init() {
	m.data.SetName("newrelicoracledb.tablespace.is_offline")
	m.data.SetDescription("Whether the tablespace is offline (1) or online (0)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbTablespaceIsOffline) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, tablespaceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("tablespace.name", tablespaceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbTablespaceIsOffline) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbTablespaceIsOffline) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbTablespaceIsOffline(cfg MetricConfig) metricNewrelicoracledbTablespaceIsOffline {
	m := metricNewrelicoracledbTablespaceIsOffline{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbTablespaceOfflineCdbDatafiles struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.tablespace.offline_cdb_datafiles metric with initial data.
func (m *metricNewrelicoracledbTablespaceOfflineCdbDatafiles) init() {
	m.data.SetName("newrelicoracledb.tablespace.offline_cdb_datafiles")
	m.data.SetDescription("Count of offline CDB datafiles by tablespace")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbTablespaceOfflineCdbDatafiles) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, tablespaceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("tablespace.name", tablespaceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbTablespaceOfflineCdbDatafiles) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbTablespaceOfflineCdbDatafiles) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbTablespaceOfflineCdbDatafiles(cfg MetricConfig) metricNewrelicoracledbTablespaceOfflineCdbDatafiles {
	m := metricNewrelicoracledbTablespaceOfflineCdbDatafiles{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbTablespaceOfflinePdbDatafiles struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.tablespace.offline_pdb_datafiles metric with initial data.
func (m *metricNewrelicoracledbTablespaceOfflinePdbDatafiles) init() {
	m.data.SetName("newrelicoracledb.tablespace.offline_pdb_datafiles")
	m.data.SetDescription("Count of offline PDB datafiles by tablespace")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbTablespaceOfflinePdbDatafiles) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, tablespaceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("tablespace.name", tablespaceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbTablespaceOfflinePdbDatafiles) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbTablespaceOfflinePdbDatafiles) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbTablespaceOfflinePdbDatafiles(cfg MetricConfig) metricNewrelicoracledbTablespaceOfflinePdbDatafiles {
	m := metricNewrelicoracledbTablespaceOfflinePdbDatafiles{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbTablespacePdbNonWriteMode struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.tablespace.pdb_non_write_mode metric with initial data.
func (m *metricNewrelicoracledbTablespacePdbNonWriteMode) init() {
	m.data.SetName("newrelicoracledb.tablespace.pdb_non_write_mode")
	m.data.SetDescription("Count of PDB datafiles in non-write mode by tablespace")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbTablespacePdbNonWriteMode) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, tablespaceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("tablespace.name", tablespaceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbTablespacePdbNonWriteMode) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbTablespacePdbNonWriteMode) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbTablespacePdbNonWriteMode(cfg MetricConfig) metricNewrelicoracledbTablespacePdbNonWriteMode {
	m := metricNewrelicoracledbTablespacePdbNonWriteMode{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbTablespaceSpaceConsumedBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.tablespace.space_consumed_bytes metric with initial data.
func (m *metricNewrelicoracledbTablespaceSpaceConsumedBytes) init() {
	m.data.SetName("newrelicoracledb.tablespace.space_consumed_bytes")
	m.data.SetDescription("Total bytes consumed by the tablespace")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbTablespaceSpaceConsumedBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, tablespaceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("tablespace.name", tablespaceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbTablespaceSpaceConsumedBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbTablespaceSpaceConsumedBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbTablespaceSpaceConsumedBytes(cfg MetricConfig) metricNewrelicoracledbTablespaceSpaceConsumedBytes {
	m := metricNewrelicoracledbTablespaceSpaceConsumedBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbTablespaceSpaceReservedBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.tablespace.space_reserved_bytes metric with initial data.
func (m *metricNewrelicoracledbTablespaceSpaceReservedBytes) init() {
	m.data.SetName("newrelicoracledb.tablespace.space_reserved_bytes")
	m.data.SetDescription("Total bytes reserved by the tablespace")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbTablespaceSpaceReservedBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, tablespaceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("tablespace.name", tablespaceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbTablespaceSpaceReservedBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbTablespaceSpaceReservedBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbTablespaceSpaceReservedBytes(cfg MetricConfig) metricNewrelicoracledbTablespaceSpaceReservedBytes {
	m := metricNewrelicoracledbTablespaceSpaceReservedBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbTablespaceSpaceUsedPercentage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.tablespace.space_used_percentage metric with initial data.
func (m *metricNewrelicoracledbTablespaceSpaceUsedPercentage) init() {
	m.data.SetName("newrelicoracledb.tablespace.space_used_percentage")
	m.data.SetDescription("Percentage of tablespace space currently used")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbTablespaceSpaceUsedPercentage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, tablespaceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("tablespace.name", tablespaceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbTablespaceSpaceUsedPercentage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbTablespaceSpaceUsedPercentage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbTablespaceSpaceUsedPercentage(cfg MetricConfig) metricNewrelicoracledbTablespaceSpaceUsedPercentage {
	m := metricNewrelicoracledbTablespaceSpaceUsedPercentage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbTablespaceTotalBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.tablespace.total_bytes metric with initial data.
func (m *metricNewrelicoracledbTablespaceTotalBytes) init() {
	m.data.SetName("newrelicoracledb.tablespace.total_bytes")
	m.data.SetDescription("Total bytes in tablespace")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbTablespaceTotalBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, conIDAttributeValue string, tablespaceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("con.id", conIDAttributeValue)
	dp.Attributes().PutStr("tablespace.name", tablespaceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbTablespaceTotalBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbTablespaceTotalBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbTablespaceTotalBytes(cfg MetricConfig) metricNewrelicoracledbTablespaceTotalBytes {
	m := metricNewrelicoracledbTablespaceTotalBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbTablespaceUsedBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.tablespace.used_bytes metric with initial data.
func (m *metricNewrelicoracledbTablespaceUsedBytes) init() {
	m.data.SetName("newrelicoracledb.tablespace.used_bytes")
	m.data.SetDescription("Used bytes in tablespace")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbTablespaceUsedBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, conIDAttributeValue string, tablespaceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("con.id", conIDAttributeValue)
	dp.Attributes().PutStr("tablespace.name", tablespaceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbTablespaceUsedBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbTablespaceUsedBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbTablespaceUsedBytes(cfg MetricConfig) metricNewrelicoracledbTablespaceUsedBytes {
	m := metricNewrelicoracledbTablespaceUsedBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicoracledbTablespaceUsedPercent struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelicoracledb.tablespace.used_percent metric with initial data.
func (m *metricNewrelicoracledbTablespaceUsedPercent) init() {
	m.data.SetName("newrelicoracledb.tablespace.used_percent")
	m.data.SetDescription("Used percentage of tablespace")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicoracledbTablespaceUsedPercent) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, conIDAttributeValue string, tablespaceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("db.instance.name", dbInstanceNameAttributeValue)
	dp.Attributes().PutStr("con.id", conIDAttributeValue)
	dp.Attributes().PutStr("tablespace.name", tablespaceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicoracledbTablespaceUsedPercent) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicoracledbTablespaceUsedPercent) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicoracledbTablespaceUsedPercent(cfg MetricConfig) metricNewrelicoracledbTablespaceUsedPercent {
	m := metricNewrelicoracledbTablespaceUsedPercent{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user config.
type MetricsBuilder struct {
	config                                                                   MetricsBuilderConfig // config of the metrics builder.
	startTime                                                                pcommon.Timestamp    // start time that will be applied to all recorded data points.
	metricsCapacity                                                          int                  // maximum observed number of metrics per resource.
	metricsBuffer                                                            pmetric.Metrics      // accumulates metrics data before emitting.
	buildInfo                                                                component.BuildInfo  // contains version information.
	resourceAttributeIncludeFilter                                           map[string]filter.Filter
	resourceAttributeExcludeFilter                                           map[string]filter.Filter
	metricNewrelicoracledbAsmDiskgroupFreeMb                                 metricNewrelicoracledbAsmDiskgroupFreeMb
	metricNewrelicoracledbAsmDiskgroupOfflineDisks                           metricNewrelicoracledbAsmDiskgroupOfflineDisks
	metricNewrelicoracledbAsmDiskgroupTotalMb                                metricNewrelicoracledbAsmDiskgroupTotalMb
	metricNewrelicoracledbConnectionActiveSessions                           metricNewrelicoracledbConnectionActiveSessions
	metricNewrelicoracledbConnectionBlockingSessions                         metricNewrelicoracledbConnectionBlockingSessions
	metricNewrelicoracledbConnectionBytesReceived                            metricNewrelicoracledbConnectionBytesReceived
	metricNewrelicoracledbConnectionBytesSent                                metricNewrelicoracledbConnectionBytesSent
	metricNewrelicoracledbConnectionCircuits                                 metricNewrelicoracledbConnectionCircuits
	metricNewrelicoracledbConnectionDispatchers                              metricNewrelicoracledbConnectionDispatchers
	metricNewrelicoracledbConnectionExecuteCount                             metricNewrelicoracledbConnectionExecuteCount
	metricNewrelicoracledbConnectionInactiveSessions                         metricNewrelicoracledbConnectionInactiveSessions
	metricNewrelicoracledbConnectionLogonsCumulative                         metricNewrelicoracledbConnectionLogonsCumulative
	metricNewrelicoracledbConnectionLogonsCurrent                            metricNewrelicoracledbConnectionLogonsCurrent
	metricNewrelicoracledbConnectionParseCountHard                           metricNewrelicoracledbConnectionParseCountHard
	metricNewrelicoracledbConnectionParseCountTotal                          metricNewrelicoracledbConnectionParseCountTotal
	metricNewrelicoracledbConnectionResourceCurrentUtilization               metricNewrelicoracledbConnectionResourceCurrentUtilization
	metricNewrelicoracledbConnectionResourceLimit                            metricNewrelicoracledbConnectionResourceLimit
	metricNewrelicoracledbConnectionResourceMaxUtilization                   metricNewrelicoracledbConnectionResourceMaxUtilization
	metricNewrelicoracledbConnectionSessionCPUUsage                          metricNewrelicoracledbConnectionSessionCPUUsage
	metricNewrelicoracledbConnectionSessionIdleTime                          metricNewrelicoracledbConnectionSessionIdleTime
	metricNewrelicoracledbConnectionSessionLogicalReads                      metricNewrelicoracledbConnectionSessionLogicalReads
	metricNewrelicoracledbConnectionSessionPgaMemory                         metricNewrelicoracledbConnectionSessionPgaMemory
	metricNewrelicoracledbConnectionSessionsByStatus                         metricNewrelicoracledbConnectionSessionsByStatus
	metricNewrelicoracledbConnectionSessionsByType                           metricNewrelicoracledbConnectionSessionsByType
	metricNewrelicoracledbConnectionSharedServers                            metricNewrelicoracledbConnectionSharedServers
	metricNewrelicoracledbConnectionSqlnetRoundtrips                         metricNewrelicoracledbConnectionSqlnetRoundtrips
	metricNewrelicoracledbConnectionTotalSessions                            metricNewrelicoracledbConnectionTotalSessions
	metricNewrelicoracledbConnectionUserCommits                              metricNewrelicoracledbConnectionUserCommits
	metricNewrelicoracledbConnectionUserRollbacks                            metricNewrelicoracledbConnectionUserRollbacks
	metricNewrelicoracledbConnectionWaitEventAvgWaitTime                     metricNewrelicoracledbConnectionWaitEventAvgWaitTime
	metricNewrelicoracledbConnectionWaitEventTimeWaited                      metricNewrelicoracledbConnectionWaitEventTimeWaited
	metricNewrelicoracledbConnectionWaitEventTotalWaits                      metricNewrelicoracledbConnectionWaitEventTotalWaits
	metricNewrelicoracledbConnectionWaitEvents                               metricNewrelicoracledbConnectionWaitEvents
	metricNewrelicoracledbContainerRestricted                                metricNewrelicoracledbContainerRestricted
	metricNewrelicoracledbContainerStatus                                    metricNewrelicoracledbContainerStatus
	metricNewrelicoracledbDatafileAutoextensible                             metricNewrelicoracledbDatafileAutoextensible
	metricNewrelicoracledbDatafileSizeBytes                                  metricNewrelicoracledbDatafileSizeBytes
	metricNewrelicoracledbDatafileUsedBytes                                  metricNewrelicoracledbDatafileUsedBytes
	metricNewrelicoracledbDbID                                               metricNewrelicoracledbDbID
	metricNewrelicoracledbDiskBlocksRead                                     metricNewrelicoracledbDiskBlocksRead
	metricNewrelicoracledbDiskBlocksWritten                                  metricNewrelicoracledbDiskBlocksWritten
	metricNewrelicoracledbDiskReadTimeMilliseconds                           metricNewrelicoracledbDiskReadTimeMilliseconds
	metricNewrelicoracledbDiskReads                                          metricNewrelicoracledbDiskReads
	metricNewrelicoracledbDiskWriteTimeMilliseconds                          metricNewrelicoracledbDiskWriteTimeMilliseconds
	metricNewrelicoracledbDiskWrites                                         metricNewrelicoracledbDiskWrites
	metricNewrelicoracledbGlobalName                                         metricNewrelicoracledbGlobalName
	metricNewrelicoracledbLockedAccounts                                     metricNewrelicoracledbLockedAccounts
	metricNewrelicoracledbLongRunningQueries                                 metricNewrelicoracledbLongRunningQueries
	metricNewrelicoracledbMemoryPgaAllocatedBytes                            metricNewrelicoracledbMemoryPgaAllocatedBytes
	metricNewrelicoracledbMemoryPgaFreeableBytes                             metricNewrelicoracledbMemoryPgaFreeableBytes
	metricNewrelicoracledbMemoryPgaInUseBytes                                metricNewrelicoracledbMemoryPgaInUseBytes
	metricNewrelicoracledbMemoryPgaMaxSizeBytes                              metricNewrelicoracledbMemoryPgaMaxSizeBytes
	metricNewrelicoracledbMemorySgaSharedPoolLibraryCacheSharableBytes       metricNewrelicoracledbMemorySgaSharedPoolLibraryCacheSharableBytes
	metricNewrelicoracledbMemorySgaSharedPoolLibraryCacheUserBytes           metricNewrelicoracledbMemorySgaSharedPoolLibraryCacheUserBytes
	metricNewrelicoracledbMemorySgaUgaTotalBytes                             metricNewrelicoracledbMemorySgaUgaTotalBytes
	metricNewrelicoracledbPdbActiveParallelSessions                          metricNewrelicoracledbPdbActiveParallelSessions
	metricNewrelicoracledbPdbActiveSerialSessions                            metricNewrelicoracledbPdbActiveSerialSessions
	metricNewrelicoracledbPdbAverageActiveSessions                           metricNewrelicoracledbPdbAverageActiveSessions
	metricNewrelicoracledbPdbBackgroundCPUUsagePerSecond                     metricNewrelicoracledbPdbBackgroundCPUUsagePerSecond
	metricNewrelicoracledbPdbBackgroundTimePerSecond                         metricNewrelicoracledbPdbBackgroundTimePerSecond
	metricNewrelicoracledbPdbBlockChangesPerSecond                           metricNewrelicoracledbPdbBlockChangesPerSecond
	metricNewrelicoracledbPdbBlockChangesPerTransaction                      metricNewrelicoracledbPdbBlockChangesPerTransaction
	metricNewrelicoracledbPdbCPUTimeRatio                                    metricNewrelicoracledbPdbCPUTimeRatio
	metricNewrelicoracledbPdbCPUUsagePerSecond                               metricNewrelicoracledbPdbCPUUsagePerSecond
	metricNewrelicoracledbPdbCPUUsagePerTransaction                          metricNewrelicoracledbPdbCPUUsagePerTransaction
	metricNewrelicoracledbPdbCurrentLogons                                   metricNewrelicoracledbPdbCurrentLogons
	metricNewrelicoracledbPdbCurrentOpenCursors                              metricNewrelicoracledbPdbCurrentOpenCursors
	metricNewrelicoracledbPdbDbPhysicalReadBytesPerSecond                    metricNewrelicoracledbPdbDbPhysicalReadBytesPerSecond
	metricNewrelicoracledbPdbDbPhysicalReadsPerSecond                        metricNewrelicoracledbPdbDbPhysicalReadsPerSecond
	metricNewrelicoracledbPdbDbPhysicalWriteBytesPerSecond                   metricNewrelicoracledbPdbDbPhysicalWriteBytesPerSecond
	metricNewrelicoracledbPdbDbPhysicalWritesPerSecond                       metricNewrelicoracledbPdbDbPhysicalWritesPerSecond
	metricNewrelicoracledbPdbExecuteWithoutParseRatio                        metricNewrelicoracledbPdbExecuteWithoutParseRatio
	metricNewrelicoracledbPdbExecutionsPerSecond                             metricNewrelicoracledbPdbExecutionsPerSecond
	metricNewrelicoracledbPdbExecutionsPerTransaction                        metricNewrelicoracledbPdbExecutionsPerTransaction
	metricNewrelicoracledbPdbHardParseCountPerSecond                         metricNewrelicoracledbPdbHardParseCountPerSecond
	metricNewrelicoracledbPdbHardParseCountPerTransaction                    metricNewrelicoracledbPdbHardParseCountPerTransaction
	metricNewrelicoracledbPdbLogicalReadsPerSecond                           metricNewrelicoracledbPdbLogicalReadsPerSecond
	metricNewrelicoracledbPdbLogicalReadsPerTransaction                      metricNewrelicoracledbPdbLogicalReadsPerTransaction
	metricNewrelicoracledbPdbLogonsPerSecond                                 metricNewrelicoracledbPdbLogonsPerSecond
	metricNewrelicoracledbPdbLogonsPerTransaction                            metricNewrelicoracledbPdbLogonsPerTransaction
	metricNewrelicoracledbPdbNetworkTrafficBytePerSecond                     metricNewrelicoracledbPdbNetworkTrafficBytePerSecond
	metricNewrelicoracledbPdbOpenCursorsPerSecond                            metricNewrelicoracledbPdbOpenCursorsPerSecond
	metricNewrelicoracledbPdbOpenCursorsPerTransaction                       metricNewrelicoracledbPdbOpenCursorsPerTransaction
	metricNewrelicoracledbPdbOpenMode                                        metricNewrelicoracledbPdbOpenMode
	metricNewrelicoracledbPdbParseFailureCountPerSecond                      metricNewrelicoracledbPdbParseFailureCountPerSecond
	metricNewrelicoracledbPdbPhysicalReadBytesPerSecond                      metricNewrelicoracledbPdbPhysicalReadBytesPerSecond
	metricNewrelicoracledbPdbPhysicalReadsPerTransaction                     metricNewrelicoracledbPdbPhysicalReadsPerTransaction
	metricNewrelicoracledbPdbPhysicalWriteBytesPerSecond                     metricNewrelicoracledbPdbPhysicalWriteBytesPerSecond
	metricNewrelicoracledbPdbPhysicalWritesPerTransaction                    metricNewrelicoracledbPdbPhysicalWritesPerTransaction
	metricNewrelicoracledbPdbRedoGeneratedBytesPerSecond                     metricNewrelicoracledbPdbRedoGeneratedBytesPerSecond
	metricNewrelicoracledbPdbRedoGeneratedBytesPerTransaction                metricNewrelicoracledbPdbRedoGeneratedBytesPerTransaction
	metricNewrelicoracledbPdbResponseTimePerTransaction                      metricNewrelicoracledbPdbResponseTimePerTransaction
	metricNewrelicoracledbPdbSessionCount                                    metricNewrelicoracledbPdbSessionCount
	metricNewrelicoracledbPdbSoftParseRatio                                  metricNewrelicoracledbPdbSoftParseRatio
	metricNewrelicoracledbPdbSQLServiceResponseTime                          metricNewrelicoracledbPdbSQLServiceResponseTime
	metricNewrelicoracledbPdbStatus                                          metricNewrelicoracledbPdbStatus
	metricNewrelicoracledbPdbTotalParseCountPerSecond                        metricNewrelicoracledbPdbTotalParseCountPerSecond
	metricNewrelicoracledbPdbTotalParseCountPerTransaction                   metricNewrelicoracledbPdbTotalParseCountPerTransaction
	metricNewrelicoracledbPdbTotalSizeBytes                                  metricNewrelicoracledbPdbTotalSizeBytes
	metricNewrelicoracledbPdbTransactionsPerSecond                           metricNewrelicoracledbPdbTransactionsPerSecond
	metricNewrelicoracledbPdbUserCallsPerSecond                              metricNewrelicoracledbPdbUserCallsPerSecond
	metricNewrelicoracledbPdbUserCallsPerTransaction                         metricNewrelicoracledbPdbUserCallsPerTransaction
	metricNewrelicoracledbPdbUserCommitsPerSecond                            metricNewrelicoracledbPdbUserCommitsPerSecond
	metricNewrelicoracledbPdbUserCommitsPercentage                           metricNewrelicoracledbPdbUserCommitsPercentage
	metricNewrelicoracledbPdbUserRollbacksPerSecond                          metricNewrelicoracledbPdbUserRollbacksPerSecond
	metricNewrelicoracledbPdbUserRollbacksPercentage                         metricNewrelicoracledbPdbUserRollbacksPercentage
	metricNewrelicoracledbPdbWaitTimeRatio                                   metricNewrelicoracledbPdbWaitTimeRatio
	metricNewrelicoracledbRacInstanceActiveState                             metricNewrelicoracledbRacInstanceActiveState
	metricNewrelicoracledbRacInstanceArchiverStarted                         metricNewrelicoracledbRacInstanceArchiverStarted
	metricNewrelicoracledbRacInstanceDatabaseStatus                          metricNewrelicoracledbRacInstanceDatabaseStatus
	metricNewrelicoracledbRacInstanceLoginsAllowed                           metricNewrelicoracledbRacInstanceLoginsAllowed
	metricNewrelicoracledbRacInstanceStatus                                  metricNewrelicoracledbRacInstanceStatus
	metricNewrelicoracledbRacInstanceUptimeSeconds                           metricNewrelicoracledbRacInstanceUptimeSeconds
	metricNewrelicoracledbRacInstanceVersionInfo                             metricNewrelicoracledbRacInstanceVersionInfo
	metricNewrelicoracledbRacServiceClbConfig                                metricNewrelicoracledbRacServiceClbConfig
	metricNewrelicoracledbRacServiceCreationAgeDays                          metricNewrelicoracledbRacServiceCreationAgeDays
	metricNewrelicoracledbRacServiceFailoverConfig                           metricNewrelicoracledbRacServiceFailoverConfig
	metricNewrelicoracledbRacServiceFailoverDelaySeconds                     metricNewrelicoracledbRacServiceFailoverDelaySeconds
	metricNewrelicoracledbRacServiceFailoverRetries                          metricNewrelicoracledbRacServiceFailoverRetries
	metricNewrelicoracledbRacServiceInstanceID                               metricNewrelicoracledbRacServiceInstanceID
	metricNewrelicoracledbRacServiceNetworkConfig                            metricNewrelicoracledbRacServiceNetworkConfig
	metricNewrelicoracledbRacTotalWaits                                      metricNewrelicoracledbRacTotalWaits
	metricNewrelicoracledbRacWaitTime                                        metricNewrelicoracledbRacWaitTime
	metricNewrelicoracledbRedoLogParallelWriteWaits                          metricNewrelicoracledbRedoLogParallelWriteWaits
	metricNewrelicoracledbRedoLogSwitchArchivingNeededWaits                  metricNewrelicoracledbRedoLogSwitchArchivingNeededWaits
	metricNewrelicoracledbRedoLogSwitchCheckpointIncompleteWaits             metricNewrelicoracledbRedoLogSwitchCheckpointIncompleteWaits
	metricNewrelicoracledbRedoLogSwitchCompletionWaits                       metricNewrelicoracledbRedoLogSwitchCompletionWaits
	metricNewrelicoracledbRollbackSegmentsGets                               metricNewrelicoracledbRollbackSegmentsGets
	metricNewrelicoracledbRollbackSegmentsWaitRatio                          metricNewrelicoracledbRollbackSegmentsWaitRatio
	metricNewrelicoracledbRollbackSegmentsWaits                              metricNewrelicoracledbRollbackSegmentsWaits
	metricNewrelicoracledbServiceCount                                       metricNewrelicoracledbServiceCount
	metricNewrelicoracledbServiceStatus                                      metricNewrelicoracledbServiceStatus
	metricNewrelicoracledbSessionsCount                                      metricNewrelicoracledbSessionsCount
	metricNewrelicoracledbSgaBufferBusyWaits                                 metricNewrelicoracledbSgaBufferBusyWaits
	metricNewrelicoracledbSgaFixedSizeBytes                                  metricNewrelicoracledbSgaFixedSizeBytes
	metricNewrelicoracledbSgaFreeBufferInspectedWaits                        metricNewrelicoracledbSgaFreeBufferInspectedWaits
	metricNewrelicoracledbSgaFreeBufferWaits                                 metricNewrelicoracledbSgaFreeBufferWaits
	metricNewrelicoracledbSgaHitRatio                                        metricNewrelicoracledbSgaHitRatio
	metricNewrelicoracledbSgaLogAllocationRetriesRatio                       metricNewrelicoracledbSgaLogAllocationRetriesRatio
	metricNewrelicoracledbSgaLogBufferRedoAllocationRetries                  metricNewrelicoracledbSgaLogBufferRedoAllocationRetries
	metricNewrelicoracledbSgaLogBufferRedoEntries                            metricNewrelicoracledbSgaLogBufferRedoEntries
	metricNewrelicoracledbSgaLogBufferSpaceWaits                             metricNewrelicoracledbSgaLogBufferSpaceWaits
	metricNewrelicoracledbSgaRedoBuffersBytes                                metricNewrelicoracledbSgaRedoBuffersBytes
	metricNewrelicoracledbSgaSharedPoolDictCacheMissRatio                    metricNewrelicoracledbSgaSharedPoolDictCacheMissRatio
	metricNewrelicoracledbSgaSharedPoolLibraryCacheHitRatio                  metricNewrelicoracledbSgaSharedPoolLibraryCacheHitRatio
	metricNewrelicoracledbSgaSharedPoolLibraryCacheReloadRatio               metricNewrelicoracledbSgaSharedPoolLibraryCacheReloadRatio
	metricNewrelicoracledbSortsDisk                                          metricNewrelicoracledbSortsDisk
	metricNewrelicoracledbSortsMemory                                        metricNewrelicoracledbSortsMemory
	metricNewrelicoracledbSystemActiveParallelSessions                       metricNewrelicoracledbSystemActiveParallelSessions
	metricNewrelicoracledbSystemActiveSerialSessions                         metricNewrelicoracledbSystemActiveSerialSessions
	metricNewrelicoracledbSystemAverageActiveSessions                        metricNewrelicoracledbSystemAverageActiveSessions
	metricNewrelicoracledbSystemBackgroundCheckpointsPerSecond               metricNewrelicoracledbSystemBackgroundCheckpointsPerSecond
	metricNewrelicoracledbSystemBackgroundCPUUsagePerSecond                  metricNewrelicoracledbSystemBackgroundCPUUsagePerSecond
	metricNewrelicoracledbSystemBackgroundTimePerSecond                      metricNewrelicoracledbSystemBackgroundTimePerSecond
	metricNewrelicoracledbSystemBranchNodeSplitsPerSecond                    metricNewrelicoracledbSystemBranchNodeSplitsPerSecond
	metricNewrelicoracledbSystemBranchNodeSplitsPerTransaction               metricNewrelicoracledbSystemBranchNodeSplitsPerTransaction
	metricNewrelicoracledbSystemBufferCacheHitRatio                          metricNewrelicoracledbSystemBufferCacheHitRatio
	metricNewrelicoracledbSystemCapturedUserCalls                            metricNewrelicoracledbSystemCapturedUserCalls
	metricNewrelicoracledbSystemConsistentReadChangesPerSecond               metricNewrelicoracledbSystemConsistentReadChangesPerSecond
	metricNewrelicoracledbSystemConsistentReadChangesPerTransaction          metricNewrelicoracledbSystemConsistentReadChangesPerTransaction
	metricNewrelicoracledbSystemConsistentReadGetsPerSecond                  metricNewrelicoracledbSystemConsistentReadGetsPerSecond
	metricNewrelicoracledbSystemConsistentReadGetsPerTransaction             metricNewrelicoracledbSystemConsistentReadGetsPerTransaction
	metricNewrelicoracledbSystemCPUUsagePerSecond                            metricNewrelicoracledbSystemCPUUsagePerSecond
	metricNewrelicoracledbSystemCPUUsagePerTransaction                       metricNewrelicoracledbSystemCPUUsagePerTransaction
	metricNewrelicoracledbSystemCrBlocksCreatedPerSecond                     metricNewrelicoracledbSystemCrBlocksCreatedPerSecond
	metricNewrelicoracledbSystemCrBlocksCreatedPerTransaction                metricNewrelicoracledbSystemCrBlocksCreatedPerTransaction
	metricNewrelicoracledbSystemCrUndoRecordsAppliedPerSecond                metricNewrelicoracledbSystemCrUndoRecordsAppliedPerSecond
	metricNewrelicoracledbSystemCrUndoRecordsAppliedPerTransaction           metricNewrelicoracledbSystemCrUndoRecordsAppliedPerTransaction
	metricNewrelicoracledbSystemCurrentLogonsCount                           metricNewrelicoracledbSystemCurrentLogonsCount
	metricNewrelicoracledbSystemCurrentOpenCursorsCount                      metricNewrelicoracledbSystemCurrentOpenCursorsCount
	metricNewrelicoracledbSystemCurrentOsLoad                                metricNewrelicoracledbSystemCurrentOsLoad
	metricNewrelicoracledbSystemCursorCacheHitRatio                          metricNewrelicoracledbSystemCursorCacheHitRatio
	metricNewrelicoracledbSystemDatabaseCPUTimeRatio                         metricNewrelicoracledbSystemDatabaseCPUTimeRatio
	metricNewrelicoracledbSystemDatabaseTimePerSecond                        metricNewrelicoracledbSystemDatabaseTimePerSecond
	metricNewrelicoracledbSystemDatabaseWaitTimeRatio                        metricNewrelicoracledbSystemDatabaseWaitTimeRatio
	metricNewrelicoracledbSystemDbBlockChangesPerSecond                      metricNewrelicoracledbSystemDbBlockChangesPerSecond
	metricNewrelicoracledbSystemDbBlockChangesPerTransaction                 metricNewrelicoracledbSystemDbBlockChangesPerTransaction
	metricNewrelicoracledbSystemDbBlockChangesPerUserCall                    metricNewrelicoracledbSystemDbBlockChangesPerUserCall
	metricNewrelicoracledbSystemDbBlockGetsPerSecond                         metricNewrelicoracledbSystemDbBlockGetsPerSecond
	metricNewrelicoracledbSystemDbBlockGetsPerTransaction                    metricNewrelicoracledbSystemDbBlockGetsPerTransaction
	metricNewrelicoracledbSystemDbBlockGetsPerUserCall                       metricNewrelicoracledbSystemDbBlockGetsPerUserCall
	metricNewrelicoracledbSystemDbwrCheckpointsPerSecond                     metricNewrelicoracledbSystemDbwrCheckpointsPerSecond
	metricNewrelicoracledbSystemDiskSortPerSecond                            metricNewrelicoracledbSystemDiskSortPerSecond
	metricNewrelicoracledbSystemDiskSortPerTransaction                       metricNewrelicoracledbSystemDiskSortPerTransaction
	metricNewrelicoracledbSystemEnqueueDeadlocksPerSecond                    metricNewrelicoracledbSystemEnqueueDeadlocksPerSecond
	metricNewrelicoracledbSystemEnqueueDeadlocksPerTransaction               metricNewrelicoracledbSystemEnqueueDeadlocksPerTransaction
	metricNewrelicoracledbSystemEnqueueRequestsPerSecond                     metricNewrelicoracledbSystemEnqueueRequestsPerSecond
	metricNewrelicoracledbSystemEnqueueRequestsPerTransaction                metricNewrelicoracledbSystemEnqueueRequestsPerTransaction
	metricNewrelicoracledbSystemEnqueueTimeoutsPerSecond                     metricNewrelicoracledbSystemEnqueueTimeoutsPerSecond
	metricNewrelicoracledbSystemEnqueueTimeoutsPerTransaction                metricNewrelicoracledbSystemEnqueueTimeoutsPerTransaction
	metricNewrelicoracledbSystemEnqueueWaitsPerSecond                        metricNewrelicoracledbSystemEnqueueWaitsPerSecond
	metricNewrelicoracledbSystemEnqueueWaitsPerTransaction                   metricNewrelicoracledbSystemEnqueueWaitsPerTransaction
	metricNewrelicoracledbSystemExecuteWithoutParseRatio                     metricNewrelicoracledbSystemExecuteWithoutParseRatio
	metricNewrelicoracledbSystemExecutionsPerSecond                          metricNewrelicoracledbSystemExecutionsPerSecond
	metricNewrelicoracledbSystemExecutionsPerTransaction                     metricNewrelicoracledbSystemExecutionsPerTransaction
	metricNewrelicoracledbSystemExecutionsPerUserCall                        metricNewrelicoracledbSystemExecutionsPerUserCall
	metricNewrelicoracledbSystemFullIndexScansPerSecond                      metricNewrelicoracledbSystemFullIndexScansPerSecond
	metricNewrelicoracledbSystemFullIndexScansPerTransaction                 metricNewrelicoracledbSystemFullIndexScansPerTransaction
	metricNewrelicoracledbSystemGcCrBlockReceivedPerSecond                   metricNewrelicoracledbSystemGcCrBlockReceivedPerSecond
	metricNewrelicoracledbSystemGcCrBlockReceivedPerTransaction              metricNewrelicoracledbSystemGcCrBlockReceivedPerTransaction
	metricNewrelicoracledbSystemGcCurrentBlockReceivedPerSecond              metricNewrelicoracledbSystemGcCurrentBlockReceivedPerSecond
	metricNewrelicoracledbSystemGcCurrentBlockReceivedPerTransaction         metricNewrelicoracledbSystemGcCurrentBlockReceivedPerTransaction
	metricNewrelicoracledbSystemGlobalCacheAverageCrGetTime                  metricNewrelicoracledbSystemGlobalCacheAverageCrGetTime
	metricNewrelicoracledbSystemGlobalCacheAverageCurrentGetTime             metricNewrelicoracledbSystemGlobalCacheAverageCurrentGetTime
	metricNewrelicoracledbSystemGlobalCacheBlocksCorrupted                   metricNewrelicoracledbSystemGlobalCacheBlocksCorrupted
	metricNewrelicoracledbSystemGlobalCacheBlocksLost                        metricNewrelicoracledbSystemGlobalCacheBlocksLost
	metricNewrelicoracledbSystemHardParseCountPerSecond                      metricNewrelicoracledbSystemHardParseCountPerSecond
	metricNewrelicoracledbSystemHardParseCountPerTransaction                 metricNewrelicoracledbSystemHardParseCountPerTransaction
	metricNewrelicoracledbSystemHostCPUUsagePerSecond                        metricNewrelicoracledbSystemHostCPUUsagePerSecond
	metricNewrelicoracledbSystemHostCPUUtilization                           metricNewrelicoracledbSystemHostCPUUtilization
	metricNewrelicoracledbSystemIoMegabytesPerSecond                         metricNewrelicoracledbSystemIoMegabytesPerSecond
	metricNewrelicoracledbSystemIoRequestsPerSecond                          metricNewrelicoracledbSystemIoRequestsPerSecond
	metricNewrelicoracledbSystemLeafNodeSplitsPerSecond                      metricNewrelicoracledbSystemLeafNodeSplitsPerSecond
	metricNewrelicoracledbSystemLeafNodeSplitsPerTransaction                 metricNewrelicoracledbSystemLeafNodeSplitsPerTransaction
	metricNewrelicoracledbSystemLibraryCacheHitRatio                         metricNewrelicoracledbSystemLibraryCacheHitRatio
	metricNewrelicoracledbSystemLibraryCacheMissRatio                        metricNewrelicoracledbSystemLibraryCacheMissRatio
	metricNewrelicoracledbSystemLogicalReadsPerSecond                        metricNewrelicoracledbSystemLogicalReadsPerSecond
	metricNewrelicoracledbSystemLogicalReadsPerTransaction                   metricNewrelicoracledbSystemLogicalReadsPerTransaction
	metricNewrelicoracledbSystemLogicalReadsPerUserCall                      metricNewrelicoracledbSystemLogicalReadsPerUserCall
	metricNewrelicoracledbSystemLogonsPerSecond                              metricNewrelicoracledbSystemLogonsPerSecond
	metricNewrelicoracledbSystemLogonsPerTransaction                         metricNewrelicoracledbSystemLogonsPerTransaction
	metricNewrelicoracledbSystemLongTableScansPerSecond                      metricNewrelicoracledbSystemLongTableScansPerSecond
	metricNewrelicoracledbSystemLongTableScansPerTransaction                 metricNewrelicoracledbSystemLongTableScansPerTransaction
	metricNewrelicoracledbSystemMemorySortsRatio                             metricNewrelicoracledbSystemMemorySortsRatio
	metricNewrelicoracledbSystemNetworkTrafficVolumePerSecond                metricNewrelicoracledbSystemNetworkTrafficVolumePerSecond
	metricNewrelicoracledbSystemOpenCursorsPerSecond                         metricNewrelicoracledbSystemOpenCursorsPerSecond
	metricNewrelicoracledbSystemOpenCursorsPerTransaction                    metricNewrelicoracledbSystemOpenCursorsPerTransaction
	metricNewrelicoracledbSystemParseFailureCountPerSecond                   metricNewrelicoracledbSystemParseFailureCountPerSecond
	metricNewrelicoracledbSystemParseFailureCountPerTransaction              metricNewrelicoracledbSystemParseFailureCountPerTransaction
	metricNewrelicoracledbSystemPgaCacheHitPercentage                        metricNewrelicoracledbSystemPgaCacheHitPercentage
	metricNewrelicoracledbSystemPhysicalLobsReadsPerSecond                   metricNewrelicoracledbSystemPhysicalLobsReadsPerSecond
	metricNewrelicoracledbSystemPhysicalLobsReadsPerTransaction              metricNewrelicoracledbSystemPhysicalLobsReadsPerTransaction
	metricNewrelicoracledbSystemPhysicalLobsWritesPerSecond                  metricNewrelicoracledbSystemPhysicalLobsWritesPerSecond
	metricNewrelicoracledbSystemPhysicalLobsWritesPerTransaction             metricNewrelicoracledbSystemPhysicalLobsWritesPerTransaction
	metricNewrelicoracledbSystemPhysicalReadBytesPerSecond                   metricNewrelicoracledbSystemPhysicalReadBytesPerSecond
	metricNewrelicoracledbSystemPhysicalReadIoRequestsPerSecond              metricNewrelicoracledbSystemPhysicalReadIoRequestsPerSecond
	metricNewrelicoracledbSystemPhysicalReadTotalBytesPerSecond              metricNewrelicoracledbSystemPhysicalReadTotalBytesPerSecond
	metricNewrelicoracledbSystemPhysicalReadTotalIoRequestsPerSecond         metricNewrelicoracledbSystemPhysicalReadTotalIoRequestsPerSecond
	metricNewrelicoracledbSystemPhysicalReadsDirectPerSecond                 metricNewrelicoracledbSystemPhysicalReadsDirectPerSecond
	metricNewrelicoracledbSystemPhysicalReadsDirectPerTransaction            metricNewrelicoracledbSystemPhysicalReadsDirectPerTransaction
	metricNewrelicoracledbSystemPhysicalReadsPerSecond                       metricNewrelicoracledbSystemPhysicalReadsPerSecond
	metricNewrelicoracledbSystemPhysicalReadsPerTransaction                  metricNewrelicoracledbSystemPhysicalReadsPerTransaction
	metricNewrelicoracledbSystemPhysicalWriteBytesPerSecond                  metricNewrelicoracledbSystemPhysicalWriteBytesPerSecond
	metricNewrelicoracledbSystemPhysicalWriteIoRequestsPerSecond             metricNewrelicoracledbSystemPhysicalWriteIoRequestsPerSecond
	metricNewrelicoracledbSystemPhysicalWriteTotalBytesPerSecond             metricNewrelicoracledbSystemPhysicalWriteTotalBytesPerSecond
	metricNewrelicoracledbSystemPhysicalWriteTotalIoRequestsPerSecond        metricNewrelicoracledbSystemPhysicalWriteTotalIoRequestsPerSecond
	metricNewrelicoracledbSystemPhysicalWritesDirectPerSecond                metricNewrelicoracledbSystemPhysicalWritesDirectPerSecond
	metricNewrelicoracledbSystemPhysicalWritesDirectPerTransaction           metricNewrelicoracledbSystemPhysicalWritesDirectPerTransaction
	metricNewrelicoracledbSystemPhysicalWritesPerSecond                      metricNewrelicoracledbSystemPhysicalWritesPerSecond
	metricNewrelicoracledbSystemPhysicalWritesPerTransaction                 metricNewrelicoracledbSystemPhysicalWritesPerTransaction
	metricNewrelicoracledbSystemProcessLimitPercentage                       metricNewrelicoracledbSystemProcessLimitPercentage
	metricNewrelicoracledbSystemRecursiveCallsPerSecond                      metricNewrelicoracledbSystemRecursiveCallsPerSecond
	metricNewrelicoracledbSystemRecursiveCallsPerTransaction                 metricNewrelicoracledbSystemRecursiveCallsPerTransaction
	metricNewrelicoracledbSystemRedoAllocationHitRatio                       metricNewrelicoracledbSystemRedoAllocationHitRatio
	metricNewrelicoracledbSystemRedoGeneratedBytesPerSecond                  metricNewrelicoracledbSystemRedoGeneratedBytesPerSecond
	metricNewrelicoracledbSystemRedoGeneratedBytesPerTransaction             metricNewrelicoracledbSystemRedoGeneratedBytesPerTransaction
	metricNewrelicoracledbSystemRedoWritesPerSecond                          metricNewrelicoracledbSystemRedoWritesPerSecond
	metricNewrelicoracledbSystemRedoWritesPerTransaction                     metricNewrelicoracledbSystemRedoWritesPerTransaction
	metricNewrelicoracledbSystemResponseTimePerTransaction                   metricNewrelicoracledbSystemResponseTimePerTransaction
	metricNewrelicoracledbSystemRowCacheHitRatio                             metricNewrelicoracledbSystemRowCacheHitRatio
	metricNewrelicoracledbSystemRowCacheMissRatio                            metricNewrelicoracledbSystemRowCacheMissRatio
	metricNewrelicoracledbSystemRowsPerSort                                  metricNewrelicoracledbSystemRowsPerSort
	metricNewrelicoracledbSystemSessionCount                                 metricNewrelicoracledbSystemSessionCount
	metricNewrelicoracledbSystemSessionLimitPercentage                       metricNewrelicoracledbSystemSessionLimitPercentage
	metricNewrelicoracledbSystemSharedPoolFreePercentage                     metricNewrelicoracledbSystemSharedPoolFreePercentage
	metricNewrelicoracledbSystemSoftParseRatio                               metricNewrelicoracledbSystemSoftParseRatio
	metricNewrelicoracledbSystemSQLServiceResponseTime                       metricNewrelicoracledbSystemSQLServiceResponseTime
	metricNewrelicoracledbSystemStreamsPoolUsagePercentage                   metricNewrelicoracledbSystemStreamsPoolUsagePercentage
	metricNewrelicoracledbSystemTempSpaceUsed                                metricNewrelicoracledbSystemTempSpaceUsed
	metricNewrelicoracledbSystemTotalIndexScansPerSecond                     metricNewrelicoracledbSystemTotalIndexScansPerSecond
	metricNewrelicoracledbSystemTotalIndexScansPerTransaction                metricNewrelicoracledbSystemTotalIndexScansPerTransaction
	metricNewrelicoracledbSystemTotalParseCountPerSecond                     metricNewrelicoracledbSystemTotalParseCountPerSecond
	metricNewrelicoracledbSystemTotalParseCountPerTransaction                metricNewrelicoracledbSystemTotalParseCountPerTransaction
	metricNewrelicoracledbSystemTotalSortsPerUserCall                        metricNewrelicoracledbSystemTotalSortsPerUserCall
	metricNewrelicoracledbSystemTotalTableScansPerSecond                     metricNewrelicoracledbSystemTotalTableScansPerSecond
	metricNewrelicoracledbSystemTotalTableScansPerTransaction                metricNewrelicoracledbSystemTotalTableScansPerTransaction
	metricNewrelicoracledbSystemTotalTableScansPerUserCall                   metricNewrelicoracledbSystemTotalTableScansPerUserCall
	metricNewrelicoracledbSystemTransactionsPerLogon                         metricNewrelicoracledbSystemTransactionsPerLogon
	metricNewrelicoracledbSystemTransactionsPerSecond                        metricNewrelicoracledbSystemTransactionsPerSecond
	metricNewrelicoracledbSystemUserCallsPerSecond                           metricNewrelicoracledbSystemUserCallsPerSecond
	metricNewrelicoracledbSystemUserCallsPerTransaction                      metricNewrelicoracledbSystemUserCallsPerTransaction
	metricNewrelicoracledbSystemUserCallsRatio                               metricNewrelicoracledbSystemUserCallsRatio
	metricNewrelicoracledbSystemUserCommitsPerSecond                         metricNewrelicoracledbSystemUserCommitsPerSecond
	metricNewrelicoracledbSystemUserCommitsPercentage                        metricNewrelicoracledbSystemUserCommitsPercentage
	metricNewrelicoracledbSystemUserLimitPercentage                          metricNewrelicoracledbSystemUserLimitPercentage
	metricNewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerSecond      metricNewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerSecond
	metricNewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerTransaction metricNewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerTransaction
	metricNewrelicoracledbSystemUserRollbacksPerSecond                       metricNewrelicoracledbSystemUserRollbacksPerSecond
	metricNewrelicoracledbSystemUserRollbacksPercentage                      metricNewrelicoracledbSystemUserRollbacksPercentage
	metricNewrelicoracledbTablespaceDbID                                     metricNewrelicoracledbTablespaceDbID
	metricNewrelicoracledbTablespaceGlobalName                               metricNewrelicoracledbTablespaceGlobalName
	metricNewrelicoracledbTablespaceIsOffline                                metricNewrelicoracledbTablespaceIsOffline
	metricNewrelicoracledbTablespaceOfflineCdbDatafiles                      metricNewrelicoracledbTablespaceOfflineCdbDatafiles
	metricNewrelicoracledbTablespaceOfflinePdbDatafiles                      metricNewrelicoracledbTablespaceOfflinePdbDatafiles
	metricNewrelicoracledbTablespacePdbNonWriteMode                          metricNewrelicoracledbTablespacePdbNonWriteMode
	metricNewrelicoracledbTablespaceSpaceConsumedBytes                       metricNewrelicoracledbTablespaceSpaceConsumedBytes
	metricNewrelicoracledbTablespaceSpaceReservedBytes                       metricNewrelicoracledbTablespaceSpaceReservedBytes
	metricNewrelicoracledbTablespaceSpaceUsedPercentage                      metricNewrelicoracledbTablespaceSpaceUsedPercentage
	metricNewrelicoracledbTablespaceTotalBytes                               metricNewrelicoracledbTablespaceTotalBytes
	metricNewrelicoracledbTablespaceUsedBytes                                metricNewrelicoracledbTablespaceUsedBytes
	metricNewrelicoracledbTablespaceUsedPercent                              metricNewrelicoracledbTablespaceUsedPercent
}

// MetricBuilderOption applies changes to default metrics builder.
type MetricBuilderOption interface {
	apply(*MetricsBuilder)
}

type metricBuilderOptionFunc func(mb *MetricsBuilder)

func (mbof metricBuilderOptionFunc) apply(mb *MetricsBuilder) {
	mbof(mb)
}

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) MetricBuilderOption {
	return metricBuilderOptionFunc(func(mb *MetricsBuilder) {
		mb.startTime = startTime
	})
}
func NewMetricsBuilder(mbc MetricsBuilderConfig, settings receiver.Settings, options ...MetricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		config:                                   mbc,
		startTime:                                pcommon.NewTimestampFromTime(time.Now()),
		metricsBuffer:                            pmetric.NewMetrics(),
		buildInfo:                                settings.BuildInfo,
		metricNewrelicoracledbAsmDiskgroupFreeMb: newMetricNewrelicoracledbAsmDiskgroupFreeMb(mbc.Metrics.NewrelicoracledbAsmDiskgroupFreeMb),
		metricNewrelicoracledbAsmDiskgroupOfflineDisks:                           newMetricNewrelicoracledbAsmDiskgroupOfflineDisks(mbc.Metrics.NewrelicoracledbAsmDiskgroupOfflineDisks),
		metricNewrelicoracledbAsmDiskgroupTotalMb:                                newMetricNewrelicoracledbAsmDiskgroupTotalMb(mbc.Metrics.NewrelicoracledbAsmDiskgroupTotalMb),
		metricNewrelicoracledbConnectionActiveSessions:                           newMetricNewrelicoracledbConnectionActiveSessions(mbc.Metrics.NewrelicoracledbConnectionActiveSessions),
		metricNewrelicoracledbConnectionBlockingSessions:                         newMetricNewrelicoracledbConnectionBlockingSessions(mbc.Metrics.NewrelicoracledbConnectionBlockingSessions),
		metricNewrelicoracledbConnectionBytesReceived:                            newMetricNewrelicoracledbConnectionBytesReceived(mbc.Metrics.NewrelicoracledbConnectionBytesReceived),
		metricNewrelicoracledbConnectionBytesSent:                                newMetricNewrelicoracledbConnectionBytesSent(mbc.Metrics.NewrelicoracledbConnectionBytesSent),
		metricNewrelicoracledbConnectionCircuits:                                 newMetricNewrelicoracledbConnectionCircuits(mbc.Metrics.NewrelicoracledbConnectionCircuits),
		metricNewrelicoracledbConnectionDispatchers:                              newMetricNewrelicoracledbConnectionDispatchers(mbc.Metrics.NewrelicoracledbConnectionDispatchers),
		metricNewrelicoracledbConnectionExecuteCount:                             newMetricNewrelicoracledbConnectionExecuteCount(mbc.Metrics.NewrelicoracledbConnectionExecuteCount),
		metricNewrelicoracledbConnectionInactiveSessions:                         newMetricNewrelicoracledbConnectionInactiveSessions(mbc.Metrics.NewrelicoracledbConnectionInactiveSessions),
		metricNewrelicoracledbConnectionLogonsCumulative:                         newMetricNewrelicoracledbConnectionLogonsCumulative(mbc.Metrics.NewrelicoracledbConnectionLogonsCumulative),
		metricNewrelicoracledbConnectionLogonsCurrent:                            newMetricNewrelicoracledbConnectionLogonsCurrent(mbc.Metrics.NewrelicoracledbConnectionLogonsCurrent),
		metricNewrelicoracledbConnectionParseCountHard:                           newMetricNewrelicoracledbConnectionParseCountHard(mbc.Metrics.NewrelicoracledbConnectionParseCountHard),
		metricNewrelicoracledbConnectionParseCountTotal:                          newMetricNewrelicoracledbConnectionParseCountTotal(mbc.Metrics.NewrelicoracledbConnectionParseCountTotal),
		metricNewrelicoracledbConnectionResourceCurrentUtilization:               newMetricNewrelicoracledbConnectionResourceCurrentUtilization(mbc.Metrics.NewrelicoracledbConnectionResourceCurrentUtilization),
		metricNewrelicoracledbConnectionResourceLimit:                            newMetricNewrelicoracledbConnectionResourceLimit(mbc.Metrics.NewrelicoracledbConnectionResourceLimit),
		metricNewrelicoracledbConnectionResourceMaxUtilization:                   newMetricNewrelicoracledbConnectionResourceMaxUtilization(mbc.Metrics.NewrelicoracledbConnectionResourceMaxUtilization),
		metricNewrelicoracledbConnectionSessionCPUUsage:                          newMetricNewrelicoracledbConnectionSessionCPUUsage(mbc.Metrics.NewrelicoracledbConnectionSessionCPUUsage),
		metricNewrelicoracledbConnectionSessionIdleTime:                          newMetricNewrelicoracledbConnectionSessionIdleTime(mbc.Metrics.NewrelicoracledbConnectionSessionIdleTime),
		metricNewrelicoracledbConnectionSessionLogicalReads:                      newMetricNewrelicoracledbConnectionSessionLogicalReads(mbc.Metrics.NewrelicoracledbConnectionSessionLogicalReads),
		metricNewrelicoracledbConnectionSessionPgaMemory:                         newMetricNewrelicoracledbConnectionSessionPgaMemory(mbc.Metrics.NewrelicoracledbConnectionSessionPgaMemory),
		metricNewrelicoracledbConnectionSessionsByStatus:                         newMetricNewrelicoracledbConnectionSessionsByStatus(mbc.Metrics.NewrelicoracledbConnectionSessionsByStatus),
		metricNewrelicoracledbConnectionSessionsByType:                           newMetricNewrelicoracledbConnectionSessionsByType(mbc.Metrics.NewrelicoracledbConnectionSessionsByType),
		metricNewrelicoracledbConnectionSharedServers:                            newMetricNewrelicoracledbConnectionSharedServers(mbc.Metrics.NewrelicoracledbConnectionSharedServers),
		metricNewrelicoracledbConnectionSqlnetRoundtrips:                         newMetricNewrelicoracledbConnectionSqlnetRoundtrips(mbc.Metrics.NewrelicoracledbConnectionSqlnetRoundtrips),
		metricNewrelicoracledbConnectionTotalSessions:                            newMetricNewrelicoracledbConnectionTotalSessions(mbc.Metrics.NewrelicoracledbConnectionTotalSessions),
		metricNewrelicoracledbConnectionUserCommits:                              newMetricNewrelicoracledbConnectionUserCommits(mbc.Metrics.NewrelicoracledbConnectionUserCommits),
		metricNewrelicoracledbConnectionUserRollbacks:                            newMetricNewrelicoracledbConnectionUserRollbacks(mbc.Metrics.NewrelicoracledbConnectionUserRollbacks),
		metricNewrelicoracledbConnectionWaitEventAvgWaitTime:                     newMetricNewrelicoracledbConnectionWaitEventAvgWaitTime(mbc.Metrics.NewrelicoracledbConnectionWaitEventAvgWaitTime),
		metricNewrelicoracledbConnectionWaitEventTimeWaited:                      newMetricNewrelicoracledbConnectionWaitEventTimeWaited(mbc.Metrics.NewrelicoracledbConnectionWaitEventTimeWaited),
		metricNewrelicoracledbConnectionWaitEventTotalWaits:                      newMetricNewrelicoracledbConnectionWaitEventTotalWaits(mbc.Metrics.NewrelicoracledbConnectionWaitEventTotalWaits),
		metricNewrelicoracledbConnectionWaitEvents:                               newMetricNewrelicoracledbConnectionWaitEvents(mbc.Metrics.NewrelicoracledbConnectionWaitEvents),
		metricNewrelicoracledbContainerRestricted:                                newMetricNewrelicoracledbContainerRestricted(mbc.Metrics.NewrelicoracledbContainerRestricted),
		metricNewrelicoracledbContainerStatus:                                    newMetricNewrelicoracledbContainerStatus(mbc.Metrics.NewrelicoracledbContainerStatus),
		metricNewrelicoracledbDatafileAutoextensible:                             newMetricNewrelicoracledbDatafileAutoextensible(mbc.Metrics.NewrelicoracledbDatafileAutoextensible),
		metricNewrelicoracledbDatafileSizeBytes:                                  newMetricNewrelicoracledbDatafileSizeBytes(mbc.Metrics.NewrelicoracledbDatafileSizeBytes),
		metricNewrelicoracledbDatafileUsedBytes:                                  newMetricNewrelicoracledbDatafileUsedBytes(mbc.Metrics.NewrelicoracledbDatafileUsedBytes),
		metricNewrelicoracledbDbID:                                               newMetricNewrelicoracledbDbID(mbc.Metrics.NewrelicoracledbDbID),
		metricNewrelicoracledbDiskBlocksRead:                                     newMetricNewrelicoracledbDiskBlocksRead(mbc.Metrics.NewrelicoracledbDiskBlocksRead),
		metricNewrelicoracledbDiskBlocksWritten:                                  newMetricNewrelicoracledbDiskBlocksWritten(mbc.Metrics.NewrelicoracledbDiskBlocksWritten),
		metricNewrelicoracledbDiskReadTimeMilliseconds:                           newMetricNewrelicoracledbDiskReadTimeMilliseconds(mbc.Metrics.NewrelicoracledbDiskReadTimeMilliseconds),
		metricNewrelicoracledbDiskReads:                                          newMetricNewrelicoracledbDiskReads(mbc.Metrics.NewrelicoracledbDiskReads),
		metricNewrelicoracledbDiskWriteTimeMilliseconds:                          newMetricNewrelicoracledbDiskWriteTimeMilliseconds(mbc.Metrics.NewrelicoracledbDiskWriteTimeMilliseconds),
		metricNewrelicoracledbDiskWrites:                                         newMetricNewrelicoracledbDiskWrites(mbc.Metrics.NewrelicoracledbDiskWrites),
		metricNewrelicoracledbGlobalName:                                         newMetricNewrelicoracledbGlobalName(mbc.Metrics.NewrelicoracledbGlobalName),
		metricNewrelicoracledbLockedAccounts:                                     newMetricNewrelicoracledbLockedAccounts(mbc.Metrics.NewrelicoracledbLockedAccounts),
		metricNewrelicoracledbLongRunningQueries:                                 newMetricNewrelicoracledbLongRunningQueries(mbc.Metrics.NewrelicoracledbLongRunningQueries),
		metricNewrelicoracledbMemoryPgaAllocatedBytes:                            newMetricNewrelicoracledbMemoryPgaAllocatedBytes(mbc.Metrics.NewrelicoracledbMemoryPgaAllocatedBytes),
		metricNewrelicoracledbMemoryPgaFreeableBytes:                             newMetricNewrelicoracledbMemoryPgaFreeableBytes(mbc.Metrics.NewrelicoracledbMemoryPgaFreeableBytes),
		metricNewrelicoracledbMemoryPgaInUseBytes:                                newMetricNewrelicoracledbMemoryPgaInUseBytes(mbc.Metrics.NewrelicoracledbMemoryPgaInUseBytes),
		metricNewrelicoracledbMemoryPgaMaxSizeBytes:                              newMetricNewrelicoracledbMemoryPgaMaxSizeBytes(mbc.Metrics.NewrelicoracledbMemoryPgaMaxSizeBytes),
		metricNewrelicoracledbMemorySgaSharedPoolLibraryCacheSharableBytes:       newMetricNewrelicoracledbMemorySgaSharedPoolLibraryCacheSharableBytes(mbc.Metrics.NewrelicoracledbMemorySgaSharedPoolLibraryCacheSharableBytes),
		metricNewrelicoracledbMemorySgaSharedPoolLibraryCacheUserBytes:           newMetricNewrelicoracledbMemorySgaSharedPoolLibraryCacheUserBytes(mbc.Metrics.NewrelicoracledbMemorySgaSharedPoolLibraryCacheUserBytes),
		metricNewrelicoracledbMemorySgaUgaTotalBytes:                             newMetricNewrelicoracledbMemorySgaUgaTotalBytes(mbc.Metrics.NewrelicoracledbMemorySgaUgaTotalBytes),
		metricNewrelicoracledbPdbActiveParallelSessions:                          newMetricNewrelicoracledbPdbActiveParallelSessions(mbc.Metrics.NewrelicoracledbPdbActiveParallelSessions),
		metricNewrelicoracledbPdbActiveSerialSessions:                            newMetricNewrelicoracledbPdbActiveSerialSessions(mbc.Metrics.NewrelicoracledbPdbActiveSerialSessions),
		metricNewrelicoracledbPdbAverageActiveSessions:                           newMetricNewrelicoracledbPdbAverageActiveSessions(mbc.Metrics.NewrelicoracledbPdbAverageActiveSessions),
		metricNewrelicoracledbPdbBackgroundCPUUsagePerSecond:                     newMetricNewrelicoracledbPdbBackgroundCPUUsagePerSecond(mbc.Metrics.NewrelicoracledbPdbBackgroundCPUUsagePerSecond),
		metricNewrelicoracledbPdbBackgroundTimePerSecond:                         newMetricNewrelicoracledbPdbBackgroundTimePerSecond(mbc.Metrics.NewrelicoracledbPdbBackgroundTimePerSecond),
		metricNewrelicoracledbPdbBlockChangesPerSecond:                           newMetricNewrelicoracledbPdbBlockChangesPerSecond(mbc.Metrics.NewrelicoracledbPdbBlockChangesPerSecond),
		metricNewrelicoracledbPdbBlockChangesPerTransaction:                      newMetricNewrelicoracledbPdbBlockChangesPerTransaction(mbc.Metrics.NewrelicoracledbPdbBlockChangesPerTransaction),
		metricNewrelicoracledbPdbCPUTimeRatio:                                    newMetricNewrelicoracledbPdbCPUTimeRatio(mbc.Metrics.NewrelicoracledbPdbCPUTimeRatio),
		metricNewrelicoracledbPdbCPUUsagePerSecond:                               newMetricNewrelicoracledbPdbCPUUsagePerSecond(mbc.Metrics.NewrelicoracledbPdbCPUUsagePerSecond),
		metricNewrelicoracledbPdbCPUUsagePerTransaction:                          newMetricNewrelicoracledbPdbCPUUsagePerTransaction(mbc.Metrics.NewrelicoracledbPdbCPUUsagePerTransaction),
		metricNewrelicoracledbPdbCurrentLogons:                                   newMetricNewrelicoracledbPdbCurrentLogons(mbc.Metrics.NewrelicoracledbPdbCurrentLogons),
		metricNewrelicoracledbPdbCurrentOpenCursors:                              newMetricNewrelicoracledbPdbCurrentOpenCursors(mbc.Metrics.NewrelicoracledbPdbCurrentOpenCursors),
		metricNewrelicoracledbPdbDbPhysicalReadBytesPerSecond:                    newMetricNewrelicoracledbPdbDbPhysicalReadBytesPerSecond(mbc.Metrics.NewrelicoracledbPdbDbPhysicalReadBytesPerSecond),
		metricNewrelicoracledbPdbDbPhysicalReadsPerSecond:                        newMetricNewrelicoracledbPdbDbPhysicalReadsPerSecond(mbc.Metrics.NewrelicoracledbPdbDbPhysicalReadsPerSecond),
		metricNewrelicoracledbPdbDbPhysicalWriteBytesPerSecond:                   newMetricNewrelicoracledbPdbDbPhysicalWriteBytesPerSecond(mbc.Metrics.NewrelicoracledbPdbDbPhysicalWriteBytesPerSecond),
		metricNewrelicoracledbPdbDbPhysicalWritesPerSecond:                       newMetricNewrelicoracledbPdbDbPhysicalWritesPerSecond(mbc.Metrics.NewrelicoracledbPdbDbPhysicalWritesPerSecond),
		metricNewrelicoracledbPdbExecuteWithoutParseRatio:                        newMetricNewrelicoracledbPdbExecuteWithoutParseRatio(mbc.Metrics.NewrelicoracledbPdbExecuteWithoutParseRatio),
		metricNewrelicoracledbPdbExecutionsPerSecond:                             newMetricNewrelicoracledbPdbExecutionsPerSecond(mbc.Metrics.NewrelicoracledbPdbExecutionsPerSecond),
		metricNewrelicoracledbPdbExecutionsPerTransaction:                        newMetricNewrelicoracledbPdbExecutionsPerTransaction(mbc.Metrics.NewrelicoracledbPdbExecutionsPerTransaction),
		metricNewrelicoracledbPdbHardParseCountPerSecond:                         newMetricNewrelicoracledbPdbHardParseCountPerSecond(mbc.Metrics.NewrelicoracledbPdbHardParseCountPerSecond),
		metricNewrelicoracledbPdbHardParseCountPerTransaction:                    newMetricNewrelicoracledbPdbHardParseCountPerTransaction(mbc.Metrics.NewrelicoracledbPdbHardParseCountPerTransaction),
		metricNewrelicoracledbPdbLogicalReadsPerSecond:                           newMetricNewrelicoracledbPdbLogicalReadsPerSecond(mbc.Metrics.NewrelicoracledbPdbLogicalReadsPerSecond),
		metricNewrelicoracledbPdbLogicalReadsPerTransaction:                      newMetricNewrelicoracledbPdbLogicalReadsPerTransaction(mbc.Metrics.NewrelicoracledbPdbLogicalReadsPerTransaction),
		metricNewrelicoracledbPdbLogonsPerSecond:                                 newMetricNewrelicoracledbPdbLogonsPerSecond(mbc.Metrics.NewrelicoracledbPdbLogonsPerSecond),
		metricNewrelicoracledbPdbLogonsPerTransaction:                            newMetricNewrelicoracledbPdbLogonsPerTransaction(mbc.Metrics.NewrelicoracledbPdbLogonsPerTransaction),
		metricNewrelicoracledbPdbNetworkTrafficBytePerSecond:                     newMetricNewrelicoracledbPdbNetworkTrafficBytePerSecond(mbc.Metrics.NewrelicoracledbPdbNetworkTrafficBytePerSecond),
		metricNewrelicoracledbPdbOpenCursorsPerSecond:                            newMetricNewrelicoracledbPdbOpenCursorsPerSecond(mbc.Metrics.NewrelicoracledbPdbOpenCursorsPerSecond),
		metricNewrelicoracledbPdbOpenCursorsPerTransaction:                       newMetricNewrelicoracledbPdbOpenCursorsPerTransaction(mbc.Metrics.NewrelicoracledbPdbOpenCursorsPerTransaction),
		metricNewrelicoracledbPdbOpenMode:                                        newMetricNewrelicoracledbPdbOpenMode(mbc.Metrics.NewrelicoracledbPdbOpenMode),
		metricNewrelicoracledbPdbParseFailureCountPerSecond:                      newMetricNewrelicoracledbPdbParseFailureCountPerSecond(mbc.Metrics.NewrelicoracledbPdbParseFailureCountPerSecond),
		metricNewrelicoracledbPdbPhysicalReadBytesPerSecond:                      newMetricNewrelicoracledbPdbPhysicalReadBytesPerSecond(mbc.Metrics.NewrelicoracledbPdbPhysicalReadBytesPerSecond),
		metricNewrelicoracledbPdbPhysicalReadsPerTransaction:                     newMetricNewrelicoracledbPdbPhysicalReadsPerTransaction(mbc.Metrics.NewrelicoracledbPdbPhysicalReadsPerTransaction),
		metricNewrelicoracledbPdbPhysicalWriteBytesPerSecond:                     newMetricNewrelicoracledbPdbPhysicalWriteBytesPerSecond(mbc.Metrics.NewrelicoracledbPdbPhysicalWriteBytesPerSecond),
		metricNewrelicoracledbPdbPhysicalWritesPerTransaction:                    newMetricNewrelicoracledbPdbPhysicalWritesPerTransaction(mbc.Metrics.NewrelicoracledbPdbPhysicalWritesPerTransaction),
		metricNewrelicoracledbPdbRedoGeneratedBytesPerSecond:                     newMetricNewrelicoracledbPdbRedoGeneratedBytesPerSecond(mbc.Metrics.NewrelicoracledbPdbRedoGeneratedBytesPerSecond),
		metricNewrelicoracledbPdbRedoGeneratedBytesPerTransaction:                newMetricNewrelicoracledbPdbRedoGeneratedBytesPerTransaction(mbc.Metrics.NewrelicoracledbPdbRedoGeneratedBytesPerTransaction),
		metricNewrelicoracledbPdbResponseTimePerTransaction:                      newMetricNewrelicoracledbPdbResponseTimePerTransaction(mbc.Metrics.NewrelicoracledbPdbResponseTimePerTransaction),
		metricNewrelicoracledbPdbSessionCount:                                    newMetricNewrelicoracledbPdbSessionCount(mbc.Metrics.NewrelicoracledbPdbSessionCount),
		metricNewrelicoracledbPdbSoftParseRatio:                                  newMetricNewrelicoracledbPdbSoftParseRatio(mbc.Metrics.NewrelicoracledbPdbSoftParseRatio),
		metricNewrelicoracledbPdbSQLServiceResponseTime:                          newMetricNewrelicoracledbPdbSQLServiceResponseTime(mbc.Metrics.NewrelicoracledbPdbSQLServiceResponseTime),
		metricNewrelicoracledbPdbStatus:                                          newMetricNewrelicoracledbPdbStatus(mbc.Metrics.NewrelicoracledbPdbStatus),
		metricNewrelicoracledbPdbTotalParseCountPerSecond:                        newMetricNewrelicoracledbPdbTotalParseCountPerSecond(mbc.Metrics.NewrelicoracledbPdbTotalParseCountPerSecond),
		metricNewrelicoracledbPdbTotalParseCountPerTransaction:                   newMetricNewrelicoracledbPdbTotalParseCountPerTransaction(mbc.Metrics.NewrelicoracledbPdbTotalParseCountPerTransaction),
		metricNewrelicoracledbPdbTotalSizeBytes:                                  newMetricNewrelicoracledbPdbTotalSizeBytes(mbc.Metrics.NewrelicoracledbPdbTotalSizeBytes),
		metricNewrelicoracledbPdbTransactionsPerSecond:                           newMetricNewrelicoracledbPdbTransactionsPerSecond(mbc.Metrics.NewrelicoracledbPdbTransactionsPerSecond),
		metricNewrelicoracledbPdbUserCallsPerSecond:                              newMetricNewrelicoracledbPdbUserCallsPerSecond(mbc.Metrics.NewrelicoracledbPdbUserCallsPerSecond),
		metricNewrelicoracledbPdbUserCallsPerTransaction:                         newMetricNewrelicoracledbPdbUserCallsPerTransaction(mbc.Metrics.NewrelicoracledbPdbUserCallsPerTransaction),
		metricNewrelicoracledbPdbUserCommitsPerSecond:                            newMetricNewrelicoracledbPdbUserCommitsPerSecond(mbc.Metrics.NewrelicoracledbPdbUserCommitsPerSecond),
		metricNewrelicoracledbPdbUserCommitsPercentage:                           newMetricNewrelicoracledbPdbUserCommitsPercentage(mbc.Metrics.NewrelicoracledbPdbUserCommitsPercentage),
		metricNewrelicoracledbPdbUserRollbacksPerSecond:                          newMetricNewrelicoracledbPdbUserRollbacksPerSecond(mbc.Metrics.NewrelicoracledbPdbUserRollbacksPerSecond),
		metricNewrelicoracledbPdbUserRollbacksPercentage:                         newMetricNewrelicoracledbPdbUserRollbacksPercentage(mbc.Metrics.NewrelicoracledbPdbUserRollbacksPercentage),
		metricNewrelicoracledbPdbWaitTimeRatio:                                   newMetricNewrelicoracledbPdbWaitTimeRatio(mbc.Metrics.NewrelicoracledbPdbWaitTimeRatio),
		metricNewrelicoracledbRacInstanceActiveState:                             newMetricNewrelicoracledbRacInstanceActiveState(mbc.Metrics.NewrelicoracledbRacInstanceActiveState),
		metricNewrelicoracledbRacInstanceArchiverStarted:                         newMetricNewrelicoracledbRacInstanceArchiverStarted(mbc.Metrics.NewrelicoracledbRacInstanceArchiverStarted),
		metricNewrelicoracledbRacInstanceDatabaseStatus:                          newMetricNewrelicoracledbRacInstanceDatabaseStatus(mbc.Metrics.NewrelicoracledbRacInstanceDatabaseStatus),
		metricNewrelicoracledbRacInstanceLoginsAllowed:                           newMetricNewrelicoracledbRacInstanceLoginsAllowed(mbc.Metrics.NewrelicoracledbRacInstanceLoginsAllowed),
		metricNewrelicoracledbRacInstanceStatus:                                  newMetricNewrelicoracledbRacInstanceStatus(mbc.Metrics.NewrelicoracledbRacInstanceStatus),
		metricNewrelicoracledbRacInstanceUptimeSeconds:                           newMetricNewrelicoracledbRacInstanceUptimeSeconds(mbc.Metrics.NewrelicoracledbRacInstanceUptimeSeconds),
		metricNewrelicoracledbRacInstanceVersionInfo:                             newMetricNewrelicoracledbRacInstanceVersionInfo(mbc.Metrics.NewrelicoracledbRacInstanceVersionInfo),
		metricNewrelicoracledbRacServiceClbConfig:                                newMetricNewrelicoracledbRacServiceClbConfig(mbc.Metrics.NewrelicoracledbRacServiceClbConfig),
		metricNewrelicoracledbRacServiceCreationAgeDays:                          newMetricNewrelicoracledbRacServiceCreationAgeDays(mbc.Metrics.NewrelicoracledbRacServiceCreationAgeDays),
		metricNewrelicoracledbRacServiceFailoverConfig:                           newMetricNewrelicoracledbRacServiceFailoverConfig(mbc.Metrics.NewrelicoracledbRacServiceFailoverConfig),
		metricNewrelicoracledbRacServiceFailoverDelaySeconds:                     newMetricNewrelicoracledbRacServiceFailoverDelaySeconds(mbc.Metrics.NewrelicoracledbRacServiceFailoverDelaySeconds),
		metricNewrelicoracledbRacServiceFailoverRetries:                          newMetricNewrelicoracledbRacServiceFailoverRetries(mbc.Metrics.NewrelicoracledbRacServiceFailoverRetries),
		metricNewrelicoracledbRacServiceInstanceID:                               newMetricNewrelicoracledbRacServiceInstanceID(mbc.Metrics.NewrelicoracledbRacServiceInstanceID),
		metricNewrelicoracledbRacServiceNetworkConfig:                            newMetricNewrelicoracledbRacServiceNetworkConfig(mbc.Metrics.NewrelicoracledbRacServiceNetworkConfig),
		metricNewrelicoracledbRacTotalWaits:                                      newMetricNewrelicoracledbRacTotalWaits(mbc.Metrics.NewrelicoracledbRacTotalWaits),
		metricNewrelicoracledbRacWaitTime:                                        newMetricNewrelicoracledbRacWaitTime(mbc.Metrics.NewrelicoracledbRacWaitTime),
		metricNewrelicoracledbRedoLogParallelWriteWaits:                          newMetricNewrelicoracledbRedoLogParallelWriteWaits(mbc.Metrics.NewrelicoracledbRedoLogParallelWriteWaits),
		metricNewrelicoracledbRedoLogSwitchArchivingNeededWaits:                  newMetricNewrelicoracledbRedoLogSwitchArchivingNeededWaits(mbc.Metrics.NewrelicoracledbRedoLogSwitchArchivingNeededWaits),
		metricNewrelicoracledbRedoLogSwitchCheckpointIncompleteWaits:             newMetricNewrelicoracledbRedoLogSwitchCheckpointIncompleteWaits(mbc.Metrics.NewrelicoracledbRedoLogSwitchCheckpointIncompleteWaits),
		metricNewrelicoracledbRedoLogSwitchCompletionWaits:                       newMetricNewrelicoracledbRedoLogSwitchCompletionWaits(mbc.Metrics.NewrelicoracledbRedoLogSwitchCompletionWaits),
		metricNewrelicoracledbRollbackSegmentsGets:                               newMetricNewrelicoracledbRollbackSegmentsGets(mbc.Metrics.NewrelicoracledbRollbackSegmentsGets),
		metricNewrelicoracledbRollbackSegmentsWaitRatio:                          newMetricNewrelicoracledbRollbackSegmentsWaitRatio(mbc.Metrics.NewrelicoracledbRollbackSegmentsWaitRatio),
		metricNewrelicoracledbRollbackSegmentsWaits:                              newMetricNewrelicoracledbRollbackSegmentsWaits(mbc.Metrics.NewrelicoracledbRollbackSegmentsWaits),
		metricNewrelicoracledbServiceCount:                                       newMetricNewrelicoracledbServiceCount(mbc.Metrics.NewrelicoracledbServiceCount),
		metricNewrelicoracledbServiceStatus:                                      newMetricNewrelicoracledbServiceStatus(mbc.Metrics.NewrelicoracledbServiceStatus),
		metricNewrelicoracledbSessionsCount:                                      newMetricNewrelicoracledbSessionsCount(mbc.Metrics.NewrelicoracledbSessionsCount),
		metricNewrelicoracledbSgaBufferBusyWaits:                                 newMetricNewrelicoracledbSgaBufferBusyWaits(mbc.Metrics.NewrelicoracledbSgaBufferBusyWaits),
		metricNewrelicoracledbSgaFixedSizeBytes:                                  newMetricNewrelicoracledbSgaFixedSizeBytes(mbc.Metrics.NewrelicoracledbSgaFixedSizeBytes),
		metricNewrelicoracledbSgaFreeBufferInspectedWaits:                        newMetricNewrelicoracledbSgaFreeBufferInspectedWaits(mbc.Metrics.NewrelicoracledbSgaFreeBufferInspectedWaits),
		metricNewrelicoracledbSgaFreeBufferWaits:                                 newMetricNewrelicoracledbSgaFreeBufferWaits(mbc.Metrics.NewrelicoracledbSgaFreeBufferWaits),
		metricNewrelicoracledbSgaHitRatio:                                        newMetricNewrelicoracledbSgaHitRatio(mbc.Metrics.NewrelicoracledbSgaHitRatio),
		metricNewrelicoracledbSgaLogAllocationRetriesRatio:                       newMetricNewrelicoracledbSgaLogAllocationRetriesRatio(mbc.Metrics.NewrelicoracledbSgaLogAllocationRetriesRatio),
		metricNewrelicoracledbSgaLogBufferRedoAllocationRetries:                  newMetricNewrelicoracledbSgaLogBufferRedoAllocationRetries(mbc.Metrics.NewrelicoracledbSgaLogBufferRedoAllocationRetries),
		metricNewrelicoracledbSgaLogBufferRedoEntries:                            newMetricNewrelicoracledbSgaLogBufferRedoEntries(mbc.Metrics.NewrelicoracledbSgaLogBufferRedoEntries),
		metricNewrelicoracledbSgaLogBufferSpaceWaits:                             newMetricNewrelicoracledbSgaLogBufferSpaceWaits(mbc.Metrics.NewrelicoracledbSgaLogBufferSpaceWaits),
		metricNewrelicoracledbSgaRedoBuffersBytes:                                newMetricNewrelicoracledbSgaRedoBuffersBytes(mbc.Metrics.NewrelicoracledbSgaRedoBuffersBytes),
		metricNewrelicoracledbSgaSharedPoolDictCacheMissRatio:                    newMetricNewrelicoracledbSgaSharedPoolDictCacheMissRatio(mbc.Metrics.NewrelicoracledbSgaSharedPoolDictCacheMissRatio),
		metricNewrelicoracledbSgaSharedPoolLibraryCacheHitRatio:                  newMetricNewrelicoracledbSgaSharedPoolLibraryCacheHitRatio(mbc.Metrics.NewrelicoracledbSgaSharedPoolLibraryCacheHitRatio),
		metricNewrelicoracledbSgaSharedPoolLibraryCacheReloadRatio:               newMetricNewrelicoracledbSgaSharedPoolLibraryCacheReloadRatio(mbc.Metrics.NewrelicoracledbSgaSharedPoolLibraryCacheReloadRatio),
		metricNewrelicoracledbSortsDisk:                                          newMetricNewrelicoracledbSortsDisk(mbc.Metrics.NewrelicoracledbSortsDisk),
		metricNewrelicoracledbSortsMemory:                                        newMetricNewrelicoracledbSortsMemory(mbc.Metrics.NewrelicoracledbSortsMemory),
		metricNewrelicoracledbSystemActiveParallelSessions:                       newMetricNewrelicoracledbSystemActiveParallelSessions(mbc.Metrics.NewrelicoracledbSystemActiveParallelSessions),
		metricNewrelicoracledbSystemActiveSerialSessions:                         newMetricNewrelicoracledbSystemActiveSerialSessions(mbc.Metrics.NewrelicoracledbSystemActiveSerialSessions),
		metricNewrelicoracledbSystemAverageActiveSessions:                        newMetricNewrelicoracledbSystemAverageActiveSessions(mbc.Metrics.NewrelicoracledbSystemAverageActiveSessions),
		metricNewrelicoracledbSystemBackgroundCheckpointsPerSecond:               newMetricNewrelicoracledbSystemBackgroundCheckpointsPerSecond(mbc.Metrics.NewrelicoracledbSystemBackgroundCheckpointsPerSecond),
		metricNewrelicoracledbSystemBackgroundCPUUsagePerSecond:                  newMetricNewrelicoracledbSystemBackgroundCPUUsagePerSecond(mbc.Metrics.NewrelicoracledbSystemBackgroundCPUUsagePerSecond),
		metricNewrelicoracledbSystemBackgroundTimePerSecond:                      newMetricNewrelicoracledbSystemBackgroundTimePerSecond(mbc.Metrics.NewrelicoracledbSystemBackgroundTimePerSecond),
		metricNewrelicoracledbSystemBranchNodeSplitsPerSecond:                    newMetricNewrelicoracledbSystemBranchNodeSplitsPerSecond(mbc.Metrics.NewrelicoracledbSystemBranchNodeSplitsPerSecond),
		metricNewrelicoracledbSystemBranchNodeSplitsPerTransaction:               newMetricNewrelicoracledbSystemBranchNodeSplitsPerTransaction(mbc.Metrics.NewrelicoracledbSystemBranchNodeSplitsPerTransaction),
		metricNewrelicoracledbSystemBufferCacheHitRatio:                          newMetricNewrelicoracledbSystemBufferCacheHitRatio(mbc.Metrics.NewrelicoracledbSystemBufferCacheHitRatio),
		metricNewrelicoracledbSystemCapturedUserCalls:                            newMetricNewrelicoracledbSystemCapturedUserCalls(mbc.Metrics.NewrelicoracledbSystemCapturedUserCalls),
		metricNewrelicoracledbSystemConsistentReadChangesPerSecond:               newMetricNewrelicoracledbSystemConsistentReadChangesPerSecond(mbc.Metrics.NewrelicoracledbSystemConsistentReadChangesPerSecond),
		metricNewrelicoracledbSystemConsistentReadChangesPerTransaction:          newMetricNewrelicoracledbSystemConsistentReadChangesPerTransaction(mbc.Metrics.NewrelicoracledbSystemConsistentReadChangesPerTransaction),
		metricNewrelicoracledbSystemConsistentReadGetsPerSecond:                  newMetricNewrelicoracledbSystemConsistentReadGetsPerSecond(mbc.Metrics.NewrelicoracledbSystemConsistentReadGetsPerSecond),
		metricNewrelicoracledbSystemConsistentReadGetsPerTransaction:             newMetricNewrelicoracledbSystemConsistentReadGetsPerTransaction(mbc.Metrics.NewrelicoracledbSystemConsistentReadGetsPerTransaction),
		metricNewrelicoracledbSystemCPUUsagePerSecond:                            newMetricNewrelicoracledbSystemCPUUsagePerSecond(mbc.Metrics.NewrelicoracledbSystemCPUUsagePerSecond),
		metricNewrelicoracledbSystemCPUUsagePerTransaction:                       newMetricNewrelicoracledbSystemCPUUsagePerTransaction(mbc.Metrics.NewrelicoracledbSystemCPUUsagePerTransaction),
		metricNewrelicoracledbSystemCrBlocksCreatedPerSecond:                     newMetricNewrelicoracledbSystemCrBlocksCreatedPerSecond(mbc.Metrics.NewrelicoracledbSystemCrBlocksCreatedPerSecond),
		metricNewrelicoracledbSystemCrBlocksCreatedPerTransaction:                newMetricNewrelicoracledbSystemCrBlocksCreatedPerTransaction(mbc.Metrics.NewrelicoracledbSystemCrBlocksCreatedPerTransaction),
		metricNewrelicoracledbSystemCrUndoRecordsAppliedPerSecond:                newMetricNewrelicoracledbSystemCrUndoRecordsAppliedPerSecond(mbc.Metrics.NewrelicoracledbSystemCrUndoRecordsAppliedPerSecond),
		metricNewrelicoracledbSystemCrUndoRecordsAppliedPerTransaction:           newMetricNewrelicoracledbSystemCrUndoRecordsAppliedPerTransaction(mbc.Metrics.NewrelicoracledbSystemCrUndoRecordsAppliedPerTransaction),
		metricNewrelicoracledbSystemCurrentLogonsCount:                           newMetricNewrelicoracledbSystemCurrentLogonsCount(mbc.Metrics.NewrelicoracledbSystemCurrentLogonsCount),
		metricNewrelicoracledbSystemCurrentOpenCursorsCount:                      newMetricNewrelicoracledbSystemCurrentOpenCursorsCount(mbc.Metrics.NewrelicoracledbSystemCurrentOpenCursorsCount),
		metricNewrelicoracledbSystemCurrentOsLoad:                                newMetricNewrelicoracledbSystemCurrentOsLoad(mbc.Metrics.NewrelicoracledbSystemCurrentOsLoad),
		metricNewrelicoracledbSystemCursorCacheHitRatio:                          newMetricNewrelicoracledbSystemCursorCacheHitRatio(mbc.Metrics.NewrelicoracledbSystemCursorCacheHitRatio),
		metricNewrelicoracledbSystemDatabaseCPUTimeRatio:                         newMetricNewrelicoracledbSystemDatabaseCPUTimeRatio(mbc.Metrics.NewrelicoracledbSystemDatabaseCPUTimeRatio),
		metricNewrelicoracledbSystemDatabaseTimePerSecond:                        newMetricNewrelicoracledbSystemDatabaseTimePerSecond(mbc.Metrics.NewrelicoracledbSystemDatabaseTimePerSecond),
		metricNewrelicoracledbSystemDatabaseWaitTimeRatio:                        newMetricNewrelicoracledbSystemDatabaseWaitTimeRatio(mbc.Metrics.NewrelicoracledbSystemDatabaseWaitTimeRatio),
		metricNewrelicoracledbSystemDbBlockChangesPerSecond:                      newMetricNewrelicoracledbSystemDbBlockChangesPerSecond(mbc.Metrics.NewrelicoracledbSystemDbBlockChangesPerSecond),
		metricNewrelicoracledbSystemDbBlockChangesPerTransaction:                 newMetricNewrelicoracledbSystemDbBlockChangesPerTransaction(mbc.Metrics.NewrelicoracledbSystemDbBlockChangesPerTransaction),
		metricNewrelicoracledbSystemDbBlockChangesPerUserCall:                    newMetricNewrelicoracledbSystemDbBlockChangesPerUserCall(mbc.Metrics.NewrelicoracledbSystemDbBlockChangesPerUserCall),
		metricNewrelicoracledbSystemDbBlockGetsPerSecond:                         newMetricNewrelicoracledbSystemDbBlockGetsPerSecond(mbc.Metrics.NewrelicoracledbSystemDbBlockGetsPerSecond),
		metricNewrelicoracledbSystemDbBlockGetsPerTransaction:                    newMetricNewrelicoracledbSystemDbBlockGetsPerTransaction(mbc.Metrics.NewrelicoracledbSystemDbBlockGetsPerTransaction),
		metricNewrelicoracledbSystemDbBlockGetsPerUserCall:                       newMetricNewrelicoracledbSystemDbBlockGetsPerUserCall(mbc.Metrics.NewrelicoracledbSystemDbBlockGetsPerUserCall),
		metricNewrelicoracledbSystemDbwrCheckpointsPerSecond:                     newMetricNewrelicoracledbSystemDbwrCheckpointsPerSecond(mbc.Metrics.NewrelicoracledbSystemDbwrCheckpointsPerSecond),
		metricNewrelicoracledbSystemDiskSortPerSecond:                            newMetricNewrelicoracledbSystemDiskSortPerSecond(mbc.Metrics.NewrelicoracledbSystemDiskSortPerSecond),
		metricNewrelicoracledbSystemDiskSortPerTransaction:                       newMetricNewrelicoracledbSystemDiskSortPerTransaction(mbc.Metrics.NewrelicoracledbSystemDiskSortPerTransaction),
		metricNewrelicoracledbSystemEnqueueDeadlocksPerSecond:                    newMetricNewrelicoracledbSystemEnqueueDeadlocksPerSecond(mbc.Metrics.NewrelicoracledbSystemEnqueueDeadlocksPerSecond),
		metricNewrelicoracledbSystemEnqueueDeadlocksPerTransaction:               newMetricNewrelicoracledbSystemEnqueueDeadlocksPerTransaction(mbc.Metrics.NewrelicoracledbSystemEnqueueDeadlocksPerTransaction),
		metricNewrelicoracledbSystemEnqueueRequestsPerSecond:                     newMetricNewrelicoracledbSystemEnqueueRequestsPerSecond(mbc.Metrics.NewrelicoracledbSystemEnqueueRequestsPerSecond),
		metricNewrelicoracledbSystemEnqueueRequestsPerTransaction:                newMetricNewrelicoracledbSystemEnqueueRequestsPerTransaction(mbc.Metrics.NewrelicoracledbSystemEnqueueRequestsPerTransaction),
		metricNewrelicoracledbSystemEnqueueTimeoutsPerSecond:                     newMetricNewrelicoracledbSystemEnqueueTimeoutsPerSecond(mbc.Metrics.NewrelicoracledbSystemEnqueueTimeoutsPerSecond),
		metricNewrelicoracledbSystemEnqueueTimeoutsPerTransaction:                newMetricNewrelicoracledbSystemEnqueueTimeoutsPerTransaction(mbc.Metrics.NewrelicoracledbSystemEnqueueTimeoutsPerTransaction),
		metricNewrelicoracledbSystemEnqueueWaitsPerSecond:                        newMetricNewrelicoracledbSystemEnqueueWaitsPerSecond(mbc.Metrics.NewrelicoracledbSystemEnqueueWaitsPerSecond),
		metricNewrelicoracledbSystemEnqueueWaitsPerTransaction:                   newMetricNewrelicoracledbSystemEnqueueWaitsPerTransaction(mbc.Metrics.NewrelicoracledbSystemEnqueueWaitsPerTransaction),
		metricNewrelicoracledbSystemExecuteWithoutParseRatio:                     newMetricNewrelicoracledbSystemExecuteWithoutParseRatio(mbc.Metrics.NewrelicoracledbSystemExecuteWithoutParseRatio),
		metricNewrelicoracledbSystemExecutionsPerSecond:                          newMetricNewrelicoracledbSystemExecutionsPerSecond(mbc.Metrics.NewrelicoracledbSystemExecutionsPerSecond),
		metricNewrelicoracledbSystemExecutionsPerTransaction:                     newMetricNewrelicoracledbSystemExecutionsPerTransaction(mbc.Metrics.NewrelicoracledbSystemExecutionsPerTransaction),
		metricNewrelicoracledbSystemExecutionsPerUserCall:                        newMetricNewrelicoracledbSystemExecutionsPerUserCall(mbc.Metrics.NewrelicoracledbSystemExecutionsPerUserCall),
		metricNewrelicoracledbSystemFullIndexScansPerSecond:                      newMetricNewrelicoracledbSystemFullIndexScansPerSecond(mbc.Metrics.NewrelicoracledbSystemFullIndexScansPerSecond),
		metricNewrelicoracledbSystemFullIndexScansPerTransaction:                 newMetricNewrelicoracledbSystemFullIndexScansPerTransaction(mbc.Metrics.NewrelicoracledbSystemFullIndexScansPerTransaction),
		metricNewrelicoracledbSystemGcCrBlockReceivedPerSecond:                   newMetricNewrelicoracledbSystemGcCrBlockReceivedPerSecond(mbc.Metrics.NewrelicoracledbSystemGcCrBlockReceivedPerSecond),
		metricNewrelicoracledbSystemGcCrBlockReceivedPerTransaction:              newMetricNewrelicoracledbSystemGcCrBlockReceivedPerTransaction(mbc.Metrics.NewrelicoracledbSystemGcCrBlockReceivedPerTransaction),
		metricNewrelicoracledbSystemGcCurrentBlockReceivedPerSecond:              newMetricNewrelicoracledbSystemGcCurrentBlockReceivedPerSecond(mbc.Metrics.NewrelicoracledbSystemGcCurrentBlockReceivedPerSecond),
		metricNewrelicoracledbSystemGcCurrentBlockReceivedPerTransaction:         newMetricNewrelicoracledbSystemGcCurrentBlockReceivedPerTransaction(mbc.Metrics.NewrelicoracledbSystemGcCurrentBlockReceivedPerTransaction),
		metricNewrelicoracledbSystemGlobalCacheAverageCrGetTime:                  newMetricNewrelicoracledbSystemGlobalCacheAverageCrGetTime(mbc.Metrics.NewrelicoracledbSystemGlobalCacheAverageCrGetTime),
		metricNewrelicoracledbSystemGlobalCacheAverageCurrentGetTime:             newMetricNewrelicoracledbSystemGlobalCacheAverageCurrentGetTime(mbc.Metrics.NewrelicoracledbSystemGlobalCacheAverageCurrentGetTime),
		metricNewrelicoracledbSystemGlobalCacheBlocksCorrupted:                   newMetricNewrelicoracledbSystemGlobalCacheBlocksCorrupted(mbc.Metrics.NewrelicoracledbSystemGlobalCacheBlocksCorrupted),
		metricNewrelicoracledbSystemGlobalCacheBlocksLost:                        newMetricNewrelicoracledbSystemGlobalCacheBlocksLost(mbc.Metrics.NewrelicoracledbSystemGlobalCacheBlocksLost),
		metricNewrelicoracledbSystemHardParseCountPerSecond:                      newMetricNewrelicoracledbSystemHardParseCountPerSecond(mbc.Metrics.NewrelicoracledbSystemHardParseCountPerSecond),
		metricNewrelicoracledbSystemHardParseCountPerTransaction:                 newMetricNewrelicoracledbSystemHardParseCountPerTransaction(mbc.Metrics.NewrelicoracledbSystemHardParseCountPerTransaction),
		metricNewrelicoracledbSystemHostCPUUsagePerSecond:                        newMetricNewrelicoracledbSystemHostCPUUsagePerSecond(mbc.Metrics.NewrelicoracledbSystemHostCPUUsagePerSecond),
		metricNewrelicoracledbSystemHostCPUUtilization:                           newMetricNewrelicoracledbSystemHostCPUUtilization(mbc.Metrics.NewrelicoracledbSystemHostCPUUtilization),
		metricNewrelicoracledbSystemIoMegabytesPerSecond:                         newMetricNewrelicoracledbSystemIoMegabytesPerSecond(mbc.Metrics.NewrelicoracledbSystemIoMegabytesPerSecond),
		metricNewrelicoracledbSystemIoRequestsPerSecond:                          newMetricNewrelicoracledbSystemIoRequestsPerSecond(mbc.Metrics.NewrelicoracledbSystemIoRequestsPerSecond),
		metricNewrelicoracledbSystemLeafNodeSplitsPerSecond:                      newMetricNewrelicoracledbSystemLeafNodeSplitsPerSecond(mbc.Metrics.NewrelicoracledbSystemLeafNodeSplitsPerSecond),
		metricNewrelicoracledbSystemLeafNodeSplitsPerTransaction:                 newMetricNewrelicoracledbSystemLeafNodeSplitsPerTransaction(mbc.Metrics.NewrelicoracledbSystemLeafNodeSplitsPerTransaction),
		metricNewrelicoracledbSystemLibraryCacheHitRatio:                         newMetricNewrelicoracledbSystemLibraryCacheHitRatio(mbc.Metrics.NewrelicoracledbSystemLibraryCacheHitRatio),
		metricNewrelicoracledbSystemLibraryCacheMissRatio:                        newMetricNewrelicoracledbSystemLibraryCacheMissRatio(mbc.Metrics.NewrelicoracledbSystemLibraryCacheMissRatio),
		metricNewrelicoracledbSystemLogicalReadsPerSecond:                        newMetricNewrelicoracledbSystemLogicalReadsPerSecond(mbc.Metrics.NewrelicoracledbSystemLogicalReadsPerSecond),
		metricNewrelicoracledbSystemLogicalReadsPerTransaction:                   newMetricNewrelicoracledbSystemLogicalReadsPerTransaction(mbc.Metrics.NewrelicoracledbSystemLogicalReadsPerTransaction),
		metricNewrelicoracledbSystemLogicalReadsPerUserCall:                      newMetricNewrelicoracledbSystemLogicalReadsPerUserCall(mbc.Metrics.NewrelicoracledbSystemLogicalReadsPerUserCall),
		metricNewrelicoracledbSystemLogonsPerSecond:                              newMetricNewrelicoracledbSystemLogonsPerSecond(mbc.Metrics.NewrelicoracledbSystemLogonsPerSecond),
		metricNewrelicoracledbSystemLogonsPerTransaction:                         newMetricNewrelicoracledbSystemLogonsPerTransaction(mbc.Metrics.NewrelicoracledbSystemLogonsPerTransaction),
		metricNewrelicoracledbSystemLongTableScansPerSecond:                      newMetricNewrelicoracledbSystemLongTableScansPerSecond(mbc.Metrics.NewrelicoracledbSystemLongTableScansPerSecond),
		metricNewrelicoracledbSystemLongTableScansPerTransaction:                 newMetricNewrelicoracledbSystemLongTableScansPerTransaction(mbc.Metrics.NewrelicoracledbSystemLongTableScansPerTransaction),
		metricNewrelicoracledbSystemMemorySortsRatio:                             newMetricNewrelicoracledbSystemMemorySortsRatio(mbc.Metrics.NewrelicoracledbSystemMemorySortsRatio),
		metricNewrelicoracledbSystemNetworkTrafficVolumePerSecond:                newMetricNewrelicoracledbSystemNetworkTrafficVolumePerSecond(mbc.Metrics.NewrelicoracledbSystemNetworkTrafficVolumePerSecond),
		metricNewrelicoracledbSystemOpenCursorsPerSecond:                         newMetricNewrelicoracledbSystemOpenCursorsPerSecond(mbc.Metrics.NewrelicoracledbSystemOpenCursorsPerSecond),
		metricNewrelicoracledbSystemOpenCursorsPerTransaction:                    newMetricNewrelicoracledbSystemOpenCursorsPerTransaction(mbc.Metrics.NewrelicoracledbSystemOpenCursorsPerTransaction),
		metricNewrelicoracledbSystemParseFailureCountPerSecond:                   newMetricNewrelicoracledbSystemParseFailureCountPerSecond(mbc.Metrics.NewrelicoracledbSystemParseFailureCountPerSecond),
		metricNewrelicoracledbSystemParseFailureCountPerTransaction:              newMetricNewrelicoracledbSystemParseFailureCountPerTransaction(mbc.Metrics.NewrelicoracledbSystemParseFailureCountPerTransaction),
		metricNewrelicoracledbSystemPgaCacheHitPercentage:                        newMetricNewrelicoracledbSystemPgaCacheHitPercentage(mbc.Metrics.NewrelicoracledbSystemPgaCacheHitPercentage),
		metricNewrelicoracledbSystemPhysicalLobsReadsPerSecond:                   newMetricNewrelicoracledbSystemPhysicalLobsReadsPerSecond(mbc.Metrics.NewrelicoracledbSystemPhysicalLobsReadsPerSecond),
		metricNewrelicoracledbSystemPhysicalLobsReadsPerTransaction:              newMetricNewrelicoracledbSystemPhysicalLobsReadsPerTransaction(mbc.Metrics.NewrelicoracledbSystemPhysicalLobsReadsPerTransaction),
		metricNewrelicoracledbSystemPhysicalLobsWritesPerSecond:                  newMetricNewrelicoracledbSystemPhysicalLobsWritesPerSecond(mbc.Metrics.NewrelicoracledbSystemPhysicalLobsWritesPerSecond),
		metricNewrelicoracledbSystemPhysicalLobsWritesPerTransaction:             newMetricNewrelicoracledbSystemPhysicalLobsWritesPerTransaction(mbc.Metrics.NewrelicoracledbSystemPhysicalLobsWritesPerTransaction),
		metricNewrelicoracledbSystemPhysicalReadBytesPerSecond:                   newMetricNewrelicoracledbSystemPhysicalReadBytesPerSecond(mbc.Metrics.NewrelicoracledbSystemPhysicalReadBytesPerSecond),
		metricNewrelicoracledbSystemPhysicalReadIoRequestsPerSecond:              newMetricNewrelicoracledbSystemPhysicalReadIoRequestsPerSecond(mbc.Metrics.NewrelicoracledbSystemPhysicalReadIoRequestsPerSecond),
		metricNewrelicoracledbSystemPhysicalReadTotalBytesPerSecond:              newMetricNewrelicoracledbSystemPhysicalReadTotalBytesPerSecond(mbc.Metrics.NewrelicoracledbSystemPhysicalReadTotalBytesPerSecond),
		metricNewrelicoracledbSystemPhysicalReadTotalIoRequestsPerSecond:         newMetricNewrelicoracledbSystemPhysicalReadTotalIoRequestsPerSecond(mbc.Metrics.NewrelicoracledbSystemPhysicalReadTotalIoRequestsPerSecond),
		metricNewrelicoracledbSystemPhysicalReadsDirectPerSecond:                 newMetricNewrelicoracledbSystemPhysicalReadsDirectPerSecond(mbc.Metrics.NewrelicoracledbSystemPhysicalReadsDirectPerSecond),
		metricNewrelicoracledbSystemPhysicalReadsDirectPerTransaction:            newMetricNewrelicoracledbSystemPhysicalReadsDirectPerTransaction(mbc.Metrics.NewrelicoracledbSystemPhysicalReadsDirectPerTransaction),
		metricNewrelicoracledbSystemPhysicalReadsPerSecond:                       newMetricNewrelicoracledbSystemPhysicalReadsPerSecond(mbc.Metrics.NewrelicoracledbSystemPhysicalReadsPerSecond),
		metricNewrelicoracledbSystemPhysicalReadsPerTransaction:                  newMetricNewrelicoracledbSystemPhysicalReadsPerTransaction(mbc.Metrics.NewrelicoracledbSystemPhysicalReadsPerTransaction),
		metricNewrelicoracledbSystemPhysicalWriteBytesPerSecond:                  newMetricNewrelicoracledbSystemPhysicalWriteBytesPerSecond(mbc.Metrics.NewrelicoracledbSystemPhysicalWriteBytesPerSecond),
		metricNewrelicoracledbSystemPhysicalWriteIoRequestsPerSecond:             newMetricNewrelicoracledbSystemPhysicalWriteIoRequestsPerSecond(mbc.Metrics.NewrelicoracledbSystemPhysicalWriteIoRequestsPerSecond),
		metricNewrelicoracledbSystemPhysicalWriteTotalBytesPerSecond:             newMetricNewrelicoracledbSystemPhysicalWriteTotalBytesPerSecond(mbc.Metrics.NewrelicoracledbSystemPhysicalWriteTotalBytesPerSecond),
		metricNewrelicoracledbSystemPhysicalWriteTotalIoRequestsPerSecond:        newMetricNewrelicoracledbSystemPhysicalWriteTotalIoRequestsPerSecond(mbc.Metrics.NewrelicoracledbSystemPhysicalWriteTotalIoRequestsPerSecond),
		metricNewrelicoracledbSystemPhysicalWritesDirectPerSecond:                newMetricNewrelicoracledbSystemPhysicalWritesDirectPerSecond(mbc.Metrics.NewrelicoracledbSystemPhysicalWritesDirectPerSecond),
		metricNewrelicoracledbSystemPhysicalWritesDirectPerTransaction:           newMetricNewrelicoracledbSystemPhysicalWritesDirectPerTransaction(mbc.Metrics.NewrelicoracledbSystemPhysicalWritesDirectPerTransaction),
		metricNewrelicoracledbSystemPhysicalWritesPerSecond:                      newMetricNewrelicoracledbSystemPhysicalWritesPerSecond(mbc.Metrics.NewrelicoracledbSystemPhysicalWritesPerSecond),
		metricNewrelicoracledbSystemPhysicalWritesPerTransaction:                 newMetricNewrelicoracledbSystemPhysicalWritesPerTransaction(mbc.Metrics.NewrelicoracledbSystemPhysicalWritesPerTransaction),
		metricNewrelicoracledbSystemProcessLimitPercentage:                       newMetricNewrelicoracledbSystemProcessLimitPercentage(mbc.Metrics.NewrelicoracledbSystemProcessLimitPercentage),
		metricNewrelicoracledbSystemRecursiveCallsPerSecond:                      newMetricNewrelicoracledbSystemRecursiveCallsPerSecond(mbc.Metrics.NewrelicoracledbSystemRecursiveCallsPerSecond),
		metricNewrelicoracledbSystemRecursiveCallsPerTransaction:                 newMetricNewrelicoracledbSystemRecursiveCallsPerTransaction(mbc.Metrics.NewrelicoracledbSystemRecursiveCallsPerTransaction),
		metricNewrelicoracledbSystemRedoAllocationHitRatio:                       newMetricNewrelicoracledbSystemRedoAllocationHitRatio(mbc.Metrics.NewrelicoracledbSystemRedoAllocationHitRatio),
		metricNewrelicoracledbSystemRedoGeneratedBytesPerSecond:                  newMetricNewrelicoracledbSystemRedoGeneratedBytesPerSecond(mbc.Metrics.NewrelicoracledbSystemRedoGeneratedBytesPerSecond),
		metricNewrelicoracledbSystemRedoGeneratedBytesPerTransaction:             newMetricNewrelicoracledbSystemRedoGeneratedBytesPerTransaction(mbc.Metrics.NewrelicoracledbSystemRedoGeneratedBytesPerTransaction),
		metricNewrelicoracledbSystemRedoWritesPerSecond:                          newMetricNewrelicoracledbSystemRedoWritesPerSecond(mbc.Metrics.NewrelicoracledbSystemRedoWritesPerSecond),
		metricNewrelicoracledbSystemRedoWritesPerTransaction:                     newMetricNewrelicoracledbSystemRedoWritesPerTransaction(mbc.Metrics.NewrelicoracledbSystemRedoWritesPerTransaction),
		metricNewrelicoracledbSystemResponseTimePerTransaction:                   newMetricNewrelicoracledbSystemResponseTimePerTransaction(mbc.Metrics.NewrelicoracledbSystemResponseTimePerTransaction),
		metricNewrelicoracledbSystemRowCacheHitRatio:                             newMetricNewrelicoracledbSystemRowCacheHitRatio(mbc.Metrics.NewrelicoracledbSystemRowCacheHitRatio),
		metricNewrelicoracledbSystemRowCacheMissRatio:                            newMetricNewrelicoracledbSystemRowCacheMissRatio(mbc.Metrics.NewrelicoracledbSystemRowCacheMissRatio),
		metricNewrelicoracledbSystemRowsPerSort:                                  newMetricNewrelicoracledbSystemRowsPerSort(mbc.Metrics.NewrelicoracledbSystemRowsPerSort),
		metricNewrelicoracledbSystemSessionCount:                                 newMetricNewrelicoracledbSystemSessionCount(mbc.Metrics.NewrelicoracledbSystemSessionCount),
		metricNewrelicoracledbSystemSessionLimitPercentage:                       newMetricNewrelicoracledbSystemSessionLimitPercentage(mbc.Metrics.NewrelicoracledbSystemSessionLimitPercentage),
		metricNewrelicoracledbSystemSharedPoolFreePercentage:                     newMetricNewrelicoracledbSystemSharedPoolFreePercentage(mbc.Metrics.NewrelicoracledbSystemSharedPoolFreePercentage),
		metricNewrelicoracledbSystemSoftParseRatio:                               newMetricNewrelicoracledbSystemSoftParseRatio(mbc.Metrics.NewrelicoracledbSystemSoftParseRatio),
		metricNewrelicoracledbSystemSQLServiceResponseTime:                       newMetricNewrelicoracledbSystemSQLServiceResponseTime(mbc.Metrics.NewrelicoracledbSystemSQLServiceResponseTime),
		metricNewrelicoracledbSystemStreamsPoolUsagePercentage:                   newMetricNewrelicoracledbSystemStreamsPoolUsagePercentage(mbc.Metrics.NewrelicoracledbSystemStreamsPoolUsagePercentage),
		metricNewrelicoracledbSystemTempSpaceUsed:                                newMetricNewrelicoracledbSystemTempSpaceUsed(mbc.Metrics.NewrelicoracledbSystemTempSpaceUsed),
		metricNewrelicoracledbSystemTotalIndexScansPerSecond:                     newMetricNewrelicoracledbSystemTotalIndexScansPerSecond(mbc.Metrics.NewrelicoracledbSystemTotalIndexScansPerSecond),
		metricNewrelicoracledbSystemTotalIndexScansPerTransaction:                newMetricNewrelicoracledbSystemTotalIndexScansPerTransaction(mbc.Metrics.NewrelicoracledbSystemTotalIndexScansPerTransaction),
		metricNewrelicoracledbSystemTotalParseCountPerSecond:                     newMetricNewrelicoracledbSystemTotalParseCountPerSecond(mbc.Metrics.NewrelicoracledbSystemTotalParseCountPerSecond),
		metricNewrelicoracledbSystemTotalParseCountPerTransaction:                newMetricNewrelicoracledbSystemTotalParseCountPerTransaction(mbc.Metrics.NewrelicoracledbSystemTotalParseCountPerTransaction),
		metricNewrelicoracledbSystemTotalSortsPerUserCall:                        newMetricNewrelicoracledbSystemTotalSortsPerUserCall(mbc.Metrics.NewrelicoracledbSystemTotalSortsPerUserCall),
		metricNewrelicoracledbSystemTotalTableScansPerSecond:                     newMetricNewrelicoracledbSystemTotalTableScansPerSecond(mbc.Metrics.NewrelicoracledbSystemTotalTableScansPerSecond),
		metricNewrelicoracledbSystemTotalTableScansPerTransaction:                newMetricNewrelicoracledbSystemTotalTableScansPerTransaction(mbc.Metrics.NewrelicoracledbSystemTotalTableScansPerTransaction),
		metricNewrelicoracledbSystemTotalTableScansPerUserCall:                   newMetricNewrelicoracledbSystemTotalTableScansPerUserCall(mbc.Metrics.NewrelicoracledbSystemTotalTableScansPerUserCall),
		metricNewrelicoracledbSystemTransactionsPerLogon:                         newMetricNewrelicoracledbSystemTransactionsPerLogon(mbc.Metrics.NewrelicoracledbSystemTransactionsPerLogon),
		metricNewrelicoracledbSystemTransactionsPerSecond:                        newMetricNewrelicoracledbSystemTransactionsPerSecond(mbc.Metrics.NewrelicoracledbSystemTransactionsPerSecond),
		metricNewrelicoracledbSystemUserCallsPerSecond:                           newMetricNewrelicoracledbSystemUserCallsPerSecond(mbc.Metrics.NewrelicoracledbSystemUserCallsPerSecond),
		metricNewrelicoracledbSystemUserCallsPerTransaction:                      newMetricNewrelicoracledbSystemUserCallsPerTransaction(mbc.Metrics.NewrelicoracledbSystemUserCallsPerTransaction),
		metricNewrelicoracledbSystemUserCallsRatio:                               newMetricNewrelicoracledbSystemUserCallsRatio(mbc.Metrics.NewrelicoracledbSystemUserCallsRatio),
		metricNewrelicoracledbSystemUserCommitsPerSecond:                         newMetricNewrelicoracledbSystemUserCommitsPerSecond(mbc.Metrics.NewrelicoracledbSystemUserCommitsPerSecond),
		metricNewrelicoracledbSystemUserCommitsPercentage:                        newMetricNewrelicoracledbSystemUserCommitsPercentage(mbc.Metrics.NewrelicoracledbSystemUserCommitsPercentage),
		metricNewrelicoracledbSystemUserLimitPercentage:                          newMetricNewrelicoracledbSystemUserLimitPercentage(mbc.Metrics.NewrelicoracledbSystemUserLimitPercentage),
		metricNewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerSecond:      newMetricNewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerSecond(mbc.Metrics.NewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerSecond),
		metricNewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerTransaction: newMetricNewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerTransaction(mbc.Metrics.NewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerTransaction),
		metricNewrelicoracledbSystemUserRollbacksPerSecond:                       newMetricNewrelicoracledbSystemUserRollbacksPerSecond(mbc.Metrics.NewrelicoracledbSystemUserRollbacksPerSecond),
		metricNewrelicoracledbSystemUserRollbacksPercentage:                      newMetricNewrelicoracledbSystemUserRollbacksPercentage(mbc.Metrics.NewrelicoracledbSystemUserRollbacksPercentage),
		metricNewrelicoracledbTablespaceDbID:                                     newMetricNewrelicoracledbTablespaceDbID(mbc.Metrics.NewrelicoracledbTablespaceDbID),
		metricNewrelicoracledbTablespaceGlobalName:                               newMetricNewrelicoracledbTablespaceGlobalName(mbc.Metrics.NewrelicoracledbTablespaceGlobalName),
		metricNewrelicoracledbTablespaceIsOffline:                                newMetricNewrelicoracledbTablespaceIsOffline(mbc.Metrics.NewrelicoracledbTablespaceIsOffline),
		metricNewrelicoracledbTablespaceOfflineCdbDatafiles:                      newMetricNewrelicoracledbTablespaceOfflineCdbDatafiles(mbc.Metrics.NewrelicoracledbTablespaceOfflineCdbDatafiles),
		metricNewrelicoracledbTablespaceOfflinePdbDatafiles:                      newMetricNewrelicoracledbTablespaceOfflinePdbDatafiles(mbc.Metrics.NewrelicoracledbTablespaceOfflinePdbDatafiles),
		metricNewrelicoracledbTablespacePdbNonWriteMode:                          newMetricNewrelicoracledbTablespacePdbNonWriteMode(mbc.Metrics.NewrelicoracledbTablespacePdbNonWriteMode),
		metricNewrelicoracledbTablespaceSpaceConsumedBytes:                       newMetricNewrelicoracledbTablespaceSpaceConsumedBytes(mbc.Metrics.NewrelicoracledbTablespaceSpaceConsumedBytes),
		metricNewrelicoracledbTablespaceSpaceReservedBytes:                       newMetricNewrelicoracledbTablespaceSpaceReservedBytes(mbc.Metrics.NewrelicoracledbTablespaceSpaceReservedBytes),
		metricNewrelicoracledbTablespaceSpaceUsedPercentage:                      newMetricNewrelicoracledbTablespaceSpaceUsedPercentage(mbc.Metrics.NewrelicoracledbTablespaceSpaceUsedPercentage),
		metricNewrelicoracledbTablespaceTotalBytes:                               newMetricNewrelicoracledbTablespaceTotalBytes(mbc.Metrics.NewrelicoracledbTablespaceTotalBytes),
		metricNewrelicoracledbTablespaceUsedBytes:                                newMetricNewrelicoracledbTablespaceUsedBytes(mbc.Metrics.NewrelicoracledbTablespaceUsedBytes),
		metricNewrelicoracledbTablespaceUsedPercent:                              newMetricNewrelicoracledbTablespaceUsedPercent(mbc.Metrics.NewrelicoracledbTablespaceUsedPercent),
		resourceAttributeIncludeFilter:                                           make(map[string]filter.Filter),
		resourceAttributeExcludeFilter:                                           make(map[string]filter.Filter),
	}
	if mbc.ResourceAttributes.HostName.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["host.name"] = filter.CreateFilter(mbc.ResourceAttributes.HostName.MetricsInclude)
	}
	if mbc.ResourceAttributes.HostName.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["host.name"] = filter.CreateFilter(mbc.ResourceAttributes.HostName.MetricsExclude)
	}
	if mbc.ResourceAttributes.NewrelicoracledbInstanceName.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["newrelicoracledb.instance.name"] = filter.CreateFilter(mbc.ResourceAttributes.NewrelicoracledbInstanceName.MetricsInclude)
	}
	if mbc.ResourceAttributes.NewrelicoracledbInstanceName.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["newrelicoracledb.instance.name"] = filter.CreateFilter(mbc.ResourceAttributes.NewrelicoracledbInstanceName.MetricsExclude)
	}

	for _, op := range options {
		op.apply(mb)
	}
	return mb
}

// NewResourceBuilder returns a new resource builder that should be used to build a resource associated with for the emitted metrics.
func (mb *MetricsBuilder) NewResourceBuilder() *ResourceBuilder {
	return NewResourceBuilder(mb.config.ResourceAttributes)
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (mb *MetricsBuilder) updateCapacity(rm pmetric.ResourceMetrics) {
	if mb.metricsCapacity < rm.ScopeMetrics().At(0).Metrics().Len() {
		mb.metricsCapacity = rm.ScopeMetrics().At(0).Metrics().Len()
	}
}

// ResourceMetricsOption applies changes to provided resource metrics.
type ResourceMetricsOption interface {
	apply(pmetric.ResourceMetrics)
}

type resourceMetricsOptionFunc func(pmetric.ResourceMetrics)

func (rmof resourceMetricsOptionFunc) apply(rm pmetric.ResourceMetrics) {
	rmof(rm)
}

// WithResource sets the provided resource on the emitted ResourceMetrics.
// It's recommended to use ResourceBuilder to create the resource.
func WithResource(res pcommon.Resource) ResourceMetricsOption {
	return resourceMetricsOptionFunc(func(rm pmetric.ResourceMetrics) {
		res.CopyTo(rm.Resource())
	})
}

// WithStartTimeOverride overrides start time for all the resource metrics data points.
// This option should be only used if different start time has to be set on metrics coming from different resources.
func WithStartTimeOverride(start pcommon.Timestamp) ResourceMetricsOption {
	return resourceMetricsOptionFunc(func(rm pmetric.ResourceMetrics) {
		var dps pmetric.NumberDataPointSlice
		metrics := rm.ScopeMetrics().At(0).Metrics()
		for i := 0; i < metrics.Len(); i++ {
			switch metrics.At(i).Type() {
			case pmetric.MetricTypeGauge:
				dps = metrics.At(i).Gauge().DataPoints()
			case pmetric.MetricTypeSum:
				dps = metrics.At(i).Sum().DataPoints()
			}
			for j := 0; j < dps.Len(); j++ {
				dps.At(j).SetStartTimestamp(start)
			}
		}
	})
}

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead.
// Resource attributes should be provided as ResourceMetricsOption arguments.
func (mb *MetricsBuilder) EmitForResource(options ...ResourceMetricsOption) {
	rm := pmetric.NewResourceMetrics()
	ils := rm.ScopeMetrics().AppendEmpty()
	ils.Scope().SetName(ScopeName)
	ils.Scope().SetVersion(mb.buildInfo.Version)
	ils.Metrics().EnsureCapacity(mb.metricsCapacity)
	mb.metricNewrelicoracledbAsmDiskgroupFreeMb.emit(ils.Metrics())
	mb.metricNewrelicoracledbAsmDiskgroupOfflineDisks.emit(ils.Metrics())
	mb.metricNewrelicoracledbAsmDiskgroupTotalMb.emit(ils.Metrics())
	mb.metricNewrelicoracledbConnectionActiveSessions.emit(ils.Metrics())
	mb.metricNewrelicoracledbConnectionBlockingSessions.emit(ils.Metrics())
	mb.metricNewrelicoracledbConnectionBytesReceived.emit(ils.Metrics())
	mb.metricNewrelicoracledbConnectionBytesSent.emit(ils.Metrics())
	mb.metricNewrelicoracledbConnectionCircuits.emit(ils.Metrics())
	mb.metricNewrelicoracledbConnectionDispatchers.emit(ils.Metrics())
	mb.metricNewrelicoracledbConnectionExecuteCount.emit(ils.Metrics())
	mb.metricNewrelicoracledbConnectionInactiveSessions.emit(ils.Metrics())
	mb.metricNewrelicoracledbConnectionLogonsCumulative.emit(ils.Metrics())
	mb.metricNewrelicoracledbConnectionLogonsCurrent.emit(ils.Metrics())
	mb.metricNewrelicoracledbConnectionParseCountHard.emit(ils.Metrics())
	mb.metricNewrelicoracledbConnectionParseCountTotal.emit(ils.Metrics())
	mb.metricNewrelicoracledbConnectionResourceCurrentUtilization.emit(ils.Metrics())
	mb.metricNewrelicoracledbConnectionResourceLimit.emit(ils.Metrics())
	mb.metricNewrelicoracledbConnectionResourceMaxUtilization.emit(ils.Metrics())
	mb.metricNewrelicoracledbConnectionSessionCPUUsage.emit(ils.Metrics())
	mb.metricNewrelicoracledbConnectionSessionIdleTime.emit(ils.Metrics())
	mb.metricNewrelicoracledbConnectionSessionLogicalReads.emit(ils.Metrics())
	mb.metricNewrelicoracledbConnectionSessionPgaMemory.emit(ils.Metrics())
	mb.metricNewrelicoracledbConnectionSessionsByStatus.emit(ils.Metrics())
	mb.metricNewrelicoracledbConnectionSessionsByType.emit(ils.Metrics())
	mb.metricNewrelicoracledbConnectionSharedServers.emit(ils.Metrics())
	mb.metricNewrelicoracledbConnectionSqlnetRoundtrips.emit(ils.Metrics())
	mb.metricNewrelicoracledbConnectionTotalSessions.emit(ils.Metrics())
	mb.metricNewrelicoracledbConnectionUserCommits.emit(ils.Metrics())
	mb.metricNewrelicoracledbConnectionUserRollbacks.emit(ils.Metrics())
	mb.metricNewrelicoracledbConnectionWaitEventAvgWaitTime.emit(ils.Metrics())
	mb.metricNewrelicoracledbConnectionWaitEventTimeWaited.emit(ils.Metrics())
	mb.metricNewrelicoracledbConnectionWaitEventTotalWaits.emit(ils.Metrics())
	mb.metricNewrelicoracledbConnectionWaitEvents.emit(ils.Metrics())
	mb.metricNewrelicoracledbContainerRestricted.emit(ils.Metrics())
	mb.metricNewrelicoracledbContainerStatus.emit(ils.Metrics())
	mb.metricNewrelicoracledbDatafileAutoextensible.emit(ils.Metrics())
	mb.metricNewrelicoracledbDatafileSizeBytes.emit(ils.Metrics())
	mb.metricNewrelicoracledbDatafileUsedBytes.emit(ils.Metrics())
	mb.metricNewrelicoracledbDbID.emit(ils.Metrics())
	mb.metricNewrelicoracledbDiskBlocksRead.emit(ils.Metrics())
	mb.metricNewrelicoracledbDiskBlocksWritten.emit(ils.Metrics())
	mb.metricNewrelicoracledbDiskReadTimeMilliseconds.emit(ils.Metrics())
	mb.metricNewrelicoracledbDiskReads.emit(ils.Metrics())
	mb.metricNewrelicoracledbDiskWriteTimeMilliseconds.emit(ils.Metrics())
	mb.metricNewrelicoracledbDiskWrites.emit(ils.Metrics())
	mb.metricNewrelicoracledbGlobalName.emit(ils.Metrics())
	mb.metricNewrelicoracledbLockedAccounts.emit(ils.Metrics())
	mb.metricNewrelicoracledbLongRunningQueries.emit(ils.Metrics())
	mb.metricNewrelicoracledbMemoryPgaAllocatedBytes.emit(ils.Metrics())
	mb.metricNewrelicoracledbMemoryPgaFreeableBytes.emit(ils.Metrics())
	mb.metricNewrelicoracledbMemoryPgaInUseBytes.emit(ils.Metrics())
	mb.metricNewrelicoracledbMemoryPgaMaxSizeBytes.emit(ils.Metrics())
	mb.metricNewrelicoracledbMemorySgaSharedPoolLibraryCacheSharableBytes.emit(ils.Metrics())
	mb.metricNewrelicoracledbMemorySgaSharedPoolLibraryCacheUserBytes.emit(ils.Metrics())
	mb.metricNewrelicoracledbMemorySgaUgaTotalBytes.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbActiveParallelSessions.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbActiveSerialSessions.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbAverageActiveSessions.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbBackgroundCPUUsagePerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbBackgroundTimePerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbBlockChangesPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbBlockChangesPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbCPUTimeRatio.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbCPUUsagePerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbCPUUsagePerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbCurrentLogons.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbCurrentOpenCursors.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbDbPhysicalReadBytesPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbDbPhysicalReadsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbDbPhysicalWriteBytesPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbDbPhysicalWritesPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbExecuteWithoutParseRatio.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbExecutionsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbExecutionsPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbHardParseCountPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbHardParseCountPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbLogicalReadsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbLogicalReadsPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbLogonsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbLogonsPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbNetworkTrafficBytePerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbOpenCursorsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbOpenCursorsPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbOpenMode.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbParseFailureCountPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbPhysicalReadBytesPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbPhysicalReadsPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbPhysicalWriteBytesPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbPhysicalWritesPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbRedoGeneratedBytesPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbRedoGeneratedBytesPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbResponseTimePerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbSessionCount.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbSoftParseRatio.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbSQLServiceResponseTime.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbStatus.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbTotalParseCountPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbTotalParseCountPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbTotalSizeBytes.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbTransactionsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbUserCallsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbUserCallsPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbUserCommitsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbUserCommitsPercentage.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbUserRollbacksPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbUserRollbacksPercentage.emit(ils.Metrics())
	mb.metricNewrelicoracledbPdbWaitTimeRatio.emit(ils.Metrics())
	mb.metricNewrelicoracledbRacInstanceActiveState.emit(ils.Metrics())
	mb.metricNewrelicoracledbRacInstanceArchiverStarted.emit(ils.Metrics())
	mb.metricNewrelicoracledbRacInstanceDatabaseStatus.emit(ils.Metrics())
	mb.metricNewrelicoracledbRacInstanceLoginsAllowed.emit(ils.Metrics())
	mb.metricNewrelicoracledbRacInstanceStatus.emit(ils.Metrics())
	mb.metricNewrelicoracledbRacInstanceUptimeSeconds.emit(ils.Metrics())
	mb.metricNewrelicoracledbRacInstanceVersionInfo.emit(ils.Metrics())
	mb.metricNewrelicoracledbRacServiceClbConfig.emit(ils.Metrics())
	mb.metricNewrelicoracledbRacServiceCreationAgeDays.emit(ils.Metrics())
	mb.metricNewrelicoracledbRacServiceFailoverConfig.emit(ils.Metrics())
	mb.metricNewrelicoracledbRacServiceFailoverDelaySeconds.emit(ils.Metrics())
	mb.metricNewrelicoracledbRacServiceFailoverRetries.emit(ils.Metrics())
	mb.metricNewrelicoracledbRacServiceInstanceID.emit(ils.Metrics())
	mb.metricNewrelicoracledbRacServiceNetworkConfig.emit(ils.Metrics())
	mb.metricNewrelicoracledbRacTotalWaits.emit(ils.Metrics())
	mb.metricNewrelicoracledbRacWaitTime.emit(ils.Metrics())
	mb.metricNewrelicoracledbRedoLogParallelWriteWaits.emit(ils.Metrics())
	mb.metricNewrelicoracledbRedoLogSwitchArchivingNeededWaits.emit(ils.Metrics())
	mb.metricNewrelicoracledbRedoLogSwitchCheckpointIncompleteWaits.emit(ils.Metrics())
	mb.metricNewrelicoracledbRedoLogSwitchCompletionWaits.emit(ils.Metrics())
	mb.metricNewrelicoracledbRollbackSegmentsGets.emit(ils.Metrics())
	mb.metricNewrelicoracledbRollbackSegmentsWaitRatio.emit(ils.Metrics())
	mb.metricNewrelicoracledbRollbackSegmentsWaits.emit(ils.Metrics())
	mb.metricNewrelicoracledbServiceCount.emit(ils.Metrics())
	mb.metricNewrelicoracledbServiceStatus.emit(ils.Metrics())
	mb.metricNewrelicoracledbSessionsCount.emit(ils.Metrics())
	mb.metricNewrelicoracledbSgaBufferBusyWaits.emit(ils.Metrics())
	mb.metricNewrelicoracledbSgaFixedSizeBytes.emit(ils.Metrics())
	mb.metricNewrelicoracledbSgaFreeBufferInspectedWaits.emit(ils.Metrics())
	mb.metricNewrelicoracledbSgaFreeBufferWaits.emit(ils.Metrics())
	mb.metricNewrelicoracledbSgaHitRatio.emit(ils.Metrics())
	mb.metricNewrelicoracledbSgaLogAllocationRetriesRatio.emit(ils.Metrics())
	mb.metricNewrelicoracledbSgaLogBufferRedoAllocationRetries.emit(ils.Metrics())
	mb.metricNewrelicoracledbSgaLogBufferRedoEntries.emit(ils.Metrics())
	mb.metricNewrelicoracledbSgaLogBufferSpaceWaits.emit(ils.Metrics())
	mb.metricNewrelicoracledbSgaRedoBuffersBytes.emit(ils.Metrics())
	mb.metricNewrelicoracledbSgaSharedPoolDictCacheMissRatio.emit(ils.Metrics())
	mb.metricNewrelicoracledbSgaSharedPoolLibraryCacheHitRatio.emit(ils.Metrics())
	mb.metricNewrelicoracledbSgaSharedPoolLibraryCacheReloadRatio.emit(ils.Metrics())
	mb.metricNewrelicoracledbSortsDisk.emit(ils.Metrics())
	mb.metricNewrelicoracledbSortsMemory.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemActiveParallelSessions.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemActiveSerialSessions.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemAverageActiveSessions.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemBackgroundCheckpointsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemBackgroundCPUUsagePerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemBackgroundTimePerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemBranchNodeSplitsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemBranchNodeSplitsPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemBufferCacheHitRatio.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemCapturedUserCalls.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemConsistentReadChangesPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemConsistentReadChangesPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemConsistentReadGetsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemConsistentReadGetsPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemCPUUsagePerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemCPUUsagePerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemCrBlocksCreatedPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemCrBlocksCreatedPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemCrUndoRecordsAppliedPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemCrUndoRecordsAppliedPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemCurrentLogonsCount.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemCurrentOpenCursorsCount.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemCurrentOsLoad.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemCursorCacheHitRatio.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemDatabaseCPUTimeRatio.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemDatabaseTimePerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemDatabaseWaitTimeRatio.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemDbBlockChangesPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemDbBlockChangesPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemDbBlockChangesPerUserCall.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemDbBlockGetsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemDbBlockGetsPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemDbBlockGetsPerUserCall.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemDbwrCheckpointsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemDiskSortPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemDiskSortPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemEnqueueDeadlocksPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemEnqueueDeadlocksPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemEnqueueRequestsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemEnqueueRequestsPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemEnqueueTimeoutsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemEnqueueTimeoutsPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemEnqueueWaitsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemEnqueueWaitsPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemExecuteWithoutParseRatio.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemExecutionsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemExecutionsPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemExecutionsPerUserCall.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemFullIndexScansPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemFullIndexScansPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemGcCrBlockReceivedPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemGcCrBlockReceivedPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemGcCurrentBlockReceivedPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemGcCurrentBlockReceivedPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemGlobalCacheAverageCrGetTime.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemGlobalCacheAverageCurrentGetTime.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemGlobalCacheBlocksCorrupted.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemGlobalCacheBlocksLost.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemHardParseCountPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemHardParseCountPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemHostCPUUsagePerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemHostCPUUtilization.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemIoMegabytesPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemIoRequestsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemLeafNodeSplitsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemLeafNodeSplitsPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemLibraryCacheHitRatio.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemLibraryCacheMissRatio.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemLogicalReadsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemLogicalReadsPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemLogicalReadsPerUserCall.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemLogonsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemLogonsPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemLongTableScansPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemLongTableScansPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemMemorySortsRatio.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemNetworkTrafficVolumePerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemOpenCursorsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemOpenCursorsPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemParseFailureCountPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemParseFailureCountPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemPgaCacheHitPercentage.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemPhysicalLobsReadsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemPhysicalLobsReadsPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemPhysicalLobsWritesPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemPhysicalLobsWritesPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemPhysicalReadBytesPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemPhysicalReadIoRequestsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemPhysicalReadTotalBytesPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemPhysicalReadTotalIoRequestsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemPhysicalReadsDirectPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemPhysicalReadsDirectPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemPhysicalReadsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemPhysicalReadsPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemPhysicalWriteBytesPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemPhysicalWriteIoRequestsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemPhysicalWriteTotalBytesPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemPhysicalWriteTotalIoRequestsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemPhysicalWritesDirectPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemPhysicalWritesDirectPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemPhysicalWritesPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemPhysicalWritesPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemProcessLimitPercentage.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemRecursiveCallsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemRecursiveCallsPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemRedoAllocationHitRatio.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemRedoGeneratedBytesPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemRedoGeneratedBytesPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemRedoWritesPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemRedoWritesPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemResponseTimePerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemRowCacheHitRatio.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemRowCacheMissRatio.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemRowsPerSort.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemSessionCount.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemSessionLimitPercentage.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemSharedPoolFreePercentage.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemSoftParseRatio.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemSQLServiceResponseTime.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemStreamsPoolUsagePercentage.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemTempSpaceUsed.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemTotalIndexScansPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemTotalIndexScansPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemTotalParseCountPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemTotalParseCountPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemTotalSortsPerUserCall.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemTotalTableScansPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemTotalTableScansPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemTotalTableScansPerUserCall.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemTransactionsPerLogon.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemTransactionsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemUserCallsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemUserCallsPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemUserCallsRatio.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemUserCommitsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemUserCommitsPercentage.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemUserLimitPercentage.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemUserRollbacksPerSecond.emit(ils.Metrics())
	mb.metricNewrelicoracledbSystemUserRollbacksPercentage.emit(ils.Metrics())
	mb.metricNewrelicoracledbTablespaceDbID.emit(ils.Metrics())
	mb.metricNewrelicoracledbTablespaceGlobalName.emit(ils.Metrics())
	mb.metricNewrelicoracledbTablespaceIsOffline.emit(ils.Metrics())
	mb.metricNewrelicoracledbTablespaceOfflineCdbDatafiles.emit(ils.Metrics())
	mb.metricNewrelicoracledbTablespaceOfflinePdbDatafiles.emit(ils.Metrics())
	mb.metricNewrelicoracledbTablespacePdbNonWriteMode.emit(ils.Metrics())
	mb.metricNewrelicoracledbTablespaceSpaceConsumedBytes.emit(ils.Metrics())
	mb.metricNewrelicoracledbTablespaceSpaceReservedBytes.emit(ils.Metrics())
	mb.metricNewrelicoracledbTablespaceSpaceUsedPercentage.emit(ils.Metrics())
	mb.metricNewrelicoracledbTablespaceTotalBytes.emit(ils.Metrics())
	mb.metricNewrelicoracledbTablespaceUsedBytes.emit(ils.Metrics())
	mb.metricNewrelicoracledbTablespaceUsedPercent.emit(ils.Metrics())

	for _, op := range options {
		op.apply(rm)
	}
	for attr, filter := range mb.resourceAttributeIncludeFilter {
		if val, ok := rm.Resource().Attributes().Get(attr); ok && !filter.Matches(val.AsString()) {
			return
		}
	}
	for attr, filter := range mb.resourceAttributeExcludeFilter {
		if val, ok := rm.Resource().Attributes().Get(attr); ok && filter.Matches(val.AsString()) {
			return
		}
	}

	if ils.Metrics().Len() > 0 {
		mb.updateCapacity(rm)
		rm.MoveTo(mb.metricsBuffer.ResourceMetrics().AppendEmpty())
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user config, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit(options ...ResourceMetricsOption) pmetric.Metrics {
	mb.EmitForResource(options...)
	metrics := mb.metricsBuffer
	mb.metricsBuffer = pmetric.NewMetrics()
	return metrics
}

// RecordNewrelicoracledbAsmDiskgroupFreeMbDataPoint adds a data point to newrelicoracledb.asm.diskgroup.free_mb metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbAsmDiskgroupFreeMbDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, diskgroupNameAttributeValue string) {
	mb.metricNewrelicoracledbAsmDiskgroupFreeMb.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, diskgroupNameAttributeValue)
}

// RecordNewrelicoracledbAsmDiskgroupOfflineDisksDataPoint adds a data point to newrelicoracledb.asm.diskgroup.offline_disks metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbAsmDiskgroupOfflineDisksDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, diskgroupNameAttributeValue string) {
	mb.metricNewrelicoracledbAsmDiskgroupOfflineDisks.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, diskgroupNameAttributeValue)
}

// RecordNewrelicoracledbAsmDiskgroupTotalMbDataPoint adds a data point to newrelicoracledb.asm.diskgroup.total_mb metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbAsmDiskgroupTotalMbDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, diskgroupNameAttributeValue string) {
	mb.metricNewrelicoracledbAsmDiskgroupTotalMb.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, diskgroupNameAttributeValue)
}

// RecordNewrelicoracledbConnectionActiveSessionsDataPoint adds a data point to newrelicoracledb.connection.active_sessions metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbConnectionActiveSessionsDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string) {
	mb.metricNewrelicoracledbConnectionActiveSessions.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue)
}

// RecordNewrelicoracledbConnectionBlockingSessionsDataPoint adds a data point to newrelicoracledb.connection.blocking_sessions metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbConnectionBlockingSessionsDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, sessionIDAttributeValue string, blockingSessionIDAttributeValue string, usernameAttributeValue string, waitEventAttributeValue string, programAttributeValue string) {
	mb.metricNewrelicoracledbConnectionBlockingSessions.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, sessionIDAttributeValue, blockingSessionIDAttributeValue, usernameAttributeValue, waitEventAttributeValue, programAttributeValue)
}

// RecordNewrelicoracledbConnectionBytesReceivedDataPoint adds a data point to newrelicoracledb.connection.bytes_received metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbConnectionBytesReceivedDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string) {
	mb.metricNewrelicoracledbConnectionBytesReceived.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue)
}

// RecordNewrelicoracledbConnectionBytesSentDataPoint adds a data point to newrelicoracledb.connection.bytes_sent metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbConnectionBytesSentDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string) {
	mb.metricNewrelicoracledbConnectionBytesSent.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue)
}

// RecordNewrelicoracledbConnectionCircuitsDataPoint adds a data point to newrelicoracledb.connection.circuits metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbConnectionCircuitsDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string) {
	mb.metricNewrelicoracledbConnectionCircuits.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue)
}

// RecordNewrelicoracledbConnectionDispatchersDataPoint adds a data point to newrelicoracledb.connection.dispatchers metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbConnectionDispatchersDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string) {
	mb.metricNewrelicoracledbConnectionDispatchers.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue)
}

// RecordNewrelicoracledbConnectionExecuteCountDataPoint adds a data point to newrelicoracledb.connection.execute_count metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbConnectionExecuteCountDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string) {
	mb.metricNewrelicoracledbConnectionExecuteCount.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue)
}

// RecordNewrelicoracledbConnectionInactiveSessionsDataPoint adds a data point to newrelicoracledb.connection.inactive_sessions metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbConnectionInactiveSessionsDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string) {
	mb.metricNewrelicoracledbConnectionInactiveSessions.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue)
}

// RecordNewrelicoracledbConnectionLogonsCumulativeDataPoint adds a data point to newrelicoracledb.connection.logons_cumulative metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbConnectionLogonsCumulativeDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string) {
	mb.metricNewrelicoracledbConnectionLogonsCumulative.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue)
}

// RecordNewrelicoracledbConnectionLogonsCurrentDataPoint adds a data point to newrelicoracledb.connection.logons_current metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbConnectionLogonsCurrentDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string) {
	mb.metricNewrelicoracledbConnectionLogonsCurrent.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue)
}

// RecordNewrelicoracledbConnectionParseCountHardDataPoint adds a data point to newrelicoracledb.connection.parse_count_hard metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbConnectionParseCountHardDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string) {
	mb.metricNewrelicoracledbConnectionParseCountHard.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue)
}

// RecordNewrelicoracledbConnectionParseCountTotalDataPoint adds a data point to newrelicoracledb.connection.parse_count_total metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbConnectionParseCountTotalDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string) {
	mb.metricNewrelicoracledbConnectionParseCountTotal.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue)
}

// RecordNewrelicoracledbConnectionResourceCurrentUtilizationDataPoint adds a data point to newrelicoracledb.connection.resource_current_utilization metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbConnectionResourceCurrentUtilizationDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, resourceNameAttributeValue string) {
	mb.metricNewrelicoracledbConnectionResourceCurrentUtilization.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, resourceNameAttributeValue)
}

// RecordNewrelicoracledbConnectionResourceLimitDataPoint adds a data point to newrelicoracledb.connection.resource_limit metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbConnectionResourceLimitDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, resourceNameAttributeValue string) {
	mb.metricNewrelicoracledbConnectionResourceLimit.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, resourceNameAttributeValue)
}

// RecordNewrelicoracledbConnectionResourceMaxUtilizationDataPoint adds a data point to newrelicoracledb.connection.resource_max_utilization metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbConnectionResourceMaxUtilizationDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, resourceNameAttributeValue string) {
	mb.metricNewrelicoracledbConnectionResourceMaxUtilization.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, resourceNameAttributeValue)
}

// RecordNewrelicoracledbConnectionSessionCPUUsageDataPoint adds a data point to newrelicoracledb.connection.session_cpu_usage metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbConnectionSessionCPUUsageDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, sessionIDAttributeValue string, usernameAttributeValue string, sessionStatusAttributeValue string, programAttributeValue string) {
	mb.metricNewrelicoracledbConnectionSessionCPUUsage.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, sessionIDAttributeValue, usernameAttributeValue, sessionStatusAttributeValue, programAttributeValue)
}

// RecordNewrelicoracledbConnectionSessionIdleTimeDataPoint adds a data point to newrelicoracledb.connection.session_idle_time metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbConnectionSessionIdleTimeDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, sessionIDAttributeValue string, usernameAttributeValue string, sessionStatusAttributeValue string, programAttributeValue string) {
	mb.metricNewrelicoracledbConnectionSessionIdleTime.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, sessionIDAttributeValue, usernameAttributeValue, sessionStatusAttributeValue, programAttributeValue)
}

// RecordNewrelicoracledbConnectionSessionLogicalReadsDataPoint adds a data point to newrelicoracledb.connection.session_logical_reads metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbConnectionSessionLogicalReadsDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, sessionIDAttributeValue string, usernameAttributeValue string, sessionStatusAttributeValue string, programAttributeValue string) {
	mb.metricNewrelicoracledbConnectionSessionLogicalReads.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, sessionIDAttributeValue, usernameAttributeValue, sessionStatusAttributeValue, programAttributeValue)
}

// RecordNewrelicoracledbConnectionSessionPgaMemoryDataPoint adds a data point to newrelicoracledb.connection.session_pga_memory metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbConnectionSessionPgaMemoryDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, sessionIDAttributeValue string, usernameAttributeValue string, sessionStatusAttributeValue string, programAttributeValue string) {
	mb.metricNewrelicoracledbConnectionSessionPgaMemory.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, sessionIDAttributeValue, usernameAttributeValue, sessionStatusAttributeValue, programAttributeValue)
}

// RecordNewrelicoracledbConnectionSessionsByStatusDataPoint adds a data point to newrelicoracledb.connection.sessions_by_status metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbConnectionSessionsByStatusDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, sessionStatusAttributeValue string) {
	mb.metricNewrelicoracledbConnectionSessionsByStatus.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, sessionStatusAttributeValue)
}

// RecordNewrelicoracledbConnectionSessionsByTypeDataPoint adds a data point to newrelicoracledb.connection.sessions_by_type metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbConnectionSessionsByTypeDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, sessionTypeAttributeValue string) {
	mb.metricNewrelicoracledbConnectionSessionsByType.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, sessionTypeAttributeValue)
}

// RecordNewrelicoracledbConnectionSharedServersDataPoint adds a data point to newrelicoracledb.connection.shared_servers metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbConnectionSharedServersDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string) {
	mb.metricNewrelicoracledbConnectionSharedServers.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue)
}

// RecordNewrelicoracledbConnectionSqlnetRoundtripsDataPoint adds a data point to newrelicoracledb.connection.sqlnet_roundtrips metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbConnectionSqlnetRoundtripsDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string) {
	mb.metricNewrelicoracledbConnectionSqlnetRoundtrips.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue)
}

// RecordNewrelicoracledbConnectionTotalSessionsDataPoint adds a data point to newrelicoracledb.connection.total_sessions metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbConnectionTotalSessionsDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string) {
	mb.metricNewrelicoracledbConnectionTotalSessions.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue)
}

// RecordNewrelicoracledbConnectionUserCommitsDataPoint adds a data point to newrelicoracledb.connection.user_commits metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbConnectionUserCommitsDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string) {
	mb.metricNewrelicoracledbConnectionUserCommits.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue)
}

// RecordNewrelicoracledbConnectionUserRollbacksDataPoint adds a data point to newrelicoracledb.connection.user_rollbacks metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbConnectionUserRollbacksDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string) {
	mb.metricNewrelicoracledbConnectionUserRollbacks.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue)
}

// RecordNewrelicoracledbConnectionWaitEventAvgWaitTimeDataPoint adds a data point to newrelicoracledb.connection.wait_event_avg_wait_time metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbConnectionWaitEventAvgWaitTimeDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, waitEventAttributeValue string, waitClassAttributeValue string) {
	mb.metricNewrelicoracledbConnectionWaitEventAvgWaitTime.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, waitEventAttributeValue, waitClassAttributeValue)
}

// RecordNewrelicoracledbConnectionWaitEventTimeWaitedDataPoint adds a data point to newrelicoracledb.connection.wait_event_time_waited metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbConnectionWaitEventTimeWaitedDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, waitEventAttributeValue string, waitClassAttributeValue string) {
	mb.metricNewrelicoracledbConnectionWaitEventTimeWaited.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, waitEventAttributeValue, waitClassAttributeValue)
}

// RecordNewrelicoracledbConnectionWaitEventTotalWaitsDataPoint adds a data point to newrelicoracledb.connection.wait_event_total_waits metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbConnectionWaitEventTotalWaitsDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, waitEventAttributeValue string, waitClassAttributeValue string) {
	mb.metricNewrelicoracledbConnectionWaitEventTotalWaits.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, waitEventAttributeValue, waitClassAttributeValue)
}

// RecordNewrelicoracledbConnectionWaitEventsDataPoint adds a data point to newrelicoracledb.connection.wait_events metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbConnectionWaitEventsDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, sessionIDAttributeValue string, usernameAttributeValue string, waitEventAttributeValue string, waitStateAttributeValue string, waitClassAttributeValue string) {
	mb.metricNewrelicoracledbConnectionWaitEvents.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, sessionIDAttributeValue, usernameAttributeValue, waitEventAttributeValue, waitStateAttributeValue, waitClassAttributeValue)
}

// RecordNewrelicoracledbContainerRestrictedDataPoint adds a data point to newrelicoracledb.container.restricted metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbContainerRestrictedDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, conIDAttributeValue string, containerNameAttributeValue string, restrictedStatusAttributeValue string) {
	mb.metricNewrelicoracledbContainerRestricted.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, conIDAttributeValue, containerNameAttributeValue, restrictedStatusAttributeValue)
}

// RecordNewrelicoracledbContainerStatusDataPoint adds a data point to newrelicoracledb.container.status metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbContainerStatusDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, conIDAttributeValue string, containerNameAttributeValue string, openModeAttributeValue string) {
	mb.metricNewrelicoracledbContainerStatus.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, conIDAttributeValue, containerNameAttributeValue, openModeAttributeValue)
}

// RecordNewrelicoracledbDatafileAutoextensibleDataPoint adds a data point to newrelicoracledb.datafile.autoextensible metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbDatafileAutoextensibleDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, conIDAttributeValue string, tablespaceNameAttributeValue string, fileNameAttributeValue string, containerStatusAttributeValue string) {
	mb.metricNewrelicoracledbDatafileAutoextensible.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, conIDAttributeValue, tablespaceNameAttributeValue, fileNameAttributeValue, containerStatusAttributeValue)
}

// RecordNewrelicoracledbDatafileSizeBytesDataPoint adds a data point to newrelicoracledb.datafile.size_bytes metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbDatafileSizeBytesDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, conIDAttributeValue string, tablespaceNameAttributeValue string, fileNameAttributeValue string) {
	mb.metricNewrelicoracledbDatafileSizeBytes.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, conIDAttributeValue, tablespaceNameAttributeValue, fileNameAttributeValue)
}

// RecordNewrelicoracledbDatafileUsedBytesDataPoint adds a data point to newrelicoracledb.datafile.used_bytes metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbDatafileUsedBytesDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, conIDAttributeValue string, tablespaceNameAttributeValue string, fileNameAttributeValue string) {
	mb.metricNewrelicoracledbDatafileUsedBytes.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, conIDAttributeValue, tablespaceNameAttributeValue, fileNameAttributeValue)
}

// RecordNewrelicoracledbDbIDDataPoint adds a data point to newrelicoracledb.db_id metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbDbIDDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string, dbIDAttributeValue string) {
	mb.metricNewrelicoracledbDbID.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue, dbIDAttributeValue)
}

// RecordNewrelicoracledbDiskBlocksReadDataPoint adds a data point to newrelicoracledb.disk.blocks_read metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbDiskBlocksReadDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbDiskBlocksRead.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbDiskBlocksWrittenDataPoint adds a data point to newrelicoracledb.disk.blocks_written metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbDiskBlocksWrittenDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbDiskBlocksWritten.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbDiskReadTimeMillisecondsDataPoint adds a data point to newrelicoracledb.disk.read_time_milliseconds metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbDiskReadTimeMillisecondsDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbDiskReadTimeMilliseconds.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbDiskReadsDataPoint adds a data point to newrelicoracledb.disk.reads metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbDiskReadsDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbDiskReads.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbDiskWriteTimeMillisecondsDataPoint adds a data point to newrelicoracledb.disk.write_time_milliseconds metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbDiskWriteTimeMillisecondsDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbDiskWriteTimeMilliseconds.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbDiskWritesDataPoint adds a data point to newrelicoracledb.disk.writes metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbDiskWritesDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbDiskWrites.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbGlobalNameDataPoint adds a data point to newrelicoracledb.global_name metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbGlobalNameDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string, globalNameAttributeValue string) {
	mb.metricNewrelicoracledbGlobalName.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue, globalNameAttributeValue)
}

// RecordNewrelicoracledbLockedAccountsDataPoint adds a data point to newrelicoracledb.locked_accounts metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbLockedAccountsDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbLockedAccounts.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbLongRunningQueriesDataPoint adds a data point to newrelicoracledb.long_running_queries metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbLongRunningQueriesDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbLongRunningQueries.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbMemoryPgaAllocatedBytesDataPoint adds a data point to newrelicoracledb.memory.pga_allocated_bytes metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbMemoryPgaAllocatedBytesDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbMemoryPgaAllocatedBytes.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbMemoryPgaFreeableBytesDataPoint adds a data point to newrelicoracledb.memory.pga_freeable_bytes metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbMemoryPgaFreeableBytesDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbMemoryPgaFreeableBytes.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbMemoryPgaInUseBytesDataPoint adds a data point to newrelicoracledb.memory.pga_in_use_bytes metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbMemoryPgaInUseBytesDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbMemoryPgaInUseBytes.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbMemoryPgaMaxSizeBytesDataPoint adds a data point to newrelicoracledb.memory.pga_max_size_bytes metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbMemoryPgaMaxSizeBytesDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbMemoryPgaMaxSizeBytes.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbMemorySgaSharedPoolLibraryCacheSharableBytesDataPoint adds a data point to newrelicoracledb.memory.sga_shared_pool_library_cache_sharable_bytes metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbMemorySgaSharedPoolLibraryCacheSharableBytesDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbMemorySgaSharedPoolLibraryCacheSharableBytes.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbMemorySgaSharedPoolLibraryCacheUserBytesDataPoint adds a data point to newrelicoracledb.memory.sga_shared_pool_library_cache_user_bytes metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbMemorySgaSharedPoolLibraryCacheUserBytesDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbMemorySgaSharedPoolLibraryCacheUserBytes.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbMemorySgaUgaTotalBytesDataPoint adds a data point to newrelicoracledb.memory.sga_uga_total_bytes metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbMemorySgaUgaTotalBytesDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbMemorySgaUgaTotalBytes.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbActiveParallelSessionsDataPoint adds a data point to newrelicoracledb.pdb.active_parallel_sessions metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbActiveParallelSessionsDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbActiveParallelSessions.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbActiveSerialSessionsDataPoint adds a data point to newrelicoracledb.pdb.active_serial_sessions metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbActiveSerialSessionsDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbActiveSerialSessions.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbAverageActiveSessionsDataPoint adds a data point to newrelicoracledb.pdb.average_active_sessions metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbAverageActiveSessionsDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbAverageActiveSessions.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbBackgroundCPUUsagePerSecondDataPoint adds a data point to newrelicoracledb.pdb.background_cpu_usage_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbBackgroundCPUUsagePerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbBackgroundCPUUsagePerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbBackgroundTimePerSecondDataPoint adds a data point to newrelicoracledb.pdb.background_time_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbBackgroundTimePerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbBackgroundTimePerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbBlockChangesPerSecondDataPoint adds a data point to newrelicoracledb.pdb.block_changes_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbBlockChangesPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbBlockChangesPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbBlockChangesPerTransactionDataPoint adds a data point to newrelicoracledb.pdb.block_changes_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbBlockChangesPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbBlockChangesPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbCPUTimeRatioDataPoint adds a data point to newrelicoracledb.pdb.cpu_time_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbCPUTimeRatioDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbCPUTimeRatio.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbCPUUsagePerSecondDataPoint adds a data point to newrelicoracledb.pdb.cpu_usage_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbCPUUsagePerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbCPUUsagePerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbCPUUsagePerTransactionDataPoint adds a data point to newrelicoracledb.pdb.cpu_usage_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbCPUUsagePerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbCPUUsagePerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbCurrentLogonsDataPoint adds a data point to newrelicoracledb.pdb.current_logons metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbCurrentLogonsDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbCurrentLogons.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbCurrentOpenCursorsDataPoint adds a data point to newrelicoracledb.pdb.current_open_cursors metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbCurrentOpenCursorsDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbCurrentOpenCursors.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbDbPhysicalReadBytesPerSecondDataPoint adds a data point to newrelicoracledb.pdb.db_physical_read_bytes_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbDbPhysicalReadBytesPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbDbPhysicalReadBytesPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbDbPhysicalReadsPerSecondDataPoint adds a data point to newrelicoracledb.pdb.db_physical_reads_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbDbPhysicalReadsPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbDbPhysicalReadsPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbDbPhysicalWriteBytesPerSecondDataPoint adds a data point to newrelicoracledb.pdb.db_physical_write_bytes_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbDbPhysicalWriteBytesPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbDbPhysicalWriteBytesPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbDbPhysicalWritesPerSecondDataPoint adds a data point to newrelicoracledb.pdb.db_physical_writes_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbDbPhysicalWritesPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbDbPhysicalWritesPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbExecuteWithoutParseRatioDataPoint adds a data point to newrelicoracledb.pdb.execute_without_parse_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbExecuteWithoutParseRatioDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbExecuteWithoutParseRatio.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbExecutionsPerSecondDataPoint adds a data point to newrelicoracledb.pdb.executions_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbExecutionsPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbExecutionsPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbExecutionsPerTransactionDataPoint adds a data point to newrelicoracledb.pdb.executions_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbExecutionsPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbExecutionsPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbHardParseCountPerSecondDataPoint adds a data point to newrelicoracledb.pdb.hard_parse_count_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbHardParseCountPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbHardParseCountPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbHardParseCountPerTransactionDataPoint adds a data point to newrelicoracledb.pdb.hard_parse_count_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbHardParseCountPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbHardParseCountPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbLogicalReadsPerSecondDataPoint adds a data point to newrelicoracledb.pdb.logical_reads_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbLogicalReadsPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbLogicalReadsPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbLogicalReadsPerTransactionDataPoint adds a data point to newrelicoracledb.pdb.logical_reads_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbLogicalReadsPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbLogicalReadsPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbLogonsPerSecondDataPoint adds a data point to newrelicoracledb.pdb.logons_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbLogonsPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbLogonsPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbLogonsPerTransactionDataPoint adds a data point to newrelicoracledb.pdb.logons_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbLogonsPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbLogonsPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbNetworkTrafficBytePerSecondDataPoint adds a data point to newrelicoracledb.pdb.network_traffic_byte_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbNetworkTrafficBytePerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbNetworkTrafficBytePerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbOpenCursorsPerSecondDataPoint adds a data point to newrelicoracledb.pdb.open_cursors_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbOpenCursorsPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbOpenCursorsPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbOpenCursorsPerTransactionDataPoint adds a data point to newrelicoracledb.pdb.open_cursors_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbOpenCursorsPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbOpenCursorsPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbOpenModeDataPoint adds a data point to newrelicoracledb.pdb.open_mode metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbOpenModeDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, conIDAttributeValue string, pdbNameAttributeValue string, openModeAttributeValue string) {
	mb.metricNewrelicoracledbPdbOpenMode.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, conIDAttributeValue, pdbNameAttributeValue, openModeAttributeValue)
}

// RecordNewrelicoracledbPdbParseFailureCountPerSecondDataPoint adds a data point to newrelicoracledb.pdb.parse_failure_count_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbParseFailureCountPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbParseFailureCountPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbPhysicalReadBytesPerSecondDataPoint adds a data point to newrelicoracledb.pdb.physical_read_bytes_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbPhysicalReadBytesPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbPhysicalReadBytesPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbPhysicalReadsPerTransactionDataPoint adds a data point to newrelicoracledb.pdb.physical_reads_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbPhysicalReadsPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbPhysicalReadsPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbPhysicalWriteBytesPerSecondDataPoint adds a data point to newrelicoracledb.pdb.physical_write_bytes_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbPhysicalWriteBytesPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbPhysicalWriteBytesPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbPhysicalWritesPerTransactionDataPoint adds a data point to newrelicoracledb.pdb.physical_writes_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbPhysicalWritesPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbPhysicalWritesPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbRedoGeneratedBytesPerSecondDataPoint adds a data point to newrelicoracledb.pdb.redo_generated_bytes_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbRedoGeneratedBytesPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbRedoGeneratedBytesPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbRedoGeneratedBytesPerTransactionDataPoint adds a data point to newrelicoracledb.pdb.redo_generated_bytes_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbRedoGeneratedBytesPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbRedoGeneratedBytesPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbResponseTimePerTransactionDataPoint adds a data point to newrelicoracledb.pdb.response_time_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbResponseTimePerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbResponseTimePerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbSessionCountDataPoint adds a data point to newrelicoracledb.pdb.session_count metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbSessionCountDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbSessionCount.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbSoftParseRatioDataPoint adds a data point to newrelicoracledb.pdb.soft_parse_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbSoftParseRatioDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbSoftParseRatio.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbSQLServiceResponseTimeDataPoint adds a data point to newrelicoracledb.pdb.sql_service_response_time metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbSQLServiceResponseTimeDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbSQLServiceResponseTime.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbStatusDataPoint adds a data point to newrelicoracledb.pdb.status metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbStatusDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, conIDAttributeValue string, pdbNameAttributeValue string, containerStatusAttributeValue string) {
	mb.metricNewrelicoracledbPdbStatus.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, conIDAttributeValue, pdbNameAttributeValue, containerStatusAttributeValue)
}

// RecordNewrelicoracledbPdbTotalParseCountPerSecondDataPoint adds a data point to newrelicoracledb.pdb.total_parse_count_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbTotalParseCountPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbTotalParseCountPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbTotalParseCountPerTransactionDataPoint adds a data point to newrelicoracledb.pdb.total_parse_count_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbTotalParseCountPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbTotalParseCountPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbTotalSizeBytesDataPoint adds a data point to newrelicoracledb.pdb.total_size_bytes metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbTotalSizeBytesDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, conIDAttributeValue string, pdbNameAttributeValue string) {
	mb.metricNewrelicoracledbPdbTotalSizeBytes.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, conIDAttributeValue, pdbNameAttributeValue)
}

// RecordNewrelicoracledbPdbTransactionsPerSecondDataPoint adds a data point to newrelicoracledb.pdb.transactions_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbTransactionsPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbTransactionsPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbUserCallsPerSecondDataPoint adds a data point to newrelicoracledb.pdb.user_calls_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbUserCallsPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbUserCallsPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbUserCallsPerTransactionDataPoint adds a data point to newrelicoracledb.pdb.user_calls_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbUserCallsPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbUserCallsPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbUserCommitsPerSecondDataPoint adds a data point to newrelicoracledb.pdb.user_commits_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbUserCommitsPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbUserCommitsPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbUserCommitsPercentageDataPoint adds a data point to newrelicoracledb.pdb.user_commits_percentage metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbUserCommitsPercentageDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbUserCommitsPercentage.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbUserRollbacksPerSecondDataPoint adds a data point to newrelicoracledb.pdb.user_rollbacks_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbUserRollbacksPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbUserRollbacksPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbUserRollbacksPercentageDataPoint adds a data point to newrelicoracledb.pdb.user_rollbacks_percentage metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbUserRollbacksPercentageDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbUserRollbacksPercentage.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbPdbWaitTimeRatioDataPoint adds a data point to newrelicoracledb.pdb.wait_time_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbPdbWaitTimeRatioDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbPdbWaitTimeRatio.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbRacInstanceActiveStateDataPoint adds a data point to newrelicoracledb.rac.instance.active_state metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbRacInstanceActiveStateDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string, racInstanceNameAttributeValue string, hostNameRacAttributeValue string, activeStateAttributeValue string) {
	mb.metricNewrelicoracledbRacInstanceActiveState.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue, racInstanceNameAttributeValue, hostNameRacAttributeValue, activeStateAttributeValue)
}

// RecordNewrelicoracledbRacInstanceArchiverStartedDataPoint adds a data point to newrelicoracledb.rac.instance.archiver_started metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbRacInstanceArchiverStartedDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string, racInstanceNameAttributeValue string, hostNameRacAttributeValue string, archiverStatusAttributeValue string) {
	mb.metricNewrelicoracledbRacInstanceArchiverStarted.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue, racInstanceNameAttributeValue, hostNameRacAttributeValue, archiverStatusAttributeValue)
}

// RecordNewrelicoracledbRacInstanceDatabaseStatusDataPoint adds a data point to newrelicoracledb.rac.instance.database_status metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbRacInstanceDatabaseStatusDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string, racInstanceNameAttributeValue string, hostNameRacAttributeValue string, databaseStatusAttributeValue string) {
	mb.metricNewrelicoracledbRacInstanceDatabaseStatus.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue, racInstanceNameAttributeValue, hostNameRacAttributeValue, databaseStatusAttributeValue)
}

// RecordNewrelicoracledbRacInstanceLoginsAllowedDataPoint adds a data point to newrelicoracledb.rac.instance.logins_allowed metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbRacInstanceLoginsAllowedDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string, racInstanceNameAttributeValue string, hostNameRacAttributeValue string, loginsStatusAttributeValue string) {
	mb.metricNewrelicoracledbRacInstanceLoginsAllowed.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue, racInstanceNameAttributeValue, hostNameRacAttributeValue, loginsStatusAttributeValue)
}

// RecordNewrelicoracledbRacInstanceStatusDataPoint adds a data point to newrelicoracledb.rac.instance.status metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbRacInstanceStatusDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string, racInstanceNameAttributeValue string, hostNameRacAttributeValue string, instanceStatusAttributeValue string) {
	mb.metricNewrelicoracledbRacInstanceStatus.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue, racInstanceNameAttributeValue, hostNameRacAttributeValue, instanceStatusAttributeValue)
}

// RecordNewrelicoracledbRacInstanceUptimeSecondsDataPoint adds a data point to newrelicoracledb.rac.instance.uptime_seconds metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbRacInstanceUptimeSecondsDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string, racInstanceNameAttributeValue string, hostNameRacAttributeValue string) {
	mb.metricNewrelicoracledbRacInstanceUptimeSeconds.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue, racInstanceNameAttributeValue, hostNameRacAttributeValue)
}

// RecordNewrelicoracledbRacInstanceVersionInfoDataPoint adds a data point to newrelicoracledb.rac.instance.version_info metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbRacInstanceVersionInfoDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string, racInstanceNameAttributeValue string, hostNameRacAttributeValue string, oracleVersionAttributeValue string) {
	mb.metricNewrelicoracledbRacInstanceVersionInfo.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue, racInstanceNameAttributeValue, hostNameRacAttributeValue, oracleVersionAttributeValue)
}

// RecordNewrelicoracledbRacServiceClbConfigDataPoint adds a data point to newrelicoracledb.rac.service.clb_config metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbRacServiceClbConfigDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, serviceNameAttributeValue string, instanceIDAttributeValue string, clbGoalAttributeValue string) {
	mb.metricNewrelicoracledbRacServiceClbConfig.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, serviceNameAttributeValue, instanceIDAttributeValue, clbGoalAttributeValue)
}

// RecordNewrelicoracledbRacServiceCreationAgeDaysDataPoint adds a data point to newrelicoracledb.rac.service.creation_age_days metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbRacServiceCreationAgeDaysDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, serviceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbRacServiceCreationAgeDays.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, serviceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbRacServiceFailoverConfigDataPoint adds a data point to newrelicoracledb.rac.service.failover_config metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbRacServiceFailoverConfigDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, serviceNameAttributeValue string, instanceIDAttributeValue string, failoverMethodAttributeValue string, failoverTypeAttributeValue string, serviceGoalAttributeValue string) {
	mb.metricNewrelicoracledbRacServiceFailoverConfig.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, serviceNameAttributeValue, instanceIDAttributeValue, failoverMethodAttributeValue, failoverTypeAttributeValue, serviceGoalAttributeValue)
}

// RecordNewrelicoracledbRacServiceFailoverDelaySecondsDataPoint adds a data point to newrelicoracledb.rac.service.failover_delay_seconds metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbRacServiceFailoverDelaySecondsDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, serviceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbRacServiceFailoverDelaySeconds.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, serviceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbRacServiceFailoverRetriesDataPoint adds a data point to newrelicoracledb.rac.service.failover_retries metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbRacServiceFailoverRetriesDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, serviceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbRacServiceFailoverRetries.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, serviceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbRacServiceInstanceIDDataPoint adds a data point to newrelicoracledb.rac.service.instance_id metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbRacServiceInstanceIDDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, serviceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbRacServiceInstanceID.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, serviceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbRacServiceNetworkConfigDataPoint adds a data point to newrelicoracledb.rac.service.network_config metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbRacServiceNetworkConfigDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, serviceNameAttributeValue string, instanceIDAttributeValue string, networkNameAttributeValue string) {
	mb.metricNewrelicoracledbRacServiceNetworkConfig.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, serviceNameAttributeValue, instanceIDAttributeValue, networkNameAttributeValue)
}

// RecordNewrelicoracledbRacTotalWaitsDataPoint adds a data point to newrelicoracledb.rac.total_waits metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbRacTotalWaitsDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string, waitEventAttributeValue string) {
	mb.metricNewrelicoracledbRacTotalWaits.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue, waitEventAttributeValue)
}

// RecordNewrelicoracledbRacWaitTimeDataPoint adds a data point to newrelicoracledb.rac.wait_time metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbRacWaitTimeDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string, waitEventAttributeValue string) {
	mb.metricNewrelicoracledbRacWaitTime.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue, waitEventAttributeValue)
}

// RecordNewrelicoracledbRedoLogParallelWriteWaitsDataPoint adds a data point to newrelicoracledb.redo_log_parallel_write_waits metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbRedoLogParallelWriteWaitsDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbRedoLogParallelWriteWaits.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbRedoLogSwitchArchivingNeededWaitsDataPoint adds a data point to newrelicoracledb.redo_log_switch_archiving_needed_waits metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbRedoLogSwitchArchivingNeededWaitsDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbRedoLogSwitchArchivingNeededWaits.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbRedoLogSwitchCheckpointIncompleteWaitsDataPoint adds a data point to newrelicoracledb.redo_log_switch_checkpoint_incomplete_waits metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbRedoLogSwitchCheckpointIncompleteWaitsDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbRedoLogSwitchCheckpointIncompleteWaits.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbRedoLogSwitchCompletionWaitsDataPoint adds a data point to newrelicoracledb.redo_log_switch_completion_waits metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbRedoLogSwitchCompletionWaitsDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbRedoLogSwitchCompletionWaits.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbRollbackSegmentsGetsDataPoint adds a data point to newrelicoracledb.rollback_segments_gets metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbRollbackSegmentsGetsDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbRollbackSegmentsGets.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbRollbackSegmentsWaitRatioDataPoint adds a data point to newrelicoracledb.rollback_segments_wait_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbRollbackSegmentsWaitRatioDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbRollbackSegmentsWaitRatio.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbRollbackSegmentsWaitsDataPoint adds a data point to newrelicoracledb.rollback_segments_waits metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbRollbackSegmentsWaitsDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbRollbackSegmentsWaits.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbServiceCountDataPoint adds a data point to newrelicoracledb.service.count metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbServiceCountDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, conIDAttributeValue string) {
	mb.metricNewrelicoracledbServiceCount.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, conIDAttributeValue)
}

// RecordNewrelicoracledbServiceStatusDataPoint adds a data point to newrelicoracledb.service.status metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbServiceStatusDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, conIDAttributeValue string, serviceNameAttributeValue string) {
	mb.metricNewrelicoracledbServiceStatus.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, conIDAttributeValue, serviceNameAttributeValue)
}

// RecordNewrelicoracledbSessionsCountDataPoint adds a data point to newrelicoracledb.sessions.count metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSessionsCountDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string) {
	mb.metricNewrelicoracledbSessionsCount.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue)
}

// RecordNewrelicoracledbSgaBufferBusyWaitsDataPoint adds a data point to newrelicoracledb.sga_buffer_busy_waits metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSgaBufferBusyWaitsDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSgaBufferBusyWaits.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSgaFixedSizeBytesDataPoint adds a data point to newrelicoracledb.sga_fixed_size_bytes metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSgaFixedSizeBytesDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSgaFixedSizeBytes.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSgaFreeBufferInspectedWaitsDataPoint adds a data point to newrelicoracledb.sga_free_buffer_inspected_waits metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSgaFreeBufferInspectedWaitsDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSgaFreeBufferInspectedWaits.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSgaFreeBufferWaitsDataPoint adds a data point to newrelicoracledb.sga_free_buffer_waits metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSgaFreeBufferWaitsDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSgaFreeBufferWaits.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSgaHitRatioDataPoint adds a data point to newrelicoracledb.sga_hit_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSgaHitRatioDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSgaHitRatio.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSgaLogAllocationRetriesRatioDataPoint adds a data point to newrelicoracledb.sga_log_allocation_retries_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSgaLogAllocationRetriesRatioDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSgaLogAllocationRetriesRatio.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSgaLogBufferRedoAllocationRetriesDataPoint adds a data point to newrelicoracledb.sga_log_buffer_redo_allocation_retries metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSgaLogBufferRedoAllocationRetriesDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSgaLogBufferRedoAllocationRetries.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSgaLogBufferRedoEntriesDataPoint adds a data point to newrelicoracledb.sga_log_buffer_redo_entries metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSgaLogBufferRedoEntriesDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSgaLogBufferRedoEntries.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSgaLogBufferSpaceWaitsDataPoint adds a data point to newrelicoracledb.sga_log_buffer_space_waits metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSgaLogBufferSpaceWaitsDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSgaLogBufferSpaceWaits.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSgaRedoBuffersBytesDataPoint adds a data point to newrelicoracledb.sga_redo_buffers_bytes metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSgaRedoBuffersBytesDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSgaRedoBuffersBytes.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSgaSharedPoolDictCacheMissRatioDataPoint adds a data point to newrelicoracledb.sga_shared_pool_dict_cache_miss_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSgaSharedPoolDictCacheMissRatioDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSgaSharedPoolDictCacheMissRatio.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSgaSharedPoolLibraryCacheHitRatioDataPoint adds a data point to newrelicoracledb.sga_shared_pool_library_cache_hit_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSgaSharedPoolLibraryCacheHitRatioDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSgaSharedPoolLibraryCacheHitRatio.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSgaSharedPoolLibraryCacheReloadRatioDataPoint adds a data point to newrelicoracledb.sga_shared_pool_library_cache_reload_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSgaSharedPoolLibraryCacheReloadRatioDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSgaSharedPoolLibraryCacheReloadRatio.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSortsDiskDataPoint adds a data point to newrelicoracledb.sorts_disk metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSortsDiskDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSortsDisk.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSortsMemoryDataPoint adds a data point to newrelicoracledb.sorts_memory metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSortsMemoryDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSortsMemory.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemActiveParallelSessionsDataPoint adds a data point to newrelicoracledb.system.active_parallel_sessions metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemActiveParallelSessionsDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemActiveParallelSessions.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemActiveSerialSessionsDataPoint adds a data point to newrelicoracledb.system.active_serial_sessions metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemActiveSerialSessionsDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemActiveSerialSessions.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemAverageActiveSessionsDataPoint adds a data point to newrelicoracledb.system.average_active_sessions metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemAverageActiveSessionsDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemAverageActiveSessions.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemBackgroundCheckpointsPerSecondDataPoint adds a data point to newrelicoracledb.system.background_checkpoints_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemBackgroundCheckpointsPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemBackgroundCheckpointsPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemBackgroundCPUUsagePerSecondDataPoint adds a data point to newrelicoracledb.system.background_cpu_usage_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemBackgroundCPUUsagePerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemBackgroundCPUUsagePerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemBackgroundTimePerSecondDataPoint adds a data point to newrelicoracledb.system.background_time_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemBackgroundTimePerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemBackgroundTimePerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemBranchNodeSplitsPerSecondDataPoint adds a data point to newrelicoracledb.system.branch_node_splits_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemBranchNodeSplitsPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemBranchNodeSplitsPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemBranchNodeSplitsPerTransactionDataPoint adds a data point to newrelicoracledb.system.branch_node_splits_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemBranchNodeSplitsPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemBranchNodeSplitsPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemBufferCacheHitRatioDataPoint adds a data point to newrelicoracledb.system.buffer_cache_hit_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemBufferCacheHitRatioDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemBufferCacheHitRatio.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemCapturedUserCallsDataPoint adds a data point to newrelicoracledb.system.captured_user_calls metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemCapturedUserCallsDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemCapturedUserCalls.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemConsistentReadChangesPerSecondDataPoint adds a data point to newrelicoracledb.system.consistent_read_changes_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemConsistentReadChangesPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemConsistentReadChangesPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemConsistentReadChangesPerTransactionDataPoint adds a data point to newrelicoracledb.system.consistent_read_changes_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemConsistentReadChangesPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemConsistentReadChangesPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemConsistentReadGetsPerSecondDataPoint adds a data point to newrelicoracledb.system.consistent_read_gets_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemConsistentReadGetsPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemConsistentReadGetsPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemConsistentReadGetsPerTransactionDataPoint adds a data point to newrelicoracledb.system.consistent_read_gets_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemConsistentReadGetsPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemConsistentReadGetsPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemCPUUsagePerSecondDataPoint adds a data point to newrelicoracledb.system.cpu_usage_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemCPUUsagePerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemCPUUsagePerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemCPUUsagePerTransactionDataPoint adds a data point to newrelicoracledb.system.cpu_usage_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemCPUUsagePerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemCPUUsagePerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemCrBlocksCreatedPerSecondDataPoint adds a data point to newrelicoracledb.system.cr_blocks_created_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemCrBlocksCreatedPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemCrBlocksCreatedPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemCrBlocksCreatedPerTransactionDataPoint adds a data point to newrelicoracledb.system.cr_blocks_created_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemCrBlocksCreatedPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemCrBlocksCreatedPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemCrUndoRecordsAppliedPerSecondDataPoint adds a data point to newrelicoracledb.system.cr_undo_records_applied_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemCrUndoRecordsAppliedPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemCrUndoRecordsAppliedPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemCrUndoRecordsAppliedPerTransactionDataPoint adds a data point to newrelicoracledb.system.cr_undo_records_applied_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemCrUndoRecordsAppliedPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemCrUndoRecordsAppliedPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemCurrentLogonsCountDataPoint adds a data point to newrelicoracledb.system.current_logons_count metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemCurrentLogonsCountDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemCurrentLogonsCount.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemCurrentOpenCursorsCountDataPoint adds a data point to newrelicoracledb.system.current_open_cursors_count metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemCurrentOpenCursorsCountDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemCurrentOpenCursorsCount.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemCurrentOsLoadDataPoint adds a data point to newrelicoracledb.system.current_os_load metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemCurrentOsLoadDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemCurrentOsLoad.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemCursorCacheHitRatioDataPoint adds a data point to newrelicoracledb.system.cursor_cache_hit_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemCursorCacheHitRatioDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemCursorCacheHitRatio.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemDatabaseCPUTimeRatioDataPoint adds a data point to newrelicoracledb.system.database_cpu_time_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemDatabaseCPUTimeRatioDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemDatabaseCPUTimeRatio.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemDatabaseTimePerSecondDataPoint adds a data point to newrelicoracledb.system.database_time_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemDatabaseTimePerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemDatabaseTimePerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemDatabaseWaitTimeRatioDataPoint adds a data point to newrelicoracledb.system.database_wait_time_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemDatabaseWaitTimeRatioDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemDatabaseWaitTimeRatio.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemDbBlockChangesPerSecondDataPoint adds a data point to newrelicoracledb.system.db_block_changes_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemDbBlockChangesPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemDbBlockChangesPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemDbBlockChangesPerTransactionDataPoint adds a data point to newrelicoracledb.system.db_block_changes_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemDbBlockChangesPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemDbBlockChangesPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemDbBlockChangesPerUserCallDataPoint adds a data point to newrelicoracledb.system.db_block_changes_per_user_call metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemDbBlockChangesPerUserCallDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemDbBlockChangesPerUserCall.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemDbBlockGetsPerSecondDataPoint adds a data point to newrelicoracledb.system.db_block_gets_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemDbBlockGetsPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemDbBlockGetsPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemDbBlockGetsPerTransactionDataPoint adds a data point to newrelicoracledb.system.db_block_gets_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemDbBlockGetsPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemDbBlockGetsPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemDbBlockGetsPerUserCallDataPoint adds a data point to newrelicoracledb.system.db_block_gets_per_user_call metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemDbBlockGetsPerUserCallDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemDbBlockGetsPerUserCall.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemDbwrCheckpointsPerSecondDataPoint adds a data point to newrelicoracledb.system.dbwr_checkpoints_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemDbwrCheckpointsPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemDbwrCheckpointsPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemDiskSortPerSecondDataPoint adds a data point to newrelicoracledb.system.disk_sort_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemDiskSortPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemDiskSortPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemDiskSortPerTransactionDataPoint adds a data point to newrelicoracledb.system.disk_sort_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemDiskSortPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemDiskSortPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemEnqueueDeadlocksPerSecondDataPoint adds a data point to newrelicoracledb.system.enqueue_deadlocks_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemEnqueueDeadlocksPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemEnqueueDeadlocksPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemEnqueueDeadlocksPerTransactionDataPoint adds a data point to newrelicoracledb.system.enqueue_deadlocks_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemEnqueueDeadlocksPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemEnqueueDeadlocksPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemEnqueueRequestsPerSecondDataPoint adds a data point to newrelicoracledb.system.enqueue_requests_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemEnqueueRequestsPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemEnqueueRequestsPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemEnqueueRequestsPerTransactionDataPoint adds a data point to newrelicoracledb.system.enqueue_requests_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemEnqueueRequestsPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemEnqueueRequestsPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemEnqueueTimeoutsPerSecondDataPoint adds a data point to newrelicoracledb.system.enqueue_timeouts_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemEnqueueTimeoutsPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemEnqueueTimeoutsPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemEnqueueTimeoutsPerTransactionDataPoint adds a data point to newrelicoracledb.system.enqueue_timeouts_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemEnqueueTimeoutsPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemEnqueueTimeoutsPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemEnqueueWaitsPerSecondDataPoint adds a data point to newrelicoracledb.system.enqueue_waits_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemEnqueueWaitsPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemEnqueueWaitsPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemEnqueueWaitsPerTransactionDataPoint adds a data point to newrelicoracledb.system.enqueue_waits_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemEnqueueWaitsPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemEnqueueWaitsPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemExecuteWithoutParseRatioDataPoint adds a data point to newrelicoracledb.system.execute_without_parse_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemExecuteWithoutParseRatioDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemExecuteWithoutParseRatio.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemExecutionsPerSecondDataPoint adds a data point to newrelicoracledb.system.executions_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemExecutionsPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemExecutionsPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemExecutionsPerTransactionDataPoint adds a data point to newrelicoracledb.system.executions_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemExecutionsPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemExecutionsPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemExecutionsPerUserCallDataPoint adds a data point to newrelicoracledb.system.executions_per_user_call metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemExecutionsPerUserCallDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemExecutionsPerUserCall.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemFullIndexScansPerSecondDataPoint adds a data point to newrelicoracledb.system.full_index_scans_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemFullIndexScansPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemFullIndexScansPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemFullIndexScansPerTransactionDataPoint adds a data point to newrelicoracledb.system.full_index_scans_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemFullIndexScansPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemFullIndexScansPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemGcCrBlockReceivedPerSecondDataPoint adds a data point to newrelicoracledb.system.gc_cr_block_received_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemGcCrBlockReceivedPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemGcCrBlockReceivedPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemGcCrBlockReceivedPerTransactionDataPoint adds a data point to newrelicoracledb.system.gc_cr_block_received_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemGcCrBlockReceivedPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemGcCrBlockReceivedPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemGcCurrentBlockReceivedPerSecondDataPoint adds a data point to newrelicoracledb.system.gc_current_block_received_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemGcCurrentBlockReceivedPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemGcCurrentBlockReceivedPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemGcCurrentBlockReceivedPerTransactionDataPoint adds a data point to newrelicoracledb.system.gc_current_block_received_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemGcCurrentBlockReceivedPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemGcCurrentBlockReceivedPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemGlobalCacheAverageCrGetTimeDataPoint adds a data point to newrelicoracledb.system.global_cache_average_cr_get_time metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemGlobalCacheAverageCrGetTimeDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemGlobalCacheAverageCrGetTime.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemGlobalCacheAverageCurrentGetTimeDataPoint adds a data point to newrelicoracledb.system.global_cache_average_current_get_time metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemGlobalCacheAverageCurrentGetTimeDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemGlobalCacheAverageCurrentGetTime.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemGlobalCacheBlocksCorruptedDataPoint adds a data point to newrelicoracledb.system.global_cache_blocks_corrupted metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemGlobalCacheBlocksCorruptedDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemGlobalCacheBlocksCorrupted.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemGlobalCacheBlocksLostDataPoint adds a data point to newrelicoracledb.system.global_cache_blocks_lost metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemGlobalCacheBlocksLostDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemGlobalCacheBlocksLost.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemHardParseCountPerSecondDataPoint adds a data point to newrelicoracledb.system.hard_parse_count_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemHardParseCountPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemHardParseCountPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemHardParseCountPerTransactionDataPoint adds a data point to newrelicoracledb.system.hard_parse_count_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemHardParseCountPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemHardParseCountPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemHostCPUUsagePerSecondDataPoint adds a data point to newrelicoracledb.system.host_cpu_usage_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemHostCPUUsagePerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemHostCPUUsagePerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemHostCPUUtilizationDataPoint adds a data point to newrelicoracledb.system.host_cpu_utilization metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemHostCPUUtilizationDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemHostCPUUtilization.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemIoMegabytesPerSecondDataPoint adds a data point to newrelicoracledb.system.io_megabytes_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemIoMegabytesPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemIoMegabytesPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemIoRequestsPerSecondDataPoint adds a data point to newrelicoracledb.system.io_requests_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemIoRequestsPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemIoRequestsPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemLeafNodeSplitsPerSecondDataPoint adds a data point to newrelicoracledb.system.leaf_node_splits_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemLeafNodeSplitsPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemLeafNodeSplitsPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemLeafNodeSplitsPerTransactionDataPoint adds a data point to newrelicoracledb.system.leaf_node_splits_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemLeafNodeSplitsPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemLeafNodeSplitsPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemLibraryCacheHitRatioDataPoint adds a data point to newrelicoracledb.system.library_cache_hit_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemLibraryCacheHitRatioDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemLibraryCacheHitRatio.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemLibraryCacheMissRatioDataPoint adds a data point to newrelicoracledb.system.library_cache_miss_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemLibraryCacheMissRatioDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemLibraryCacheMissRatio.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemLogicalReadsPerSecondDataPoint adds a data point to newrelicoracledb.system.logical_reads_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemLogicalReadsPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemLogicalReadsPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemLogicalReadsPerTransactionDataPoint adds a data point to newrelicoracledb.system.logical_reads_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemLogicalReadsPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemLogicalReadsPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemLogicalReadsPerUserCallDataPoint adds a data point to newrelicoracledb.system.logical_reads_per_user_call metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemLogicalReadsPerUserCallDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemLogicalReadsPerUserCall.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemLogonsPerSecondDataPoint adds a data point to newrelicoracledb.system.logons_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemLogonsPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemLogonsPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemLogonsPerTransactionDataPoint adds a data point to newrelicoracledb.system.logons_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemLogonsPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemLogonsPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemLongTableScansPerSecondDataPoint adds a data point to newrelicoracledb.system.long_table_scans_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemLongTableScansPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemLongTableScansPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemLongTableScansPerTransactionDataPoint adds a data point to newrelicoracledb.system.long_table_scans_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemLongTableScansPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemLongTableScansPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemMemorySortsRatioDataPoint adds a data point to newrelicoracledb.system.memory_sorts_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemMemorySortsRatioDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemMemorySortsRatio.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemNetworkTrafficVolumePerSecondDataPoint adds a data point to newrelicoracledb.system.network_traffic_volume_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemNetworkTrafficVolumePerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemNetworkTrafficVolumePerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemOpenCursorsPerSecondDataPoint adds a data point to newrelicoracledb.system.open_cursors_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemOpenCursorsPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemOpenCursorsPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemOpenCursorsPerTransactionDataPoint adds a data point to newrelicoracledb.system.open_cursors_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemOpenCursorsPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemOpenCursorsPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemParseFailureCountPerSecondDataPoint adds a data point to newrelicoracledb.system.parse_failure_count_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemParseFailureCountPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemParseFailureCountPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemParseFailureCountPerTransactionDataPoint adds a data point to newrelicoracledb.system.parse_failure_count_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemParseFailureCountPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemParseFailureCountPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemPgaCacheHitPercentageDataPoint adds a data point to newrelicoracledb.system.pga_cache_hit_percentage metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemPgaCacheHitPercentageDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemPgaCacheHitPercentage.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemPhysicalLobsReadsPerSecondDataPoint adds a data point to newrelicoracledb.system.physical_lobs_reads_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemPhysicalLobsReadsPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemPhysicalLobsReadsPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemPhysicalLobsReadsPerTransactionDataPoint adds a data point to newrelicoracledb.system.physical_lobs_reads_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemPhysicalLobsReadsPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemPhysicalLobsReadsPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemPhysicalLobsWritesPerSecondDataPoint adds a data point to newrelicoracledb.system.physical_lobs_writes_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemPhysicalLobsWritesPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemPhysicalLobsWritesPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemPhysicalLobsWritesPerTransactionDataPoint adds a data point to newrelicoracledb.system.physical_lobs_writes_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemPhysicalLobsWritesPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemPhysicalLobsWritesPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemPhysicalReadBytesPerSecondDataPoint adds a data point to newrelicoracledb.system.physical_read_bytes_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemPhysicalReadBytesPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemPhysicalReadBytesPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemPhysicalReadIoRequestsPerSecondDataPoint adds a data point to newrelicoracledb.system.physical_read_io_requests_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemPhysicalReadIoRequestsPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemPhysicalReadIoRequestsPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemPhysicalReadTotalBytesPerSecondDataPoint adds a data point to newrelicoracledb.system.physical_read_total_bytes_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemPhysicalReadTotalBytesPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemPhysicalReadTotalBytesPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemPhysicalReadTotalIoRequestsPerSecondDataPoint adds a data point to newrelicoracledb.system.physical_read_total_io_requests_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemPhysicalReadTotalIoRequestsPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemPhysicalReadTotalIoRequestsPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemPhysicalReadsDirectPerSecondDataPoint adds a data point to newrelicoracledb.system.physical_reads_direct_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemPhysicalReadsDirectPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemPhysicalReadsDirectPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemPhysicalReadsDirectPerTransactionDataPoint adds a data point to newrelicoracledb.system.physical_reads_direct_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemPhysicalReadsDirectPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemPhysicalReadsDirectPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemPhysicalReadsPerSecondDataPoint adds a data point to newrelicoracledb.system.physical_reads_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemPhysicalReadsPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemPhysicalReadsPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemPhysicalReadsPerTransactionDataPoint adds a data point to newrelicoracledb.system.physical_reads_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemPhysicalReadsPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemPhysicalReadsPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemPhysicalWriteBytesPerSecondDataPoint adds a data point to newrelicoracledb.system.physical_write_bytes_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemPhysicalWriteBytesPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemPhysicalWriteBytesPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemPhysicalWriteIoRequestsPerSecondDataPoint adds a data point to newrelicoracledb.system.physical_write_io_requests_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemPhysicalWriteIoRequestsPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemPhysicalWriteIoRequestsPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemPhysicalWriteTotalBytesPerSecondDataPoint adds a data point to newrelicoracledb.system.physical_write_total_bytes_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemPhysicalWriteTotalBytesPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemPhysicalWriteTotalBytesPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemPhysicalWriteTotalIoRequestsPerSecondDataPoint adds a data point to newrelicoracledb.system.physical_write_total_io_requests_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemPhysicalWriteTotalIoRequestsPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemPhysicalWriteTotalIoRequestsPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemPhysicalWritesDirectPerSecondDataPoint adds a data point to newrelicoracledb.system.physical_writes_direct_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemPhysicalWritesDirectPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemPhysicalWritesDirectPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemPhysicalWritesDirectPerTransactionDataPoint adds a data point to newrelicoracledb.system.physical_writes_direct_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemPhysicalWritesDirectPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemPhysicalWritesDirectPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemPhysicalWritesPerSecondDataPoint adds a data point to newrelicoracledb.system.physical_writes_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemPhysicalWritesPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemPhysicalWritesPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemPhysicalWritesPerTransactionDataPoint adds a data point to newrelicoracledb.system.physical_writes_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemPhysicalWritesPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemPhysicalWritesPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemProcessLimitPercentageDataPoint adds a data point to newrelicoracledb.system.process_limit_percentage metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemProcessLimitPercentageDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemProcessLimitPercentage.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemRecursiveCallsPerSecondDataPoint adds a data point to newrelicoracledb.system.recursive_calls_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemRecursiveCallsPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemRecursiveCallsPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemRecursiveCallsPerTransactionDataPoint adds a data point to newrelicoracledb.system.recursive_calls_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemRecursiveCallsPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemRecursiveCallsPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemRedoAllocationHitRatioDataPoint adds a data point to newrelicoracledb.system.redo_allocation_hit_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemRedoAllocationHitRatioDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemRedoAllocationHitRatio.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemRedoGeneratedBytesPerSecondDataPoint adds a data point to newrelicoracledb.system.redo_generated_bytes_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemRedoGeneratedBytesPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemRedoGeneratedBytesPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemRedoGeneratedBytesPerTransactionDataPoint adds a data point to newrelicoracledb.system.redo_generated_bytes_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemRedoGeneratedBytesPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemRedoGeneratedBytesPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemRedoWritesPerSecondDataPoint adds a data point to newrelicoracledb.system.redo_writes_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemRedoWritesPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemRedoWritesPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemRedoWritesPerTransactionDataPoint adds a data point to newrelicoracledb.system.redo_writes_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemRedoWritesPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemRedoWritesPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemResponseTimePerTransactionDataPoint adds a data point to newrelicoracledb.system.response_time_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemResponseTimePerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemResponseTimePerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemRowCacheHitRatioDataPoint adds a data point to newrelicoracledb.system.row_cache_hit_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemRowCacheHitRatioDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemRowCacheHitRatio.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemRowCacheMissRatioDataPoint adds a data point to newrelicoracledb.system.row_cache_miss_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemRowCacheMissRatioDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemRowCacheMissRatio.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemRowsPerSortDataPoint adds a data point to newrelicoracledb.system.rows_per_sort metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemRowsPerSortDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemRowsPerSort.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemSessionCountDataPoint adds a data point to newrelicoracledb.system.session_count metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemSessionCountDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemSessionCount.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemSessionLimitPercentageDataPoint adds a data point to newrelicoracledb.system.session_limit_percentage metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemSessionLimitPercentageDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemSessionLimitPercentage.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemSharedPoolFreePercentageDataPoint adds a data point to newrelicoracledb.system.shared_pool_free_percentage metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemSharedPoolFreePercentageDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemSharedPoolFreePercentage.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemSoftParseRatioDataPoint adds a data point to newrelicoracledb.system.soft_parse_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemSoftParseRatioDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemSoftParseRatio.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemSQLServiceResponseTimeDataPoint adds a data point to newrelicoracledb.system.sql_service_response_time metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemSQLServiceResponseTimeDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemSQLServiceResponseTime.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemStreamsPoolUsagePercentageDataPoint adds a data point to newrelicoracledb.system.streams_pool_usage_percentage metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemStreamsPoolUsagePercentageDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemStreamsPoolUsagePercentage.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemTempSpaceUsedDataPoint adds a data point to newrelicoracledb.system.temp_space_used metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemTempSpaceUsedDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemTempSpaceUsed.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemTotalIndexScansPerSecondDataPoint adds a data point to newrelicoracledb.system.total_index_scans_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemTotalIndexScansPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemTotalIndexScansPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemTotalIndexScansPerTransactionDataPoint adds a data point to newrelicoracledb.system.total_index_scans_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemTotalIndexScansPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemTotalIndexScansPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemTotalParseCountPerSecondDataPoint adds a data point to newrelicoracledb.system.total_parse_count_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemTotalParseCountPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemTotalParseCountPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemTotalParseCountPerTransactionDataPoint adds a data point to newrelicoracledb.system.total_parse_count_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemTotalParseCountPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemTotalParseCountPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemTotalSortsPerUserCallDataPoint adds a data point to newrelicoracledb.system.total_sorts_per_user_call metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemTotalSortsPerUserCallDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemTotalSortsPerUserCall.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemTotalTableScansPerSecondDataPoint adds a data point to newrelicoracledb.system.total_table_scans_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemTotalTableScansPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemTotalTableScansPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemTotalTableScansPerTransactionDataPoint adds a data point to newrelicoracledb.system.total_table_scans_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemTotalTableScansPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemTotalTableScansPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemTotalTableScansPerUserCallDataPoint adds a data point to newrelicoracledb.system.total_table_scans_per_user_call metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemTotalTableScansPerUserCallDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemTotalTableScansPerUserCall.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemTransactionsPerLogonDataPoint adds a data point to newrelicoracledb.system.transactions_per_logon metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemTransactionsPerLogonDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemTransactionsPerLogon.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemTransactionsPerSecondDataPoint adds a data point to newrelicoracledb.system.transactions_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemTransactionsPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemTransactionsPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemUserCallsPerSecondDataPoint adds a data point to newrelicoracledb.system.user_calls_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemUserCallsPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemUserCallsPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemUserCallsPerTransactionDataPoint adds a data point to newrelicoracledb.system.user_calls_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemUserCallsPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemUserCallsPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemUserCallsRatioDataPoint adds a data point to newrelicoracledb.system.user_calls_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemUserCallsRatioDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemUserCallsRatio.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemUserCommitsPerSecondDataPoint adds a data point to newrelicoracledb.system.user_commits_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemUserCommitsPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemUserCommitsPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemUserCommitsPercentageDataPoint adds a data point to newrelicoracledb.system.user_commits_percentage metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemUserCommitsPercentageDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemUserCommitsPercentage.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemUserLimitPercentageDataPoint adds a data point to newrelicoracledb.system.user_limit_percentage metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemUserLimitPercentageDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemUserLimitPercentage.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerSecondDataPoint adds a data point to newrelicoracledb.system.user_rollback_undo_records_applied_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerTransactionDataPoint adds a data point to newrelicoracledb.system.user_rollback_undo_records_applied_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerTransactionDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemUserRollbackUndoRecordsAppliedPerTransaction.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemUserRollbacksPerSecondDataPoint adds a data point to newrelicoracledb.system.user_rollbacks_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemUserRollbacksPerSecondDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemUserRollbacksPerSecond.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbSystemUserRollbacksPercentageDataPoint adds a data point to newrelicoracledb.system.user_rollbacks_percentage metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbSystemUserRollbacksPercentageDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, instanceIDAttributeValue string) {
	mb.metricNewrelicoracledbSystemUserRollbacksPercentage.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, instanceIDAttributeValue)
}

// RecordNewrelicoracledbTablespaceDbIDDataPoint adds a data point to newrelicoracledb.tablespace.db_id metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbTablespaceDbIDDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, tablespaceNameAttributeValue string) {
	mb.metricNewrelicoracledbTablespaceDbID.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, tablespaceNameAttributeValue)
}

// RecordNewrelicoracledbTablespaceGlobalNameDataPoint adds a data point to newrelicoracledb.tablespace.global_name metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbTablespaceGlobalNameDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, tablespaceNameAttributeValue string) {
	mb.metricNewrelicoracledbTablespaceGlobalName.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, tablespaceNameAttributeValue)
}

// RecordNewrelicoracledbTablespaceIsOfflineDataPoint adds a data point to newrelicoracledb.tablespace.is_offline metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbTablespaceIsOfflineDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, tablespaceNameAttributeValue string) {
	mb.metricNewrelicoracledbTablespaceIsOffline.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, tablespaceNameAttributeValue)
}

// RecordNewrelicoracledbTablespaceOfflineCdbDatafilesDataPoint adds a data point to newrelicoracledb.tablespace.offline_cdb_datafiles metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbTablespaceOfflineCdbDatafilesDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, tablespaceNameAttributeValue string) {
	mb.metricNewrelicoracledbTablespaceOfflineCdbDatafiles.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, tablespaceNameAttributeValue)
}

// RecordNewrelicoracledbTablespaceOfflinePdbDatafilesDataPoint adds a data point to newrelicoracledb.tablespace.offline_pdb_datafiles metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbTablespaceOfflinePdbDatafilesDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, tablespaceNameAttributeValue string) {
	mb.metricNewrelicoracledbTablespaceOfflinePdbDatafiles.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, tablespaceNameAttributeValue)
}

// RecordNewrelicoracledbTablespacePdbNonWriteModeDataPoint adds a data point to newrelicoracledb.tablespace.pdb_non_write_mode metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbTablespacePdbNonWriteModeDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, tablespaceNameAttributeValue string) {
	mb.metricNewrelicoracledbTablespacePdbNonWriteMode.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, tablespaceNameAttributeValue)
}

// RecordNewrelicoracledbTablespaceSpaceConsumedBytesDataPoint adds a data point to newrelicoracledb.tablespace.space_consumed_bytes metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbTablespaceSpaceConsumedBytesDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, tablespaceNameAttributeValue string) {
	mb.metricNewrelicoracledbTablespaceSpaceConsumedBytes.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, tablespaceNameAttributeValue)
}

// RecordNewrelicoracledbTablespaceSpaceReservedBytesDataPoint adds a data point to newrelicoracledb.tablespace.space_reserved_bytes metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbTablespaceSpaceReservedBytesDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, tablespaceNameAttributeValue string) {
	mb.metricNewrelicoracledbTablespaceSpaceReservedBytes.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, tablespaceNameAttributeValue)
}

// RecordNewrelicoracledbTablespaceSpaceUsedPercentageDataPoint adds a data point to newrelicoracledb.tablespace.space_used_percentage metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbTablespaceSpaceUsedPercentageDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, tablespaceNameAttributeValue string) {
	mb.metricNewrelicoracledbTablespaceSpaceUsedPercentage.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, tablespaceNameAttributeValue)
}

// RecordNewrelicoracledbTablespaceTotalBytesDataPoint adds a data point to newrelicoracledb.tablespace.total_bytes metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbTablespaceTotalBytesDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, conIDAttributeValue string, tablespaceNameAttributeValue string) {
	mb.metricNewrelicoracledbTablespaceTotalBytes.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, conIDAttributeValue, tablespaceNameAttributeValue)
}

// RecordNewrelicoracledbTablespaceUsedBytesDataPoint adds a data point to newrelicoracledb.tablespace.used_bytes metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbTablespaceUsedBytesDataPoint(ts pcommon.Timestamp, val int64, dbInstanceNameAttributeValue string, conIDAttributeValue string, tablespaceNameAttributeValue string) {
	mb.metricNewrelicoracledbTablespaceUsedBytes.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, conIDAttributeValue, tablespaceNameAttributeValue)
}

// RecordNewrelicoracledbTablespaceUsedPercentDataPoint adds a data point to newrelicoracledb.tablespace.used_percent metric.
func (mb *MetricsBuilder) RecordNewrelicoracledbTablespaceUsedPercentDataPoint(ts pcommon.Timestamp, val float64, dbInstanceNameAttributeValue string, conIDAttributeValue string, tablespaceNameAttributeValue string) {
	mb.metricNewrelicoracledbTablespaceUsedPercent.recordDataPoint(mb.startTime, ts, val, dbInstanceNameAttributeValue, conIDAttributeValue, tablespaceNameAttributeValue)
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...MetricBuilderOption) {
	mb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op.apply(mb)
	}
}
